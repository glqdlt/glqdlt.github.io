## 역자 서문
## 서문
## 초판의 서문
## 감사의 글
## 이 책에 대해
## 저자 소개
## 표지 일러스트 소개

## 1부 JUnit 기본

## 1장 JUnit 첫걸음
## 1.1 동작 증명하기
## 1.2 밑그림부터 시작하기
## 1.3 단위 테스트 프레임워크 이해하기
## 1.4 JUnit의 설계 목표
## 1.5 JUnit 셋업하기
## 1.6. JUnit으로 테스트 실행하기
## 1.7 정리

## 2장 JUnit 핵심 들여다보기
## 2.1. JUnit의 핵심
## 2.2 파라미터화 테스트 실행하기
## 2.3 JUnit 테스트 러너
## 2.3.1 테스트 러너 개요
## 2.3.2 JUnitCore 퍼사드
## 2.3.3 자신만의 테스트 러너 만들기
## 2.4 스위트를 이용한 테스트 조직하기
## 2.4.1. 테스트 클래스 집합 만들기
## 2.4.2 스위트의 스위트 만들기
## 2.4.3 스위트 vs. IDE, Ant, Maven
## 2.5 정리

## 3장 JUnit 마스터하기
## 3.1 컨트롤러 컴포넌트 소개
## 3.1.1 인터페이스 설계하기
## 3.1.2 기반 클래스 구현하기
## 3.2 자! 이제 테스트다!
## 3.2.1 DefaultController 테스트하기
## 3.2.2 핸들러 추가하기
## 3.2.3 요청 처리하기
## 3.2.4 testProcessRequest 개선하기
## 3.3 예외 처리 테스트하기
## 3.3.1 예외 상황 시뮬레이션하기
## 3.3.2 예외 테스트하기
## 3.4 타임아웃 테스트하기
## 3.5 Hamcrest 매처 소개
## 3.6 테스트 프로젝트 셋업하기
## 3.7 정리

## 4장 소프트웨어 테스트 원칙
## 4.1 단위 테스트가 필요한 이유
## 4.1.1 높은 테스트 커버리지 달성
## 4.1.2 팀 생산성 향상
## 4.1.3 회귀 테스트 수행 및 디버깅 감소
## 4.1.4 확신에 찬 리팩터링
## 4.1.5 구현 품질 향상
## 4.1.6 기대 행위 문서화
## 4.1.7 코드 커버리지 등 각종 측정이 가능
## 4.2. 테스트의 종류
## 4.2.1 소프트웨어 테스트의 네 가지 종류
## 4.2.2 단위 테스트의 종류 세 가지
## 4.3 블랙박스 테스트와 화이트박스 테스트
## 4.4 정리

## 2부 다채로운 테스트 전략

## 5장 테스트 커버리지와 개발
## 5.1 테스트 커버리지 측정하기
## 5.1.1 테스트 커버리지란?
## 5.1.2 Cobertura 소개
## 5.1.3 테스트 커버리지 보고서 생성하기
## 5.1.4 블랙박스 테스트와 화이트박스 테스트 혼용하기
## 5.2. 테스트 가능한 코드 작성하기
## 5.2.1 공개 API는 계약이다
## 5.2.2 종속성을 줄여라
## 5.2.3 생성자는 간단하게 만들어라
## 5.2.4 최소 지식의 원칙을 따르라
## 5.2.5 숨겨진 종속성과 전역 상태를 피하라
## 5.2.6 싱글톤의 장단점
## 5.2.7 제너릭 메서드를 애용하라
## 5.2.8 상속보다 컴포지션을 활용하라
## 5.2.9 조건 분기보다 다형성을 활용하라
## 5.3. 테스트 주도 개발
## 5.3.1 개발 주기 조정하기
## 5.3.2 TDD 실천으로 가는 두 단계
## 5.4 개발 주기에서의 테스트
## 5.5 정리

## 6장 스텁을 활용한 포괄적인 테스트
## 6.1. 스텁이란?
## 6.2 HTTP 커넥션을 스텁으로 대체하기
## 6.2.1 스텁 방식 선택하기
## 6.2.2 임베디드 서버로 Jetty 활용하기
## 6.3 웹 서버의 리소스를 스텁으로 대체하기
## 6.3.1 첫 번째 스텁 테스트 설정하기
## 6.3.2 실패 조건 테스트하기
## 6.3.3 첫 번째 스텁 테스트 되돌아보기
## 6.4 커넥션 스텁 작성하기
## 6.4.1 커스텀 URL 프로토콜 핸들러 제작하기
## 6.4.2 JDK HttpURLConnection 스텁 작성하기
## 6.4.3 테스트 실행하기
## 6.5 정리

## 7장 목 객체를 활용한 테스트
## 7.1 목 객체 소개하기
## 7.2 목 객체를 활용해 단위 테스트하기
## 7.3 목 객체와 함께 리팩터링하기
## 7.3.1 예제 리팩터링하기
## 7.4 HTTP 커넥션을 목으로 대체하기
## 7.4.1 목 객체 정의하기
## 7.4.2 예제 메서드 테스트하기
## 7.4.3 첫 번째 시도: 손쉬운 메서드 리팩터링 기법
## 7.4.4 두 번째 시도: 클래스 팩토리를 활용한 리팩터링
## 7.5 목 객체를 트로이 목마로 사용하기
## 7.6 목 프레임워크 만나보기
## 7.6.1 EasyMock 활용하기
## 7.6.2 JMock 활용하기
## 7.7 정리

## 8장 In-container 테스트
## 8.1 표준 단위 테스트의 한계
## 8.2 목 객체를 이용한 해법
## 8.3 In-container 테스트
## 8.3.1 전략 구현하기
## 8.3.2 In-container 테스트 프레임워크
## 8.4 스텁, 목 객체, In-container 테스트 비교하기
## 8.4.1 스텁의 장단점
## 8.4.2 목 객체의 장단점
## 8.4.3 In-container 테스트의 장단점
## 8.4.4 In-container 테스트 vs. Out-of-container 테스트
## 8.5 정리

## 3부 JUnit과 빌드 프로세스

## 9장 Ant로 JUnit 테스트 실행하기
## 9.1 개발자의 하루
## 9.2 Ant로 테스트 실행하기
## 9.3 Ant 소개 및 설치하기
## 9.4 Ant의 타깃, 프로젝트, 속성, 태스크 알아보기
## 9.4.1 javac 태스크
## 9.4.2 junit 태스크
## 9.5 Ant 실행하기
## 9.6 Ivy를 이용한 종속성 관리
## 9.7 HTML 보고서 생성하기
## 9.8 테스트 일괄 수행하기
## 9.9 정리

## 10장 Maven2로 JUnit 테스트 실행하기
## 10.1 Maven의 특성
## 10.1.1 규약이 설정에 우선한다
## 10.1.2 강력한 종속성 관리
## 10.1.3 Maven 빌드 생명주기
## 10.1.4 플러그인 기반 아키텍처
## 10.1.5 Maven 프로젝트 객체 모델(POM)
## 10.2 Maven 프로젝트 구성하기
## 10.3 Maven 플러그인 소개하기
## 10.3.1 Maven Compiler 플러그인
## 10.3.2 Maven Surefire 플러그인
## 10.3.3 Maven으로 HTML JUnit 보고서 생성하기
## 10.4 Maven의 부정적 측면
## 10.5 정리

## 11장 지속적 통합 툴
## 11.1 지속적 통합의 맛
## 11.1.1 지속적 통합 테스트
## 11.2 구원투수 CruiseControl
## 11.2.1 CruiseControl 시작하기
## 11.2.2 견본 프로젝트 설정하기
## 11.2.3 CruiseControl 설정 파일 살펴보기
## 11.3 또 하나의 멋진 구원자 Hudson
## 11.3.1 Hudson 소개하기
## 11.3.2 Hudson 설치하기
## 11.3.3 Hudson 설정하기
## 11.3.4 Hudson 안에 프로젝트 설정하기
## 11.4 지속적 통합으로 얻는 이점
## 11.5 정리

## 4부 JUnit 확장

## 12장 표현 계층 테스트하기
## 12.1 테스트 프레임워크 선택하기
## 12.2 HtmlUnit 소개하기
## 12.2.1 실생활에서 찾을 수 있는 예
## 12.3 HtmlUnit 테스트 작성하기
## 12.3.1 HTML 단언
## 12.3.2 특정 웹 브라우저를 위한 테스트
## 12.3.3 다수의 웹 브라우저 테스트
## 12.3.4 독립형 테스트 작성하기
## 12.3.5 객체 모델 내비게이션
## 12.3.6 원소 타입으로 원소 접근하기
## 12.3.7 이름 vs. 인덱스로 원소 접근하기
## 12.3.8 참고를 통해 원소 접근하기
## 12.3.9 XPath 사용하기
## 12.3.10 테스트 실패와 예외
## 12.3.11 애플리케이션과 인터넷 내비게이션
## 12.3.12 HtmlUnit으로 폼 테스트하기
## 12.3.13 프레임 테스트하기
## 12.3.14 자바스크립트를 이용해 테스트하기
## 12.3.15 CSS 테스트하기
## 12.3.16 SSL 에러
## 12.4 HtmlUnit과 Cactus 함께 사용하기
## 12.4.1 Cactus로 테스트 작성하기
## 12.5 Selenium 소개
## 12.6 Selenium 테스트 생성하기
## 12.6.1 실생활에서 찾을 수 있는 예
## 12.7 Selenium 테스트 실행하기
## 12.7.1 Selenium 서버 관리하기
## 12.7.2 JUnit 4로 Selenium 테스트 실행하기
## 12.8 Selenium 테스트 작성하기
## 12.8.1 특정 웹 브라우저를 겨냥한 테스트 수행하기
## 12.8.2 브라우저별 테스트 한 번에 수행하기
## 12.8.3 애플리케이션과 인터넷 내비게이션
## 12.8.4 참조를 이용해 원소 접근하기
## 12.8.5 예외를 발생시켜 테스트 실패시키기
## 12.8.6 Selenium으로 폼 테스트하기
## 12.8.7 자바스크립트 경고를 이용해 테스트하기
## 12.8.8 JUnit 3 테스트 실패 시 화면 캡처하기
## 12.8.9 JUnit 4 테스트 실패 시 화면 캡처하기
## 12.9 HtmlUnit vs. Selenium
## 12.10 정리

## 13장 Ajax 테스트하기
## 13.1 Ajax 애플리케이션 테스트는 왜 어려운가?
## 13.1.1 웹의 전통적 상호작용 방식
## 13.1.2 Ajax의 상호작용
## 13.1.3 용감한 신세계
## 13.1.4 테스트를 위해 극복해야 할 난제들
## 13.2 Ajax 테스트 패턴
## 13.2.1 기능 테스트
## 13.2.2 클라이언트단 스크립트 단위 테스트하기
## 13.2.3 서비스 테스트하기
## 13.3 기능 테스트
## 13.3.1 Selenium을 이용해 기능 테스트하기
## 13.3.2 HtmlUnit을 이용해 기능 테스트하기
## 13.4 자바스크립트 테스트하기
## 13.4.1 RhinoUnit으로 자바스크립트 테스트하기
## 13.4.2 JsUnit으로 자바스크립트 테스트하기
## 13.4.3 JsUnit 테스트 작성하기
## 13.4.4 JsUnit 테스트 스위트 작성하기
## 13.4.5 수동으로 JsUnit 테스트 수행하기
## 13.4.6 Ant로 JsUnit 테스트 실행하기
## 13.5 RhinoUnit vs. JsUnit
## 13.6 JSLint로 모범 사례 이행 여부 검사하기
## 13.7 HttpClient로 서비스 테스트하기
## 13.7.1 XML 서비스 호출하기
## 13.7.2 XML 응답 검증하기
## 13.7.3 JSON 응답 검증하기
## 13.8 Google Web Toolkit 애플리케이션 테스트하기
## 13.8.1 GWT 애플리케이션용 테스트 프레임워크 선택하기
## 13.8.2 수작업으로 GWTTestCase 작성하기
## 13.8.3 junitCreator로 GWTTestCase 생성하기
## 13.8.4 테스트 케이스 실행하기
## 13.8.5 setUp과 tearDown
## 13.8.6 테스트 스위트 만들기
## 13.8.7 테스트 스위트 실행하기
## 13.9 정리

## 14장 Cactus를 이용한 서버단 자바 테스트하기
## 14.1 Cactus란 무엇인가?
## 14.2 Cactus를 이용해 테스트하기
## 14.2.1 Cactus로 테스트할 수 있는 자바 컴포넌트
## 14.2.2 일반 원칙
## 14.2.3 Cactus 동작 메커니즘
## 14.3 서블릿과 필터 테스트하기
## 14.3.1 관리 애플리케이션 소개하기
## 14.3.2 Cactus를 이용한 서블릿 테스트 작성하기
## 14.4 JSP 테스트하기
## 14.4.1 관리 애플리케이션 재조명해보기
## 14.4.2 JSP 단위 테스트란?
## 14.4.3 Cactus를 이용해 격리된 환경에서 JSP 단위 테스트하기
## 14.4.4 SQL 결과 데이터로 JSP 실행하기
## 14.5 EJB 테스트하기
## 14.6 Cargo란 무엇인가?
## 14.7 Ant로 Cactus 테스트 실행하기
## 14.7.1 아카이브 준비를 위한 Cactus 태스크
## 14.8 Maven2x를 이용해 Cactus 테스트 실행하기
## 14.8.1 Maven2의 cactifywar MOJO
## 14.8.2 Maven2의 cactifyear MOJO
## 14.9 브라우저로부터 Cactus 테스트 실행하기
## 14.10 정리

## 15장 JSP 애플리케이션 테스트하기
## 15.1 JSF 소개하기
## 15.2 애플리케이션 예제 소개하기
## 15.3 JSF 애플리케이션 테스트 시의 전형적인 난관들
## 15.4 JSF 애플리케이션 테스트 전략
## 15.4.1 블랙박스 방식
## 15.4.2 구원 투수 목 객체 투입
## 15.5 JSFUnit으로 예제 애플리케이션 테스트하기
## 15.5.1 브라우저로 JSFUnit 테스트 실행하기
## 15.5.2 JSFUnit을 이용해 Ajax 테스트하기
## 15.6 JSFUnit과 HtmlUnit 함께 사용하기
## 15.7 JSF 애플리케이션 성능 테스트하기
## 15.8 정리

## 16장 OSGi 컴포넌트 테스트하기
## 16.1 OSGi 소개하기
## 16.2 첫 번째 OSGi 서비스
## 16.2.1 예제 애플리케이션
## 16.3 OSGi 서비스 테스트하기
## 16.3.1 목 객체
## 16.4 JUnit4OSGi 소개하기
## 16.5 정리

## 17장 데이터베이스 액세스 테스트하기

>영속 계층(데이터베이스 엑세스 코드) 은 의심의 여지 없이 기업 용 제품에서 가장 중요한 부분이다. <br/> 그 중요성에도 불구하고, 영속 계층은 테스트하기 쉽지 않은데, 주로 다음의 문제들 떄문이다.<br/>
>-단위 테스트는 코드를 격리된 환경에서 실행해야한다. 영속 계층은 외부 개체(데이터베이스)와 상호작용해야 한다. <br/> -단위 테스트는 쉽게 작성하고 쉽게 돌릴 수 있어야 한다. 데이터베이스 엑세스 코드는 복잡하고 다루기 어렵다. <br/> - 단위 테스트는 빨라야 하는데, 데이터베이스 엑세스는 상대적으로 느리다. -p 434

> 객체 관계 임피던스 미스매치(object-relational impedance mismatch, 객체지향 언어로 작성된 애플리케이션의 데이터를 관계형 데이터베이스에 저장하기 어려움을 설명하는 용어)에서 착안하여, 이 문제를 데이터베이스 단위 테스트 임피던스 미스 매치라 부른다. -p 434


## 17.1 데이터베이스 단위 테스트 임피던스 미스매치
.
## 17.1.1 단위 테스트는 격리된 환경에서 수행해야 한다
> 순수주의자의 관점에서 보면 데이터베이스 엑세스 코드의 테스트는 단위 테스트라 할 수 없다. 외부 개체인 데이터베이스에 의존하게 되기 때문이다. 그렇다면 어떻게 불러야할까? <br/> 정답은 '절대적 규칙은 없다' 이다. 다시 말해 데이터베이스 테스트는 그 문맥에 따라 다양한 범주에 속할 수 있다. <br/> 실용적으로 얘기하면, 데이터베이스 엑세스 코드는 단위 테스트와 통합 테스트 양쪽 모두에서 테스트 할 수 있다. -p434
> -단위테스트는 데이터베이스와 직접 상호작용하는 클래스(DAO) 를 테스트할 때 쓰인다. 이런 테스트에서는 대상 클래스가 적절한 SQL 문을 사용하는지, 올바른 객체를 얻어내는지 같은 기능을 검증한다. 비록 외부 개체에 의존하고는 있지만, 더 큰 애플리케이션 모듈에서 사용할 클래스들을 테스트한다고 보면 된다.<br/>
> -비슷하게 데이터베이스를 사용하지 못하도록 하면서, 상위 계층 (예: facade) 을 단위 테스트할 수도 있다. 이 경우엔 mock 이나 stub 으로 애뮬레이션 가능하다. <br/>
> -양쪽 계층(영속 계층과 상위 계층) 모두 단튀 테스트를 수행했어도, 통합테스트는 여전히 필요하다. e2e(end to end) 시나리오세만 발생하는 상황도 존재할 수 있기 때문이다. <br/> -p434

> 현실적인 질문을 하나 해보자. 테스트 도중에 데이터베이스 안에 필요한 데이터를 집어넣을 수 있을까? 물론이다. 그러기 위해선, 테스트 실행 전에 데이터베이스가 알려진 상태에 놓여 있는지 확인해야 한다. -p435
## 17.1.2 단위 테스트는 쉽게 작성하고 쉽게 실행할 수 있어야 한다

> 기술 리더, 프로젝트 관리자, 혹은 전사적으로 제 아무리 단위 테스트를 찬양한다해도, 작성하고 실행시키기 어렵다면 의미가 없다. 개발자들은 테스트를 작성하지 않으려 저항할 것이다. 더구나 데이터베이스 엑세스 코드를 작성하는 것 자체도 그리 매력적인 일이 못 된다. -p435
## 17.1.3 단위 테스트는 빠르게 수행되어야 한다

> 단위 테스트가 데이터베이스 액세스 객체들을 테스트 한다. 그런데 빌드를 한 번 시작하면 10분이 걸리고, 그 중 9분은 데이터베이스 테스트가 잡아먹는다고 한다면? 어려운 문제라 할 수 있다. <br/>일반적으로는 데이터베이스 액세스 자체에 지연이 발생한다. 데이터베이스는 원격지 서버에 있을 것이고, 수 많은 사람들이 함께 사용하기 때문이다. <br/> 가능한 해결책으로는 로컬에 임베디드 DB를 사용하는 것이다. -p436 

## 17.2 DbUnit 소개하기

> DBUnit(https://www.dbunit.org/) 은 마누엘 라플래임이 2002년에 만든 JUnit의 확장 툴이다. 당시는 JUnit 가 아직 성숙하지 못했고, 데이터베이스 테스트를 위한 프레임워크도 전무하던 시절이었다. 거의 같은 시기에 리차드 달라웨이는 '데이터베이스 코드 단위 테스트하기' 라는 제목의 글을 기고하여 DBUnit 제작에 영감을 주었다. -p437

DBUnit 은 처음 알게되었는데, 나 같은 경우 평소에 그냥 test 를 진행할때에는 h2 로컬 임베디드 db를 구성하고, jpaRepository 를 동작시켜서 insert 하고 처리할수 있게 하였었다. 그런데 가만 생각해보니 테스트 대상인 영속성 계층을 사용해서 test 를 위한 db 초기화를 하는 과정이 넌센스같단 생각이 문득 들었다.
 
 아래 괜찮은 레퍼런스가 있었다.
 
- https://www.baeldung.com/java-dbunit
- https://techblog.woowahan.com/2650/

## 17.2.1 예제 애플리케이션
## 17.2.2 DbUnit 설정 및 예제 애플리케이션 실행하기
## 17.3 데이터셋을 이용해 데이터베이스 채우기
## 17.3.1 DatabaseOperation 해부
## 17.4 데이터셋으로 데이터베이스 상태 확인하기
## 17.4.1 데이터셋 필터링하기
## 17.4.2 열 무시하기
## 17.5 ReplacementDataSet를 이용해 데이터 변환하기
## 17.5.1 ReplacementDataSet을 이용해 다른 ID 문제를 처리하기
## 17.5.2 NULL 값 처리하기
## 17.6 데이터베이스 안의 데이터로부터 데이터셋 생성하기
## 17.7 고급 기법
## 17.7.1 DbUnit과 템플릿 디자인 패턴
## 17.7.2 커스텀 애노테이션으로 재활용성 높이기
## 17.7.3 데이터셋에 표현 언어 사용하기
## 17.8 데이터베이스 액세스 테스트 모범 사례
## 17.8.1 개발자마다 하나의 데이터베이스를 사용하라
## 17.8.2 대상 데이터베이스가 테스트되는지 확인하라
## 17.8.3 데이터를 읽고 저장하는 보조적인 테스트를 만들라
## 17.8.4 읽기 테스트 케이스에서 모든 기본 시나리오를 검증하라
## 17.8.5 데이터셋 용도를 계획하라
## 17.8.6 테스트 정리
## 17.9 정리

## 18장 JPA 기반 애플리케이션 테스트하기
## 18.1 계층형 애플리케이션 테스트하기
## 18.1.1 예제 애플리케이션
## 18.1.2 다양한 계층, 다양한 테스트 전략
## 18.2 JPA 테스트의 특징
## 18.3 인프라 갖추기
## 18.4 JPA 엔티티 매핑 테스트하기
## 18.4.1 테스트 케이스에 JPA ID 생성기 통합하기
## 18.5 JPA 기반 DAO 테스트하기
## 18.6 외래키 이름 테스트하기
## 18.7 정리

## 19장 JUnit에 부스터를...
## 19.1 툴 소개
## 19.1.1 툴 살펴보기
## 19.1.2 예제 실행하기
## 19.2 투명 목 활용
## 19.2.1 Unitils의 EasyMock 지원
## 19.2.2 FEST-Mocks
## 19.2.3 Mycila
## 19.3 DbUnit 통합
## 19.4 assert는 일을 쉽게 만든다
## 19.4.1 JUnit-addons의 단언 패키지
## 19.4.2 Unitils의 ReflectionAssert
## 19.4.3 FEST Fluent Assertions Module
## 19.4.4 Mycila 확장 assert 문
## 19.5 리플렉션을 이용해 캡슐화 회피하기
## 19.5.1 직접 만들어보기
## 19.5.2 JUnit-addons
## 19.5.3 FEST-Reflect
## 19.6 정리

## 부록A JUnit 3와 4의 차이점
## A.1 전반적인 변화
## A.1.1 JDK 요구사항
## A.1.1 하위/상위 호환성
## A.2 API의 변화
## A.2.1 패키지 구조
## A.2.2 생성자
## A.2.3 테스트 케이스 확장하기
## A.2.4 테스트 메서드 이름
## A.3 애노테이션과 정적 임포트의 도입
## A.3.1 @Before와 @After 애노테이션
## A.3.2 @BeforeClass와 @AfterClass 애노테이션
## A.3.3 일부 테스트를 제외하고 실행시키기
## A.3.4 정적 임포트
## A.3.5 예외 테스트하기
## A.3.6 타임아웃 테스트하기
## A.4 추가된 JUnit 러너
## A.4.1 테스트 러너
## A.4.2 테스트 스위트
## A.4.3 파라미터화 테스트
## A.5 새로운 assert 문과 가정
## A.5.1 Hamcrest assert 문
## A.5.2 가정
## A.5.3 새로 추가된 assert 문
## A.5.4 assert 에러

## 부록B 커스텀 러너와 매처로 JUnit API 확장하기
## B.1 인터셉터 패턴 소개하기
## B.2 커스텀 러너 제작하기
## B.3 커스텀 매처 구현하기

## 부록C 책의 소스 코드
## C.1 소스 코드 얻기
## C.2 소스 코드 개요
## C.3 외부 라이브러리
## C.4 JAR 버전
## C.5 디렉터리 구조 규약

## 부록D JUnit IDE 통합
## D.1 이클립스에 통합된 JUnit
## D.1.1 이클립스 설치하기
## D.1.2 소스로부터 이클립스 프로젝트 설정하기
## D.1.3 이클립스에서 JUnit 테스트 실행하기
## D.1.4 이클립스에서 Ant 스크립트 실행하기
## D.2 JUnitMAX 이클립스 플러그인 소개
## D.2.1 개발 주기에 통합됨
## D.2.2 실행 순서
## D.2.3 마지막 안정 버전으로 되돌리기
## D.3 NetBeans에 통합된 JUnit
## D.3.1 NetBeans 설치하기
## D.3.2 소스로부터 NetBeans 프로젝트 설정하기
## D.3.3 NetBeans에서 JUnit 테스트 실행하기
## D.3.4 NetBeans에서 Ant 스크립트 실행하기

## 부록E 소프트웨어 설치하기
## E.1 HtmlUnit 설치하기
## E.1.1 표준 설정
## E.1.2 이클립스 설정
## E.2 HtmlUnit을 사용할 수 있도록 Cactus 설정하기
## E.3 Selenium 설치하기
## E.4 RhinoUnit 설치하기
## E.5 JsUnit 설치하기