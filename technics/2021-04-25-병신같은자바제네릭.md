

아래처럼 서로 상속관계를 가지는 객체가 있다고 가정하자

```java
@Data
public class ExchangeLog {
    private Long seq;
    private String from;
    private String to;
    private Long changeAmount;
    private Long feeMinusChangeAmount;
    private Long beforeChangeAmount;
    private Long currentAmount;
    private Boolean workStatus;
    private Date regDate;
    private ExchangeRoute route;
    private String remoteIp;

}
```

```java
@Data
@Entity
public class ExchangeLogMoney extends ExchangeLog {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Override
    public Long getSeq() {
        return super.getSeq();
    }

    
    @Override
    public String getFrom() {
        return super.getFrom();
    }

    
    @Override
    public String getTo() {
        return super.getTo();
    }
    
    @Override
    public Boolean getWorkStatus() {
        return super.getWorkStatus();
    }
    
    @Override
    public Date getRegDate() {
        return super.getRegDate();
    }
    @Convert(converter = ExchangeRoute.converter.class)
    
    @Override
    public ExchangeRoute getRoute() {
        return super.getRoute();
    }
    
    @Override
    public String getRemoteIp() {
        return super.getRemoteIp();
    }


    
    @Override
    public Long getChangeAmount() {
        return super.getChangeAmount();
    }

    
    @Override
    public Long getFeeMinusChangeAmount() {
        return super.getFeeMinusChangeAmount();
    }

    
    @Override
    public Long getBeforeChangeAmount() {
        return super.getBeforeChangeAmount();
    }

    
    @Override
    public Long getCurrentAmount() {
        return super.getCurrentAmount();
    }
}
```
   

자바에서는 List<ExchangeLogMoney> money 와 List<ExchangeLog> log 서로를 상속 관계인지를 파악하지 못한다. List 객체 타입이 무엇이 담겨있느냐? 가 아니라 List<Log> 와 List<LogMoney> 가 서로 상속관계에 놓여 있냐고? 물어보기 때문이다. 이걸 보고 다른 언어에서 자바의 제네릭을 보고 븅신같다고 겁나 깐다. c++ 에서는 템플릿 메타프로그래밍이란 게 있다.

<img src="https://scontent-icn1-1.xx.fbcdn.net/v/t1.0-9/18403471_1175483265896912_2465738413534198752_n.jpg?_nc_cat=103&_nc_ht=scontent-icn1-1.xx&oh=e90471b4005f2e40684c5f47a2de1799&oe=5D2BCB31">

이런 걸 이펙티브 자바에서는 무공변(invariant) 에 대한 이야기를 덧붙여서 설명해준다. List<Log> 는 List<LogMoney>의 슈퍼타입도 뭐도 아니다. 서로 남남이다. 다만 Collection<Log> 와 List<Log>는 서로 슈퍼타입 서브타입의 관계가 될 수 있다. 이런 걸 매개변수화 타입의 무공변(invariant) 라고 한다. 

이런걸 보안하기 위해 나오는 것이 와일드카드이다. ?과 같은 와일드카입 타입을 사용해서 ```List<? extends ExchangeLog>``` 명시적으로 선언한다. 이것이 의미하는 것은 ExchangLog의 서브타입이 List의 매개변수화가 되어야 한다는 것을 의미한다. ? 와일드카드는 무엇이 올지 모른다라는 의미를 가진다. 

```List<? extends Object> list``` 이건 사실 ```List<?>``` 또는 ```List<Object>``` 와 다를 게 없다. 


```java
    public List<Data> zipge(Integer limit, List<? extends ExchangeLog> list) {
        ...
    }
```


```java
    new ExchangeLogMoneyRepo() {
            @Override
            public List<ExchangeLogMoney> findAll() {

                List<ExchangeLogMoney> list = new ArrayList<>((Collection<? extends ExchangeLogMoney>) fixture);

                return list;
            }
            ...
    }
```

```java
        new ExchangeLogMoneyRepo() {
                @Override
            public List<ExchangeLogMoney> findAll() {
                return fixture.stream()
                        .map(x -> (ExchangeLogMoney) x)
                        .collect(Collectors.toList());
            }

        ..
        }

```

자바 제네릭에는(1.7버전의 개선된 제네릭에도 그런지는 확인못함) 컴파일 시점에만 타입 체크를 하는 단점이 있다.

아래를 보자

```java



```


## 레퍼런스

- https://medium.com/@joongwon/java-java%EC%9D%98-generics-604b562530b3