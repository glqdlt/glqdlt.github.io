---
layout: post
title:  "자바스크립트를 객체지향스럽게"
author: "glqdlt"
---

# 들어가며

이 아티클은 [객체지향 자바스크립트 3/e](http://www.yes24.com/24/goods/51335821) 를 읽으면서 작성한 요약본입니다.

## 자바스크립트의 구성

자바스크립트에는 세 가지의 핵심적인 용어가 구성되어 있다.

- ECMAScript : 언어의 핵심적인 기능으로 변수, 함수, 루프 등을 포함(ECMA-262 스펙). 브라우저와는 무관히 독립적이고 다른 여러 환경에서 사용 될 수 있음

- DOM(Document Object Model) : HTML 및 XML 문서와 동작할수 있는 방법을 제공. 문서를 조작하는 언어 독립적인 W3C의 DOM 표준이 만들어짐.

- 브라우저 객체 모델 : 브라우저 환경과 관련된 객체의 집합. HTML5에서 표준화됨.

## 브라우저 전쟁

넷스케이프(현 모질라)와 마소간의 제1차 브라우저 전쟁에 대한 이야기

## 현재

자바스크립트에서 흥미로운 것은 항상 호스트 환경에서 실행되는 점

오늘 날 자바스크립트는 서버, 데스크톱, 모바일 기기에서도 실행이 가능

## ES5 와 ES6

### ES5

2009 년 12월에 공식적으로 승인.

대부분의 브라우저 및 서버에서 구현. 흥미로운 기능은 ```strict mode``` 의 도입.
엄격 모드는 언어의 하위집합으로 사용되지 않는 기능이 동작하지 않게해줌.

> "use strict";

태그나 함수의 머릿말에 위 선언을 통해 사용이 가능

### ES6 

2009년에서 6년 만인.. 2015년 6월에 승인. 그래서 ECMA Script 2015 라고도 부름.

```promise```, ```제네레이터``` 등

ES6의 스펙을 모든 플랫폼에서 완벽히 구현하지는 못했다. 이런 이유로 ES6 원본 코드를 브라우저에서 실행시키거나 서버에서 실행시키면 몇몇 코드의 구문을 해석하지 못해서 에러를 내고 app은 멈춘다. 

이를 위해서 트랜스파일러가 등장했다. 트랜스파일러는 ES6 syntax 코드를 모든 브라우저에서 동작하는 ES5 코드로 변환하는 개념인데, 컴파일과 유사하다해서 트랜스파일이라고 부르고, 이를 처리해주는 녀석을 트랜스파일러라고 부른다.(또는 컴파일러)

현재 대표적인 트랜스파일러로는 바벨(Babel)이 있음.

### 바벨

바벨은 빌드 시스템, 프레임워크 및 언어에서부터 탬플릿 엔진까지 광범위하게 사용되고 있음.

## 객체지향 프로그래밍

객체지향의 기본적인 개념들

- 객체와 메소드, 속성

- 클래스

- 캡슐화

- 집합

- 재사용성 / 상속

- 다형성

### 객체

OOP에서 객체는 어떠한 대상을 일컫는 개념이다. 프로그래밍에서 '인스턴스(instance)' 라고 부르기도 한다. 예를 들어 네로라 불리는 검은 고양이가 있다면 네로는 고양이 객체이고, name 이 '네로', color 가 '검정' 의 속성을 가지고 있다. 또한 고양이의 특징인 '울기(야오옹~)', '뛰어내리기' , '핥퀴기' 와 같은 동작을 수행할 수 있다. 이러한 동작을 객체의 메소드라고 부른다.

> 개인적인 팁이지만, 주변 사람들을 보면 메소드와 함수를 혼동해하는 사람이 많은 걸 보아왔다. 메소드와 함수는 생긴 모양새는 같은 의미를 가진다. 하지만 두 개념이 비슷해보여도 궁극적인 차이는 메소드는 객체에 포함되어야만 존재하는 기능의 역활이고, 함수는 객체 없이도 동작할 수 있는 기능이다.

### 클래스

OOP에서 클래스는 객체의 청사진(blueprint) 또는 레시피(recipe)임. 또 어떻게 보면 공장의 틀 같은 존재나 탬플릿과 같은 것으로 봐도 무관하다. 위의 네로 고양이를 예로 들면 '네로라는 객체는 고양이 클래스' 라 말할 수 있다.

### 캡슐화

캡슐화(encapulatoion)는 객체가 데이터의 성질(객체의 속성에 값이 저장됨)을 가짐으로써 생겨난 개념이다. 캡슐화의 궁극적인 의미는 정보 숨기기(information hiding)에 의미를 가진다. 또한 접근 제한의 의미도 가진다(public, private)

### 집합

여러 객체를 하나의 객체로 결합하는 걸 집합이라고 부른다, 또는 컴포지션(composition).
고양이의 몸을 이루는 것을 세분화해서 살펴 보면, 눈 객체, 꼬리 객체, 다리 객체로 작은 단위의 요소들로 이루어진 것을 알 수 있다. 이처럼 여러 객체들이 모여서 하나의 객체로 구성되는 것을 집합이라고 보면 된다.

### 상속

상속은 상속이다. -_-;

### 다형성

다형성도 다향성이지 -_-;

## 문법

### 변수

변수 선언은 기본적인 것임으로 패스.


#### $변수

변수 이름에 있는 $ 문자는, 일반적으로 함수 이름을 표현할 때 가끔 쓰는 네이밍 표기법이라고 한다. 

```javascript
const $myFunction = function(){...}
```

#### 세미콜론

표현식의 마지막은 항상 세미콜론으로 끝낸다. 자바스크립트에는 세미콜론 자동 삽입 매커니즘이 있다. 하지만, 미표기 시에 착각이 일어나 개발 코드에 버그를 만들게 할 수도 있음으로 대부분 표기하기를 권장한다.

#### typeof 연산자

변수 나 값의 유형을 알고 싶을 때, typeof 연사를 사용할 수 있다.

typeof 로 알 수 있는 유형은 아래와 같다.

- 숫자 (number)

- 문자열 (string)

- 부울(boolean)

- 정의되지 않음 (undefined)

- 객체 (object)

```javascript
const some ='123';
typeof some 
// >> "string"
```

```javascript
const n5 = 0xff;
n5
// >> 255
typeof n5
// >> "number"
```

#### 지수 리터럴
1e1 은 숫자 1 뒤에 0이 하나 있는 걸 나타낸다. 2e+3 은 숫자 2 뒤에 3개의 0이 있음을 나타낸다.3e-3은 0.003 이다.

```javascript
1e1
// >> 10
2e+3
// >> 2000
3e-3
// >> 0.003
```

#### 무한대

```javascript
const a = 6 / 0;
a;
// >> Infinity
```

#### NaN

NaN 은 알 수 없는 숫자타입을 의미한다.

```javascript
const a = 10 * "f;
a;
// >> NaN
```

#### 문자열 반환 변태성

```javascript
let s = '1';
s++;
// >> 2
```

#### 탬플릿 리터럴

ES6 에 생긴 문법으로, 작은 따옴표 대신 백틱(back-tick) ``` console.log(`Hello : ${name}`) ``` 을 써서 사용한다. 또한 값을 주입해주는 자리표시자 (place holder) syntax는 중괄호와 달러기호를 사용해서 ```${expression}``` 로 작성한다.

```javascript
const name = 'jhun';
console.log(`Hello ${name}`);
// >> Hello jhun

const $someFunc = (a,b) => {return a+b};
console.log(`${$someFunc(1,2)}`);
// >> 3
```

#### 지연 평가

첫 번째 피연산자가 평가됬을 때 true라 판단이 된 후에, 뒤에 어떤 값이 나오더라도 의미가 없을 경우에는 지연 평가(lazy evaluation) 으로 처리 되에 후술 된 평가 로직이 동작하지(short-circuiting) 않는다.

```javascript

let val = 5;
true || (val = 10);
// >> true
val;
// >> 5;
true && (val = 11);
// >> 11;
val;
// >> 11;

```

위 특징을 응용해서 아래와 같은 것도 가능하다.

```javascript
var myNum1 = 5;
myNum1 = myNum1 || 10;
myNum1;
// >> 5;

var myNum2 = myNum2 || 10;
myNum2;
// >> 10;
```

그렇지만 ES6 에서는 이 꼼수가 막혔다.
```javascript
let myNum1 = 5;
myNum1 = myNum1 || 10;
myNum1;
// >> 5;

let myNum2 = myNum2 || 10;
myNum2;
// >> error;
```

#### undefined 와 null

```javascript
let i = 1 + undefined;
i;
// >> NaN

let ii= 1 + null;
ii;
// >> 1;

```

#### Symbol

ES6 에는 새로운 원시 타입인 Symbol 이 생겼다.

```javascript
let atom = Symbol();
atom;
// >> Symbol();
```

#### 배열

배열은 어느 언어독립적으로 비슷하다. 단, 문자열 배열 접근은 ES6 에 와서야 동작하게 되었다.
```javascript
const s= 'one';
s[0];
// >> o
s[1];
// >> n
```

- 배열은 인덱싱 된 요소가 포함되어 있다.
- 배열은 0부터 시작한다.
- 배열에 접근하려면 인덱스 count 를 호출해야한다.
- 배열은 다른 배열을 포함한 모든 유형의 데이터를 포함 시킬수 있다.

#### 루프

자바스크립트에서는 네 가지 유형의 루프가 있다.

- while 

```javascript
let i = 0;
while(i<10){
    i++;
}
```

- do-while
```javascript
let i =0;
do{
    i++;
}while(i<10);
```

- for
```javascript
let msg = '';
for (let i =0; i< 100; i++){
    msg += i;
}
```


- for-in

    for ...in 루프는 배열 또는 객체의 요소를 반복하는 데 사용된다. for 나 while 을 대체하는 수단이 아니다.

    ```javascript
    const arr = ['a','b','c'];
    for (let i in arr){
        console.log(`index = ${i}, vale = ${arr[i]}`);
    }

    const obj = {name : 'jhun', old : 14, iq : 999};

    for(let k in obj){
        console.log(`property key : ${k}, value : ${obj[k]} `);
    }

    ```

### 함수

자바스크립트의 꽃인 함수이다.

자바스크립트의 함수를 터득한다는 것은 아래 자바스크립트의 테크닉을 사용하게 되는 걸 의미한다.

- 익명 함수의 사용
- 콜백
- 즉시 실행 함수
- 내부 함수
- 함수를 반환하는 함수
- 스스로를 재정의하는 함수
- 클로저

#### 함수의 매개변수

```javascript
function sum(a,b){return a + b};

sum(1,2);
// >> 3;

<!-- 불 필요하게 많이 들어간 매개변수는 무시된다. -->
sum(1,2,3,4,5);
// >> 3;

```

자바스크립트 함수에는 자동으로 생성되는 특별한 값이 arguments 라는 내장 키워드가 있다. 

```javascript

function args(){
    return arguments;
}
args();
// >> [];
args(1,2,3,'hello');
// >> Arguments(4) [1,2,3,'hello'] ....


```
위 특징을 응용해서 아래와 같은 함수도 만들 수 있다.

```javascript

function sumOfAll(){
    let result = 0;
    for(let i in arguments){
        if(typeof arguments[i] === 'number')
        {
        result += arguments[i];
        }
    }
    return result;
}

sumOfAll(1,2,3)
// >> 6

sumOfAll(1,2,3,'HAHA')
// >> 6

```

#### default 매개변수

함수 매개변수에 디폴트 값을 지정할 수 있다. 또한 default 매개변수는 다른 매개변수를 참조할 수도 있다.

```javascript

function echo(name = 'jhun',name2 = name){
     console.log(`Yahoo~ ${name} ~ ${name2}`);
}

echo();
// Yahoo~ jhun ~ jhun
echo('haha');
// Yahoo~ haha ~ haha;

```

좋아보이지만 주의할 점이 아래와 같다. 내부 변수에서 재정의를 하여 매개변수를 덮으려고 해도, default 매개 변수가 외부의 변수에 의해 가려지게 되면(shadowed) 의도 되로 동작하지 않는다.

```javascript
var val = 'out';

function print(arg = val){
    var val = 'in';
    console.log(arg);
}
print();
// >> out
print(123);
// >> 123;

<!-- ES6.. -->

let val = 'out';

function print(arg = val){
	let val = 'in';
	console.log(arg);
}
print();
// >> out
print(123);
// >> 123

```
#### 나머지 연산자

```javascript
function echo(...arg){
	for(let i in arg){
		console.log(arg[i]);
    }
}


echo("haha","hoho")
// >> haha
// >> hoho
```

재밌는 것은 나머지 매개변수로 받는 녀석은 배열로 들어온다는 점이 재밌다. 또한 나머지 매개변수는 꼭 마지막 매개변수로 선언이 되어야만 한다.

```javascript
function echo(a1, ...arg){
	console.log(a1);
	console.log(arg);
}
echo('h1','h2','h3','h4');
// >> h1
// >> (3) ["h2", "h3", "h4"]
```

#### 스프레드 연산자

나머지 연산자와 생긴 것은 같지만 기능이 다르다. 스프레드 연산자는 배열이나 객체의 값으로 넣어질 때 배열 안의 item 들을 하나하나 split 해서 뽑아주는 녀석이다. 코드를 직접 보자

```javascript

const arg1 = ['wed','thu'];
const arg2 = ['sat','sun'];
const week = ['mon','tue', ...arg1,'fri',...arg2];
week;
// >> (7) ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]
```

#### 사전 정의 된 함수

자바스크립트 엔진에는 사전 정의되어 있는 내장 함수가 몇 가지 있다.

- parseInt()
- parseFloat()
- isNaN()
- isFinite()
- encodeURI()
- encodeURIComponent()

    ```javascript
    const url = 'http://www.github.com?param1=value and value';
    encodeURI(url);
    // >> "http://www.github.com?param1=value%20and%20value"
    encodeURIComponent(url)
    // >> "http%3A%2F%2Fwww.github.com%3Fparam1%3Dvalue%20and%20value"
    ```
- decodeURI()
- decodeURIComponent()
- eval()

    eval 은 자바스크립트 syntax 를 가진 문자열을 실행시켜준다.

    ```javascript
    const code = 'var ii = 2;';
    ii;
    // >> ii is not defined
    
    eval(code);

    // >> 2;

    eval('var i2 = 3;');
    i2;
    // >> 3;

    const cc = console.log;
    eval(cc('what the '));
    // >> what the
    ```

    eval()은 악마다 라는 말이 있듯이, 문제를 야기하는 단점이 몇 있다.

    - 보안 : eval()에 전달되는 입력 소스를 신뢰할 수가 없다.
    - 성능 : 코드를 eval()로 실시간 평가(실행)하는 것은 소스 코드 보다 성능적인 퍼포먼스가 매우 느리다.

#### 변수 호이스팅

```javascript
var a = 123;
function f(){
    console.log(a);
    // >> undefined
    var a= 1;
    console.log(a);
    // >> 1;
}
f();
```
이 함수를 실행할 경우 기대하는 바는, 첫번째 alert 에서 123이 두번째 alert에서는 1 이 나올 것이라 기대 한다. 하지만 정작 결과는 undefined 이다. 이것은 호이스팅이라는 자바스크립트의 특징 중 하나를 보여주는 사례이다. 

호이스팅은 자바스크립트의 함수는 함수가 실행될 때 함수 내부의 모든 지역변수들을 최상단 으로 끌어올려 선언하는 특징을 가지고 있다. 위 f() 함수를 호이스팅 관점으로 보면 아래와 같다.


```javascript
var a = 123;
function f(){
    var a;
    console.log(a);
    // >> undefined
    a= 1;
    console.log(a);
    // >> 1;
}
f();
```

```var a=1``` 으로 아래에서 선언 되던 a 라는 지역 변수가 가장 최상단으로 끌어올려졌다. 끌어 올려지면서 a가 명시 되면서, 값이 선언되지 않은 undefined 가 출력 된다.

#### 블록 스코프

위의 호이스팅 문제 때문에 ES6 에서는 블록 범위(scope) 라는 기능을 추가 했다. 블록 스코프를 사용하기 위해서는 var 키워드 대신 let , const 키워드로 변수를 선언해야 한다. let, const 로 선언 하게 되면 블록 단위로 호이스팅 된다.

```javascript
let a = 123;
function f(){
    console.log(a);
    // >> a is not defiend
    let a= 1;
    console.log(a);
    // >> 1;
}
f();
```

블록 스코프는 자바나 C++ 과 같이 ```{``` ```}``` 블록 구문의 동작과 똑같이 동작하게 된다. 자바스크립트 만의 특징인 호이스팅도 일어나지 않는다. 또한 let 키워드로 선언 된 변수 명이 이미 있을 경우 재 선언할 수 없다. 

### 함수는 데이터다.

자바스크립트에서의 함수는 데이터이다. 책에서는 이 개념을 아주 중요하게 설명하고 있다.

#### 함수 리터럴

함수를 정의하는 방식 중에 함수 리터럴 표기법(function literal notation) 이라는 것이 있다.

```javascript
var f = function () {
    return 1;
    }
```

위의 코드에서 ``` function () {...} ``` 에 해당하는 것은 함수 표현식(function expression)이다. 함수 표현식은 선택사항으로 이름을 줄 수 있다, 예를 들면 ```function hello() {...}``` 이런 식으로 말이다. 이 경우에는 NPE(named function expression)이라 해서 이름을 가지는 함수 표현식이 된다. 

함수 표현식과 리터럴 표기법의 차이점은 호출법에서 차이가 있다. 함수 표현식은 변수 호이스팅처럼 전역으로 자동으로 끌어올려져 어디서든 호출할 수 있지만, 리터럴 표기법은 선언 되기 이전에는 호출할 수 없다.

```javascript

some();
// >> hi
f();
// f is not difined;

function some(){
    console.log('hi');
}

var f = function(){
    console.log('hi');
}

```

#### 익명 함수

함수 표현식에서 선택사항인 이름을 주지 않고 선언한 함수를 익명 함수(anoymous) 라고 부른다.

익명 함수는 아래의 특징을 가진다.

- 익명 함수를 매개변수로 다른 함수에 전달할 수 있다.
- 익명 함수를 정의하고 바로 실행할 수 있다.

```javascript

function somePlus(a,b){
    return a + b;
}

function sum1(){
    return 1+2;
}

function sum2(){
    return 3;
}

somePlus(sum1(),sum2());
// >> 6

<!-- 익명즉시함수로 그 자리에서 바로 함수를 작성해서 실행 -->
somePlus((function() {return 7)()}, sum2();
// >> 10;

<!-- 애로우함수(람다)로도 작성이 가능  -->
somePlus((() => {return 8})(), sum2();
// >> 11;

```
위를 응용해서 콜백함수로 사용하면 아래와 같다.

```javascript


function multiplyWithSum(a,b,callback){

    return callback(a) + callback(b);

}

multiplyWithSum(2,3,(x) => {return x*2} )
// >> 10
```

#### 즉시 실행 함수

즉시 실행 함수는 함수가 정의 된 자리에서 바로 실행되어 result 값을 가지고 있게 되는 경우이다.

#### 내부 비공개 함수

비공개 함수는 특정 함수 내부에서만 사용되는 함수를 말한다. 비공개 함수를 사용하면 얻는 이점은 아래와 같다.

- 전역 네임스페이스를 깨끗하게 유지할 수 있어 충돌 발생이 없어진다.

- 캡슐화 : 필요한 함수만 외부에 노출시키고, 나머지 함수는 의도에 따라 감출 수 있어 진다.

```javascript

function outer(param){
    function inner(innerParam){
        return innerParam * 2;
    }
    return inner(param);
}
outer(7);
// >> 14;

// 함수 리터럴로 작성하면 아래와 같다

const outer = function(param) {
    const inner = function (innerParam){
        return innerParam * 2;
    }
    return inner(param);
}
outer(7);
// >> 14;

// 람다로 작성하면 아래와 같다

const outer = (param) => 
{ 
    const inner = (innerParam) => { return innerParam * 2;};
    return inner(param);
}
outer(7);
// >> 14;

```

#### 사용자 재정의 함수

함수는 함수를 반환할 수 있다.

```javascript
const functionMom = () => {return () => {return 1;}};

functionMom();
// >> () => {return 1;}

const child = functionMom();
child();
// >> 1;

// 만약 함수를 반환하지 않고 값을 바로 리턴받고 싶다면 '즉시실행 함수'로 호출하면 된다. child 는 함수를 호출하는 반면, executeChild 는 변수를 호출하는 것을 유의.

const executeChild = (functionMoM())();
executeChild;
// >> 1;
executeChild();
// >> executeChild is not a function

```

함수는 스스로 내부에서 자신을 재작성할 수도 있다.

```javascript
function a(){
	console.log('a');
	a = function() {	
		console.log('b');
    }
}
a();
// >> a;
a();
// >> b;
```


함수의 반환과 함수의 재작성을 응용하면 이런 식으로 운용이 가능해진다.


```javascript
function a(f){
 
    if(typeof f === 'function'){
        worker = f;
    }

    function worker(){
        console.log('hello');
    }

    return worker;
}

const t1 = a();
t1();
// >> hello;
const t2 = a(() => {console.log('yaho')});
t2();
// >> yaho;

```

### 클로저

클로저는 자바스크립트의 scope 를 응용한 개념이다.

#### 범위 체인

자바스크립트에는 함수 범위가 있다. 함수에 정의 된 변수는 함수 밖에서는 볼 수 없지만, 함수 코드 블록에 정의 된 변수는 블록 외부에서도 볼 수 있다.


```javascript

let a= 1;
function f(){
    let b = 1;
    return a;
}
f();
// >> 1
b;
// >> b is not defined

```
이 특징은 아래와 같다.

- f() 안에서는 블록 밖 외부 변수 a 와 내부 변수 b가 모두 보인다.
- f() 밖에서는 블록 밖 외부 변수 a는 볼수 있지만, f 함수의 내부 변수 b는 볼 수 없다. 

함수 안에서 블록 밖 외부 변수에 접근할 수 있는 것을 scope chain(범위 체인) 이라고 일컫는다.

scope chain 의 극적인 걸 보여주기 위한 변태스런 코드는 아래와 같다.

```javascript

const global_val = 1;
function outer(){
    let outer_var = 2;
    function inner(){
        let inner_var = 3;
        return inner_var + outer_var + global_val;
    }
    return inner();
}
outer();
// >> 6;
```

클로저는 이러한 scope 의 특징을 활용해, scope 문제로 접근하지 못하는 것을 '곁다리 함수' 를 통해 접근하는 것을 말한다. 여기서 곁다리란 이놈 저놈 다리를 걸치고 있다는 의미로 말한다.

#### 클로저 1

```javascript
let a = 'global var';

const f = function(){
    let b = 'local var';
    a = () => {return b;} ;
}
b;
// b is not defined
(f())();
// local var;

```

#### 클로저 2

위의 예제가 직관적이었다면, 이번에는 조금 복잡하다.

```javascript

let cc; // 자리표시자
const $f = function(){
    let b = 'local var';
    let inner = function(){
        return b;
    }
    cc = inner;
};

b;
// b is not defined

$f();
// 여기서 중요한건 $f() 함수를 실행한 후에야 cc 에 inner 가 할당 된다.
cc();
// >> local var

```

#### 정의와 클로저 3

```javascript

const functionFac = ($f) => {
    let _f;
    if(typeof $f === 'function'){
        _f = $f;
    }else{
        _f = () => {console.log('nyaa');}
    }
    return _f;
}

const a1 = functionFac();
a1();
// >> nyaa

const a3 = functionFac((x) => {return x+x;});
a3(12);
// >> 24
```

#### 루프의 클로저

```javascript
function f() {
    let arr = [],i;
    for (i = 0; i < 3; i++) {
        arr[i] = function (){
            return i;
        }
    }
    return arr;
}

const c1 = f();
<!-- 
for 문 안에서 3번을 걸쳐 함수 처리의 결과값을 기대한다. 문제는 함수의 호출은 생성된 환경에 대한 참조만 유지되기 때문에, 3번을 걸쳐 함수가 수행된 뒤에서야 값이 반환됨으로 최종 수행값인 3에 대한 값을 첫번째 호출, 두번째 호출, 세번째 호출에 반환한다. -->
console.log(c1[1]())
// >> 3


function f2() {
    let arr = [],i;
    for (i = 0; i < 3; i++) {
        
<!-- 특정 값을 받아서 단순히 return 해주는 익명함수를 만든다, 그리고 그 익명함수를 즉시실행 함수로 실행을 시키는 데, 여기에 인자값으로 i의 값을 넣어준다. -->
        arr[i] = ((x) => {
            return x;
        })(i);
    }
    return arr;
}

const c2 = f2();
console.log(c2[1]);
// >> 1

```

위의 f2 함수 내부를 보면 람다로 작성한 익명함수가 있다. 함수의 호출에는 참조 값만 기억되기 때문에 3번의 호출이 일어난 후의 값이 저장되어서, 호출이 일어날 때마다의 즉시 값을 받아올 수가 없다. 이걸 우회하고자 중간함수(middle function) 이라는 함수를 내부에 만들어 호출이 될 때마다 i의 값을 중간함수의 지역변수인 x에 담게하고 이를 즉시 반환하게 해서 원하는 바를 동작할 수 있게 되어진다.

아래와 같이 중간함수를 외부에 미리 만들어두고 쓰는 방법으로 깔끔하게 처리할 수도있다.
```javascript
function binder(x){
    return x;
}



function f3(){
    let arr =[];
    for(let i=0; i< 3; i++){
        arr[i] = binder(i);
    }
    return arr;
}

const c3 = f3();
console.log(c3[1]);
// >> 1

```

#### 게터와 세터

클로저를 활용하면 아래와 같은 getter와 setter 를 통해서 내부 변수의 접근 제어를 할 수 있다.

```javascript


let getVal,setVal;

(function(){
    let secret = 0;

    getVal = function(){
        return secret;
    }

    setVal = function(val){
        if (typeof val === 'number') secret = val;
    }

})()

console.log(getVal());
// >> 0

setVal(7);

console.log(getVal());

// >> 7

secret;
// >> secret is not defined

```

#### 이터레이터

클로저를 통해 아래와 같은 반복자를 만들 수도 있다.

```javascript


function setup(x){
    let i = 0;
    return function() {
      if(x.length <= i){
            i = 0;
        }
        return x[i++];
    }
}

const next = setup(['a','b','c','d']);

console.log(next());
// >> a
console.log(next());
// >> b
console.log(next());
// >> c
console.log(next());
// >> d
console.log(next());
// >> a
console.log(next());
// >> b
console.log(next());
// >> c
```


#### IIFE 대블록
IIFE 대블록은 즉시 호출 함수(Immediately Invoked Function Expressions)를 말한다.
IIFE 는 블록 범위 내에는 고유의 scope 를 가지게 되어서 외부에서 접근이 불가능해진다. 

```javascript

(function(){
    let secret = 'haha';
})();

console.log(secret);
// >> secret is not defined

```

### 객체


#### 객체


+ 객체 리터럴 표기법(object literal notation)
    
    ```javascript
    let obj = {};
    ```

객체에는 속성(property)가 들어있다고 표현한다.  함수는 데이터일 뿐이므로, 객체의 속성은 함수를 가르킬 수 있다.

``` javascript

    let dog = {
        name : 'Benji',
        talk : function(){
            alert('woof, woof');
        }
    }

```
#### 배열


+ 배열 리터럴 표기법(array liternal nolation)

    ```javascript
    let arr = [];
    ```

배열에는 요소(element)가 들어 있다고 표현한다.


##### 해시와 연관 배열

일부 프로그래밍 언어에는 다음 둘 사이에 차이가 있다.

- 일반 배열 regular array : 인덱스 배열 또는 열거 배열로 불린다. 키는 숫자이다.

- 연관 배열 associate array) : 해시(hash) 또는 익셔너리(dictionary) 로 불린다. 키는 문자열이다.

자바스크립트는 배열을 사용해 인덱스 배열과 객체를 표시해서 연관배열을 나타낸다. 자바스크립트에서 해시를 원한다면 객체를 사용하면 된다.

##### 객체의 속성 접근

자바스크립트에서 객체 속성에 접근하는 방법은 두 가지가 있음.

- 대괄호 표기법 

```javascript
    dog['name']
```

- 도트 표기법
```javascript
    dog.name
```

아래는 개인적인 이야기인데, 도트 표기법이 읽고 쓰기 용이해서 자주 쓰는 편이다. 다만, 속성의 이름이 유효한 변수 이름이 아닐 경우에는 도트 표기법 한정으로 syntax 에러를 내기도 하는 게 있어서 주의해야한다 -_-;

예를 들면 아래와 같다.

```javascript
    let dog = {'name' : 'lemji', 'bow-wow' : function (){alert('wow');}};

    dog.bow-wow;
    // >> wow is not defined

    dog['bow-wow'];
    // >> ƒ (){alert('wow');}

```

객체는 포함 된 다른 객체의 데이터에도 접근이 가능하다.

```javascript

    let dog = 
    {'name' : 'lemji', 
    'bow-wow' : function (){alert('wow');}, 
    child : {name : 'cuti' }
    }
    
    dog.child.name;
    // >> cuti

    dog['child']['name'];
    // >> cuti

```

대괄호 표기법은 호출 속성을 변수로 지정할 수 있기에, 동적으로도 접근이 가능하다.

```javascript

    const key = 'name';
    
    let dog = 
    {'name' : 'lemji', 
    'bow-wow' : function (){alert('wow');}, 
    child : {name : 'cuti' }
    }

    dog[key];
    // >> lemji



```

#### 객체의 메소드 호출

메소드와 함수에 대해 혼동해 하는 사람이 많은 데, 메소드는 객체에 의존적이라는 점에 차이점이 있다. 다르게 표현하면 객체가 없으면 존재할 수 없다. 클래스 기반 언어 에서의 1등시민은 클래스이기 떄문에 어떠한 기능을 수행하기 위해서는 그 기능을 수행하는 객체가 먼저 선언(또는 호출)이 되어야 기능을 동작시킬 수 있다.

```java

public class Man{
    public void greeting(){
        ...
    }
}

public class mainClass{

    public static void main(){
        Man man = new Man();
        man.greeting();
        ...
    }

}

```


 반면 함수는 함수 기반 언어에서의 1등 시민이 함수 그 자체가 되기 때문에 객체고 뭐고 아무것도 필요없이 함수 자체를 호출해서 기능을 수행할 수 있다.
 

 
 
 ```javascript

    function greeting(){
        ...
    };

    greeting();

 ```

 또한 클래스 언어는 객체를 찍어내는 '틀' 이라는 개념이기에, 메소드 간의 복사(공유)가 어렵다. 반면 함수 기반 언어에서는 함수를 여러 객체에게 복사하거나 던지거나 지지고 볶고가 자유롭다.

그래서 객체 기반 언어에서 메소드와 함수를 '기능' 이라는 의미가 같다고 해서 이를 혼용해서 얘기하는 사람이 있으면 조심스레 피하자.. -_-;

#### this 값 사용

객체 안의 메소드는 객체의 속성(필드, 또는 멤버라 불리는)이나 메소드에 접근할 때 특별한 키워드인 this 를 통해 자유롭게 접근할 수 있다.

```javascript

    let dog = {
        name : 'venji',
        bow : function(){
            return 'wow~~'+this.name;
        }

    }
    dog.bow();
    // >> wow~~venji

```

#### 생성자 함수

객체를 생성하는 방법에 생성자(constructor) 함수를 사용하는 방법도 있다. 속성이 선언 되지 않았음에도 this 키워드로 생성되면서 만들어지는 게 부자연스럽지만, 자바와 매우 유사하다.

```javascript

function Dog(name){
    this.name = name;
    this.bow = function(){
        return 'wow~~~'+this.name;
    }
}

    let dog1 = Dog('venji');

    dog1.name;
    // >> venji
    dog1.bow();
    // >> wow~~~venji;




```

규약에 따라 생성자 함수는 문자의 어두를 대문자로 해야한다. (마치 객체 언어처럼) 또한 생성자 함수는 new 연산자를 통해야만 의도되로 동작한다.

```javascript
function Dog(name){
    this.name = name;
    this.bow = function(){
        return 'wow~~~'+this.name;
    }
}

let dog1 = Dog('venji');
dog1.bow();
// cannot read property 'bow' of undefiend;
name;
// >> venji


```

재밌는 것은 new 키워드 없이 Dog 함수를 호출 했을 때에, 내부의 this 가 가르키는 것은 전역 객체라는 것이다. 이런 이유로 name 이라는 전역 변수를 호출하면 'venji' 가 값으로 들어가있는 걸 확인할 수 있다..

#### 전역 객체

호스트 환경이 웹 브라우저이 경우, 전역 객체는 window 로 호출이 된다. 이 말은 웹 브라우저의 웹 페이지 안에서의 자바스크립트 코딩은 window 안에서 이리 뛰고 저리 뛸 수 있는 플레이그라운드가 된다는 소리이다. 

전역 객체의 접근은 생성자 함수 바깥에서 this 키워드를 사용하거나 window 의 속성으로 접근하면 된다.

```javascript

var globalVar = 123;
// let 으로 선언 시에는 window의 속성으로 할당 되지 않는다.
// let globalVar = 123;

globalVar;
// >> 123;

window.globalVar;
// >> 123;

window['globalVar'];
// >> 123;


```

재밌는 것은 var 키워드의 전역 변수 선언만 window 객체의 속성으로 할당이 된다.
이유는 

Both are still global, but vars are stored in the window object, while lets are stored in a declarative environment that you can't see (just like you can't access a variable in a function scope from outside of the function). When declared globally, both statements are pretty much identical in use.

let 은 ECMA 사양에 따라, window 의 속성에 들어가지 않도록 제안을 했다는 내용을 [검색으로](https://stackoverflow.com/questions/39414692/a-javascript-let-global-variable-is-not-a-property-of-window-unlike-a-global)찾아볼 수 있었다.

#### 생상자 속성

객체가 생성되면 특별한 constructor 속성이 내부적으로 만들어진다. 특정 객체의 constructor 속성은그 객체를 생성하는 생성자 함수를 참조하고 있다. 이를 응용하면 아래와 같은 같은 타입의 객체 생성을 아래의 코드처럼도 할 수 있다.

```javascript
function Dog(name){
    this.name = name;
    this.bow = function(){
        return 'wow~~~'+this.name;
    }
}
let dog1 = new Dog('venji');
dog1.name;
// >> venji

let dog2 = new dog1.constructor('qqq');
dog2.name;
// >> qqq;

```

##### instanceof 연산자

객체의 생성 정보를 알아 볼 수 있는, instanceof 연산자를 쓰면 객체가 어떻게 생성되었는지 알 수 있다.

```javascript
function Dog(name){
    this.name = name;
    this.bow = function(){
        return 'wow~~~'+this.name;
    }
}

let d1 = {};

let d2 = new Dog('ven');

d1 instanceof Object;
// >> true;


// Dog() 라 쓰지 않고 Dog 라고 쓰는 것은 함수 이름으로 객체 원형을 찾기 때문이다.
d1 instanceof Dog;
// >> false;

d2 instanceof Dog;
// >> true;

d2 instanceof Object;
// >> true;

```

typeof 와의 차이점은 typeof 는 6가지의 대표적인 객체 자료형을 알아본다면, instanceof 는 객체의 생성 원형을 알아보기 때문에 객체에만 쓸 수 있다는 점이 차이점이 있다.

##### 객체 생성의 주의점

```javascript

function SomeClass(){
    this.aaa= 1;
    return {bbb:2};
}

let s1 = new SomeClass();
s1.aaa;
// >> a is undefined;
s1.bbb;
// >> 2;
aaa;
// aaa is not defined;


```

해괴망측한 결과가 나왔다. 생성자 함수 내부에 return 이 있고, 이의 return 이 Object 라면 this.aaa 키워드는 무시가 된다. 이것은 this 가 생성자 내부에서 가장 맨처음에 선언이 되고 마지막에 할당되기 때문이다.

```javascript

function SomeClass(){
    // var this = {};
    this.aaa = 1;
    // {aaa : 1};
    //  this = {aaa : 1};
    return {bbb:2};
    // this = {bbb:2};
}
```


#### 객체 리터럴

객체를 선언하는 것에는 약식 구문을 사용할 수 있다. ES6 에서는 아래와 같이 간략히 할 수 있다.
이전에는 key 선언을 무조건 정적으로만 했었지만, ES6에 와서는 동적으로 가능해졌다.

```javascript

let obj = {
    prop : 1,
    modifier : function(){
        console.log(this.prop);
    }
}

// ES6
let obj2 = {
    prop : 2,
    modifier(){
        console.log(this.prop);
    }
}

// 동적 속성 key 선언

const keyName = 'haha_';

let obj3 = {
    prop : 3,
    [keyName + "modifier"] : function(){
        console.log(this.prop);
    }
}

obj3.haha_modifier();
// >> 3

```

#### 객체 복사

Object.assign 이라는 헬퍼 메소드를 사용하면, 얇은 카피를 할 수 있다. 얇은 카피란 A 와 B 가 있을 시 B가 A를 완전 대체하지 않고 덮어쓰는 걸 말한다. 완전 카피란 B가 A를 완전 대체할 정도로 복사되는 것이다.

```javascript

let a = {name : 'jj'};
const someObj = {age : 25}
Object.assign(a, someObj);
a.name;
// >> jj
a.age;
// >> 25;
a.age = 10;
a.age;
// >> 10;
someObj.age;
// >> 25;
someObj.name;
// >> undefiede;


```