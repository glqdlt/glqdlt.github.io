---
layout: post
title:  "gRPC"
author: "glqdlt"
---


# 들어가며

본 아티클은 차기 프로젝트에 gRPC 를 적용하기 위한 고민과 경험을 기록한 내용입니다.
아래에 서술 된 모든 소스는 [https://github.com/glqdlt/ex-grpc](https://github.com/glqdlt/ex-grpc) 모두 확인 할 수 있습니다.


# gRPC

<img src="https://grpc.io/img/landing-2.svg"/>

## gRPC 란

gRPC 는 Google 에서 만든 RPC(Remote Procedure Call)에 속하는 프레임워크입니다. 클라우드와 MSA(Micro Service Architecture)가 보편화되면서, 분산 서비스 node 간의 통신 성능이 화두 되어 기존 Restful API 보다 효율이 더 좋은 RPC 를 쉽게 사용하자는 취지로 만들어졌습니다. 


<img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/grpc-pub-sub1ty07.max-400x400.PNG"/>

성능적인 부분에 대한 이야기를 잠시 하면, 농단 반 섞인 이야기로 Restful API 대비 효율이 3배 좋다고 하는데요 -_-; 이에 대한 자세한 이야기는 [gRpc 성능 차트](https://cloud.google.com/blog/products/gcp/announcing-grpc-alpha-for-google-cloud-pubsub) 에서 확인해 볼 수 있습니다.


## gRPC의 특징

gRPC 의 가장 큰 특징으로는 언어 제약이 없는 [protocol buffers](https://developers.google.com/protocol-buffers/docs/overview)을 통한 바이너리 메세지와 Http/2 기반의 프로토콜을 사용하여 양방형 스트리밍이 가능하다는 점이 있습니다.

### 폴리그랏 랭귀지

<img src="/images/grpc/pb.PNG"/>

gRPC는 기반이 되는 프로토콜 버퍼 덕분에 다양한 언어에서 사용할 수 있습니다. 지원하는 언어는 아래와 같으며, 자세한 것은 [공식 문서](https://grpc.io/docs/quickstart/)에서 참고할 수 있습니다.

- C++
- C#
- [Dart](https://www.dartlang.org/) (클라이언트 플랫폼을 위한 JVM 기반 Transpile Language 입니다. 모바일 기기와 브라우저 위에서 동작합니다. 일종의 Google 에서 만든 Typescript라 생각하면 쉽습니다.)
- Go
- Java
- Android Java
- Node.js (공식적으로는 프론트엔드는 아직 미지원이지만 3rdpary 라이브러리로 [grpc-web](https://github.com/improbable-eng/grpc-web)가 존재합니다.)
- Objective-C
- PHP
- Python
- Ruby


### 스트리밍

gRPC 에서는 http2 프로토콜 위에서 동작합니다. 기존 http 1.1 과 달리 http2 에서 여러 이점이 생긴 덕에 스트리밍 통신을 지원합니다. 이에 대한 차이는

...



#### 스트리밍(server push promise)와 Pub/Sub 


여담인 이야기이지만 MSA 에서 node 들 간의 통신에 restful api 외에도 메세징 솔루션(예: apache kafka)들도 자주 사용하게 됩니다. 노드 간의 통신이라는 개념에서 gRPC의 스트리밍과 메세징 소룰션의 Pub/Sub 에 대해 비교할 수 있지 않은가를 생각해볼 수 있습니다. 메세징 솔루션은 불규칙한 시점에 구독자들에게 push 해주는 sub/pub 개념이고, 원하는 시점에 단일 대상에 호출하는 RPC 와는 설계와 개념에서 차이가 있습니다. ([gRPC vs Kafka](https://www.quora.com/How-should-I-choose-between-gRPC-and-Kafka-when-building-microservices) )

저 같은 경우에는 http2의 서버 푸시가 단어 어감 상.. [Pub / Sub 모델](https://ko.wikipedia.org/wiki/%EB%B0%9C%ED%96%89-%EA%B5%AC%EB%8F%85_%EB%AA%A8%EB%8D%B8)과 비슷한 아키텍처라고 오해(...) 하고 정말 많은 삽질을 했었습니다.

##### pub/ sub 모델이란?

여기서 잠시 Pub/Sub 모델에 대해 짚고 넘어가면, Pub/Sub 는 제공자(publisher) 와 구독자(subcriber) 그리고 중계자(broker)라는 개념이 있습니다.

<img src="https://cloud.solace.com/learn/_images/concept_pubsub_01.gif">

데이터를 제공하는 publisher 와 데이터를 수신하는 subscriber 계층이 존재하고, 이를 중간에서 제어해주는 broker(topic) 가 있습니다. 구독자들은 제공자에게 매번 데이터가 있는지를 체크하지 않고, 데이터가 '갱신' 될 때에만 데이터를 수신할 수 있습니다.

쉽게 예를 들어 설명하면 이벤트 문자메세지 구독서비스와 비슷합니다. 우리가 특정이벤트가 발생했는 지를 이벤트 회사에 매번 물어보기 보다는 자신의 휴대폰번호를 이벤트회사에 알려서 등록이 되면, 이벤트가 생겨 난 시점에 문자 메세지가 휴대폰으로 수신되어서 이벤트 발생 여부를 알 수가 있습니다. pub /sub 모델은 이와 같은 개념입니다. (여담이지만 여기서 이벤트 회사에 매번 물어보는 식은 Comet(Ajax Long Pooling) 기법이라 합니다.)

하지만 gRPC 는 RPC 모델이기에 pub / sub 과는 거리가 멉니다. RPC 는 요청과 응답이 있습니다. pub / sub 은 요청이 없더라도 한번 구독을 하게 되면 구독이 해지되기 전까지는 일방적으로 응답을 할 수 있는 반면, RPC 에서는 요청이 있어야 응답이 있습니다. 

이런 걸 극복하고자 gRPC 에서는 스트리밍이란 개념을 도입했습니다. gRPC는 스트리밍을 통해 pub/sub 모델과 유사하게 요청이 없더라도 응답을 받을 수 있습니다. 여기서 제가 많은 삽질을 하게 된 원인인데, pub / sub 은 구독을 해지하기 전까지라는 조건에서 알 수 있듯, 한번 연결되면 계속 연결을 유지합니다. 반면 gRPC 는 요청이 없더라도 최종 응답이 오면 연결이 종료 됩니다. 이는 Http 의 속성인 restful 한 성격 탓입니다. 

http2 에 와서 서버 푸시라는 기능 덕분에 일반 TCP 처럼 연결이 지속 되는 stateful 하게 바뀐 게 아니냐는 이야기가 있습니다. 이는 반은 맞는 말이고, http2 도 역시 restful 한 프로토콜입니다. 

http 자체는 restful 하게 설계 되었습니다. 

http 1.1 과 http 2 는 버전업(대체하는)이 아닌 새로 설게된 프로토콜입니다.

http 2 도 restful 합니다.


<img src="https://cdn-images-1.medium.com/max/800/1*2EduxBOtJ7ENgIna-aU4WA.png">

http 2 는 websocket 을 완전 대체하지 못합니다. 하지만 sse(server sent events) 를 통해 대체할 수는 있습니다. 단, 양방향인 websocket(서버 <-> 클라이언트)에 비해 sse 는 단방향입니다(서버 -> 클라이언트)
[sse](https://spoqa.github.io/2014/01/20/sse.html)

http 2 의 서버 푸시 기술은 브라우저에서만 처리 되고, 웹 asset 들을 효율적으로 보내기 위한 개념입니다. 서버에서 브라우저로 일방적으로 전송할 수 는 없습니다. 이 경우에는 SSE(Server send events)가 필요해집니다.

SSE는 javascript 만 있으면 가능합니다. http 1.1 에서도 됩니다. 단 빛을 발하지 못했던 것은 SSE는 http 패킷을 그대로 사용하기 때문에 패킷 오버헤드가 있어서 데이터가 무거웠습니다. 사실, comet 과 같은 ajax long pooling 기법을 썼던 기술에도 오버헤드가 있는데도 쓰는 것을 생각해보면 SSE 의 이러한 것은 상관없는 얘기가 됩니다.

SSE 는 HTTP 2에 들어서면 빛을 발하게 됬습니다. HTTP2 의 헤더 압축으로 틴해 패킷 오버헤드가 줄어들게 되어서 웹소켓과 거의 대등한 수준의 퍼포먼스를 가집니다. 단, 웹소켓은 양방향인 반면 SSE 는 단방향입니다. 거기에 웹소켓은 바이너리 데이터를 보낼수 있는 반면 SSE는 UTF-8 의 문자 데이터만 보낼 수 있도록 설계 되었습니다.

SSE 는 기본적으로 연결이 긴 일반 HTTP 커넥션으로 데이터를 받아옵니다. 단지 투명하게(어떻게 구현하고 커넥션을 관리하는지 신경아쓰고) browser 의 dom api 를 호출하고 구현만하면.. 서버에서 response 가 있어야할 때에만 데이터를 받아오게 할 수 있습니다. 사용자가 브라우저 탭을 다른 곳에 돌리게 되면 SSE 가 일시적으로 커넥션을 해지한다던가, 사용자가 브라우저를 끌 때에 SSE 커넥션을 해지한다던가.. 등의 커넥션 관리는 신경 쓰지 않아도 됩니다, SSE 를 구현한 브라우저에서 알아서 처리해줍니다.

SSE는 일반적으로 연결된 HTTP 커넥션에서 사용됩니다. 연결이 도중에 끊기더라도 SSE를 구현한 브라우저가 알아서 다시 이벤트를 수신하게 해줍니다. [https://stackoverflow.com/questions/33265773/http-1-1-message-protocol-and-server-sent-events](https://stackoverflow.com/questions/33265773/http-1-1-message-protocol-and-server-sent-events)

https://hpbn.co/server-sent-events-sse/

이야기가 또 옆으로 새는 것이지만 -_-;; http2 에서 서버 푸시라는 기능은 (server push promise라 불리는) '1커넥션에서 n 개의 데이터를 보낼 수 있다' 이지, 1커넥션이 계속 지속된다는 것은 아닙니다. [http2 에서 keep-alive 는 무시가 됩니다.](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Keep-Alive)

http://kimseunghyun76.tistory.com/447

```java

// 아래 디펜던시 필요
    //    <dependency>
    //         <groupId>org.springframework.boot</groupId>
    //         <artifactId>spring-boot-starter-webflux</artifactId>
    //         <version>2.1.1.RELEASE</version>
    //     </dependency>


@CrossOrigin
    @GetMapping(path = "/stream-flux", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> streamFlux() {
        return Flux.interval(Duration.ofSeconds(1))
                .map(sequence -> "Flux - " + LocalTime.now().toString());
    }


```


https://okky.kr/article/380704

https://okky.kr/article/380704

[https://beyondj2ee.wordpress.com/2014/01/27/tcp-keep-alive-%ED%80%B5-%EC%A0%95%EB%A6%AC/](https://beyondj2ee.wordpress.com/2014/01/27/tcp-keep-alive-%ED%80%B5-%EC%A0%95%EB%A6%AC/)

[http://b.pungjoo.com/entry/HTTP-11-Keep-Alive-%EA%B8%B0%EB%8A%A5%EC%97%90-%EB%8C%80%ED%95%B4](http://b.pungjoo.com/entry/HTTP-11-Keep-Alive-%EA%B8%B0%EB%8A%A5%EC%97%90-%EB%8C%80%ED%95%B4)



[웹소켓 과 차이](https://www.infoq.com/articles/websocket-and-http2-coexist)

물론 http2 스펙의 덕에 추가 커넥션(또는 추가 Request) 없이도 특정 Message를 push 할 수는 있습니다. 이는 newStub() 

이런 이유 떄문인지 gRPC 에는 sub/pub 기능을 지원하지 않고 있고, 이는 [Google Cloud PubSub - with the power of gRPC!](https://cloud.google.com/pubsub/docs/quickstart-client-libraries#pubsub-client-libraries-java) 라이브러리를 사용하라고 권유하고 있습니다. gRPC Pub/Sub 가이드는[여기](https://cloud.google.com/pubsub/docs/quickstart-client-libraries#pubsub-client-libraries-java), [또는 여기](https://github.com/googleapis/googleapis/blob/master/google/pubsub/v1beta2/pubsub.proto) 확인할 수 있습니다.


하지만 [gRpc-pubsub-broker](https://github.com/IAmMorrow/grpc-pubsub-broker) 와 같은 여러가지 노력을 보면 gRPC 의 스트리밍을 통해 pub/sub 을 구현하는 것이 불가능한 것은 아닙니다.



## RPC 란

RPC(Remote Procedure Call)는 의미 그대로 원격지에서 guest 가 host 의 function(method)을 호출하고 그 결과를 받는 식의 자연스러운 로직 flow를 가지자는 개념입니다.

RPC 는 오래 전 부터 있던 개념으로 매우 획기적인 컨셉에 비해 사용성이 어려워서 많이 알려지지 않았습니다.
(개인적으로는 처음 접한 RPC는 신입 시절 [Adobe Flex ~ Java SOAP](https://www.tutorialspoint.com/flex/flex_rpc_services.htm)를 경험해본게 최초였습니다. -_-a) 

원격지에서 호출한다는 개념 자체가 Guest 와 Host 간의 통신을 관리되야 함을 의미하고, 여기에 공통 된 프로토콜을 정의하고 공유해야 한다는 전제 떄문에 사용성과 관리가 어려웠습니다.

RPC 구현체로는 대표적으로 아래와 같습니다.

- CORBA
- SOAP
- Java RMI
- Microsoft RPC
- ODBC
- Apache Thrift

최근에는 Thrift 가 소셜 네트워킹 기업에서 사랑 받으면서 점차 RPC의 관심도가 커지고 있는 추세입니다.


## gRPC 구조


<img src="https://image.slidesharecdn.com/grpctalk1-160507200742/95/grpc-overview-17-638.jpg?cb=1462651696">

출처 : [gRPC Overview](https://www.slideshare.net/VarunTalwar4/grpc-overview)

gRPC 는 총 3개의 계층 구조를 가집니다.

Application Layer 에서는 정의 된 .proto 파일을 기반으로 Proto Buffer 에서 어플리케이션에 적용할 구현체(자바의 class)를 생성 하는 기능을 수행하고, 생성 된 구현체들은 gRPC Core 를 통해 Http 2 위에서 통신하게 되는 구조입니다.

참고로 gRPC 에서 같은 infra 환경 내의 서비스 노드 간의 커넥션은 최초 요청후 channel.terminate 요청 전까지는 계속 channel 이 서버에 커넥션 됩니다.

## gRPC 와 서블릿

gRPC 는 Http 2 기반이기에, http2 를 포함하는 Servlet4 구현체 중 하나인 tomcat 9 버전에서 쉽게 동작할 수 있지 않을까 생각을 했봤는 데, gRPC 에서 서블릿은 미지원이라는 것을 알게 되었습니다. (netty 프레임워크 나 okHttp 는 지원)

궁금해서 구글링을 통해 찾아보다가 [관련 토픽](https://github.com/grpc/grpc-java/issues/1621)에서 여러 이유를 알게 되었는 데,
 gRPC 는 http2의 모든 소켓을 완전히 제어할 수 있어야 한다는 전제가 필요 한것으로 보입니다.(이 완전 제어에 대해서는 좀 더 탐구해봐야할 거 같네요.) 서블릿은 이에 적합하지 않은 구조를 가지고 있어서 지원이 불가능하다는 것인데 그래도 영 불가능한 것은 아닌지, 몇몇 스레드를 보면 wildfly(jboss 의 오픈소스 버전)를 기반으로 시도한 흥미로운 사례도 있어 향후 어떻게 발전할지는 모르겠습니다. -_-a

정리를 하면 웹 프로젝트에 있어서는 서블릿 컨테이너의 http2 통신을 이용해서 gRPC 를 동작시키는 것은 불가능하고, 서블릿 컨테이너 위에서 okHttp 나 netty 등의 http2 구현체를 애드온 하는 형태로 개발 해야한다는 것을 의미합니다.



# Getting start

공식 가이드에 있는 예제를 통해 gRPC 를 살짝 맛 봤습니다.
당연한 이야기이지만, 자바로 먹고 살고 있기에 예제 소스는 자바와 메이븐 기반입니다. (추후 NodeJs 기반 Client 정도 작성 할지도 모르겠네요.)

## Working flow

gRPC 기반 프로젝트 워킹 플로우를 수행하면 아래와 같습니다.


1. .proto 작성

2. proto buffer 컴파일

    컴파일 방법은 아래 2가지 중 택 1

    1. (자동) [proto buffer generate plugin](https://github.com/xolstice/protobuf-maven-plugin) : 메이븐 빌드 커맨드에 애드온

        또는

    2. (수동) [proto buffer compiler](https://github.com/protocolbuffers/protobuf/releases) 를 직접 실행시켜 생성

3. proto buffer 생성 된 구현체와 어플리케이션 로직과의 연결

4. Server : Server Run()

5. Client : server remote method call()

저는 게으르기에 메이븐 빌드 커맨드에 에드온 해서 자동 생성하는 식으로 접근 했습니다.

## 단방향 gRPC

gRPC 에서는 일반적인 RPC 형태인 단방향의 단일 call 의 형태도 지원하고, 단방향이지만 stream 자체를 전달받아 calls 를 호출 받는 형태도 지원합니다. 이런 구조를 응용해서 양방향 stream 지원합니다.

여기서 스트림이란 무엇일까요? [https://grpc.io/docs/guides/concepts.html#overview](https://grpc.io/docs/guides/concepts.html#overview) 

기본적으로 둘 다 어떠한 데이터를 응답받을 것이라는 stub 을 기대하는 것은 맞습니다. 차이가 있다면, 단일 call 의 경우에는 데이터의 최종 complete() 콜 까지 server 에 위임하고 client 는 그 기간동안 기다리는 것을 의미합니다. 예를 들어서 설명해보겠습니다. server 의 로직은 1L 물통을 준비하고 물이 다 찰 때까지 물을 채우는 일을 하는 로직을 가지고 있다고 칩시다. 여기서 단방향 call 은 1L 물통에 1L의 물이 가득찰 때 까지 대기하게 됩니다. 반면 client 의 stream 자체를 받아서 callback으로 물통에 물이 찰 때마다 client 에 callback 을 호출해주는 형태의 경우에는 물이 물통에 들어갈때마다 client 에 알려주는 차이가 있습니다.

이 차이는 매우 큽니다. 예를 들어 1L 물통의 물을 모두 빨간색으로 물들여야야 한다면, 물통이 다 가득차고 난뒤에 빨갛게 물들이는 것보다, 물이 들어올 떄 마다 빨간색으로 처리켜주는 것이 더 빠르게 끝날 수 있습니다.(비유를 하면 그렇습니다.)

이러한 방법을 기존 http 1.1 에서 진행할 때에는, 물통에 물이 들어올 때 마다 client 가 물에 물통을 넣어달라고 요청을 했었습니다. 반면 http2 에서는 이러한 요청작업이 매번 마다 일어나는 것은 아니고, 물이 당연히 들어올 거라고 기대하게 되는 형태(물이 들어오면 callback)입니다.

여담이지만 http2 를 보고 statefull 인지, stateless 인지에 대한 헷갈려 하는 토픽들을 많이 볼 수 있습니다. 기본적으로 http2 는 기존 http1.1 과 마찬가지로 restfull 개념을 승계하고 있으며 (stateless) 많이들 오해하는 http2 는 커넥션을 계속 물고 있을 것이라는 것은 조금 다릅니다. 

기존 http 에서 설계적으로 모든 http 패킷은 한번의 request 와 한번의 response 가 쌍을 이루는 형태로 설계되었습니다. 이것이 restfull 로 바라보면 되는 데, 문제는 웹을 이루는 asset 들은 단순히 html 파일 하나만 있거나 하는 것이 아니라 여러가지 js 와 img, html 파일들로 이루어진 하나의 group 된 단위로 이루어진다는 문제가 있습니다. 이런 문제 때문에 서비스 규모가 큰 웹 서비스에서는 asset 들을 다 받기만 하는 데도 병렬처리를 못하여 최대 몇 분 까지의 asset 들을 받는 경직된 시간을 가지게 됩니다.

이를 해결하고자 여러 방법들이 있었는 데, 그것도 한계가 있었습니다. 가장 유망했던 방법 중에서는 한 커넥션 세션에서 같은 도메인 상에서 4~6 개의 추가적인 스트림을 열어 병렬 추가 request 를 보내던 꼼수에서, http2 에 들어서 최대 [100개](https://stackoverflow.com/questions/36835972/does-the-per-host-connection-limit-is-raised-with-http-2) 까지의 추가 스트림을 열어서 병렬로 처리할 수 있게 되면서 이를 해결하고자 처리하게 된 것 입니다.

최대 100개 까지 하게 된 마법은 아래와 같습니다.

1. 최초 커넥션을 맺으며 서버에 request 를 보내고, start http header 를 보냄

2. close http header 를 보내기 전 까지 필요한 경우 single request or multi request 를 보냄

3. close http header 가 오면 서버에서 응답할 차례

4. 서버에서는 이후로 최대 100개까지의 스트림을 열어 파일을 push 할 수 있음(http server push)

5. 이 마법이 가능해지는 것은, http2 스펙의 압축된 header 정보를 기반으로 request 가 여러번 온 것 과 같은 상황을 가정할 수 있기 때문

6. 압축된 http header 를 기반으로 server 에서 최대 100개까지의 여러 asset 들을 push 보냄 (순서는 의미 없음)

7. asset 들이 모두 보내졌다고 판단한 server는 complete() 콜사인을 client 로 보내면서 자신의 모든 stream 이 닫혔다는 것을 client 에 보낸다.

8. client 는 complete() 사인을 받고 그때서야 커넥션 세션을 닫게 된다.






이에 대한 것은 [이곳](https://b.luavis.kr/http2/http2-overall-operation) 에서 잘 정리한 글이 있어 자세한 설명은 대체하겠습니다.

어떠한 이벤트가 일어날 때 커넥션을 재할당 하지 않을 뿐 이지, (어디로 커넥션을 맺어야할지, 어디에 맺었었는지를 이미 알고 있을 뿐) 커넥션 자체를 지속적으로 맺고 있는 것은 아닙니다.

### gRPC with stream

gRPC 에서는 단방향 통신과 스트리밍통신을 제공합니다. 단방향은 하나의 메소드를 제공하고, 스트리밍 통신에서는 3가지 타입의 메소드들을 제공합니다.

메소드 타입들은 proto 파일을 통해 base code가 생성될 때, stream 키워드가 있느냐 없느냐? 있다면 선언이 어디에 되어있느냐(Argument 또는 return)에 따라 어떻게 통신 할 지가 결정이 됩니다.

#### Method Types

- UNARY : 단방향
    
    1커넥션에서 1건의 요청과 이 요청에 답하는 1건의 응답이 있습니다.

    request <-> response

    proto syntax:

    ```rpc clientSideStream(stream SimpleRequest) returns (SimpleResponse);```

- CLIENT_STREAMING : 클라이언트 스트리밍

    1커넥션에서 0건 이상의 요청에 이 요청에 답하는 1건의 응답이 있습니다.

    request <|->>>>> response
    
    proto syntax:

    ```rpc serverSideStream(SimpleRequest) returns (stream SimpleResponse);```

- SERVER_STREAMING : 서버 스트리밍

    1커넥션에서 1개의 요청에 0개 이상의 응답이 있습니다.

    request <<<<<-> response

    proto syntax:

    ```rpc simpleServerToClient(SimpleRequest) returns (SimpleResponse);```

- BIDI_STREAMING : 양방향 스트리밍

    1커넥션에서 0개 이상의 응답과 요청이 있습니다.

    reqeust <<<<->>>> response

    proto syntax:

    ```rpc bidirectionalStream(stream SimpleRequest) returns (stream SimpleResponse);}```

메소드 타입에 대한 내용은 (JAVA 소스 기준) [MethodType Enum 자바 API 문서](https://grpc.io/grpc-java/javadoc/io/grpc/MethodDescriptor.MethodType.html) 에서도 자세한 설명을 얻을 수 있습니다.


클라이언트 소스 상에서 아래와 같이 call 을 할 때를 후킹하는 인터셉터를 걸어서 실제 해당 call이 어떠한 Method Type 인지를 출력해 볼 수도 있습니다.

```java

public class ClientApplication {
public static void main(String[] args) {
        ManagedChannel channel = ManagedChannelBuilder

                ...

                .intercept(new SimpleHookClientInterceptor())
                .build();

    ...

}

public class SimpleHookClientInterceptor implements ClientInterceptor {
    private final static Logger logger = LoggerFactory.getLogger(SimpleHookClientInterceptor.class);

    @Override
    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {
        logger.info("method : {}, callOpt : {}, next : {}", method.getType(), callOptions.getCredentials(), next.authority());
        return next.newCall(method, callOptions);
    }
}


```

<img src="/images/grpc/method_types.PNG"/>

### Example Project Structure


[예제 소스](https://github.com/glqdlt/ex-grpc) 의 구조는 3개의 모듈로 이루어진 멀티 모듈 구조입니다.

각 모듈은 아래와 같습니다.

```
grpc-exam
ㄴclient : host method 를 호출 할 client 에 해당
ㄴmodel : proto 파일이 위치함. client 와 server 에서는 이 model module 을 의존.
ㄴserver : host method 를 제공 할 server 에 해당

```

### Model module source

model module source 에는 단순히 proto buffer 에 대한 정의를 하는 모듈이기에, 어떻게 보면 핵심이라 할 수 있습니다. 
이 모듈에는 proto 의 정의와 이를 build 하기 위한 maven plugin 가 정의 됩니다.


아래는 model module 의 메이븐 설정.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>com.glqdlt.ex.grpc</groupId>
        <artifactId>grpc-exam</artifactId>
        <version>1.1</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.glqdlt.ex.grpc</groupId>
    <artifactId>model</artifactId>
    <version>1.0-SNAPSHOT</version>


    <properties>
        <java.version>1.8</java.version>
        <grpc.version>1.17.1</grpc.version>
        <protobuf.version>3.5.1</protobuf.version>
        <protoc.version>3.5.1-1</protoc.version>
        <netty.tcnative.version>2.0.7.Final</netty.tcnative.version>
    </properties>


    <dependencies>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>20.0</version>
        </dependency>

        <dependency>
            <groupId>kr.motd.maven</groupId>
            <artifactId>os-maven-plugin</artifactId>
            <version>1.5.0.Final</version>
        </dependency>

        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-testing</artifactId>
            <version>${grpc.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java-util</artifactId>
            <version>${protobuf.version}</version>
        </dependency>

        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-netty-shaded</artifactId>
            <version>${grpc.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-protobuf</artifactId>
            <version>${grpc.version}</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-stub</artifactId>
            <version>${grpc.version}</version>
        </dependency>
    </dependencies>


    <build>
    <!-- 아래 build plugin 에 ${os.detected.classifier} OS 정보를 넣어주기 위한 확장 플러그인 -->
        <extensions>
            <extension>
                <groupId>kr.motd.maven</groupId>
                <artifactId>os-maven-plugin</artifactId>
                <version>1.5.0.Final</version>
            </extension>
        </extensions>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            <!-- maven 의 compile 단계에서 .proto 를 generate 플러그인 -->
            <plugin>
                <groupId>org.xolstice.maven.plugins</groupId>
                <artifactId>protobuf-maven-plugin</artifactId>
                <version>0.5.1</version>
                <configuration>
                    <protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}</protocArtifact>
                    <pluginId>grpc-java</pluginId>
                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>compile</goal>
                            <goal>compile-custom</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>


        </plugins>
    </build>


</project>
```


#### User.proto

.proto 는 proto buffer 의 syntax 로 작성됩니다. 일반적인 객체 class 문법과 비슷합니다. 

```proto
// proto 파일의 버전을 서술, 문법에 해당한다고 보면 됨.
syntax = "proto3";

// proto 가 빌드될 target package. 생략되면 classpath:/ 루트에 빌드됨
package com.glqdlt.ex.grpc.client.model;

// java 의 enum 과 같음
enum Sex{
    MAN = 0;
    WOMAN = 1;
}

// host 에 위치하게 될 서비스 class 의 이름
service UserService {
    // 실제 호출 될 메소드의 인터페이스를 정의
    rpc getUserDetail (UserRequest) returns (UserDetail) {};
}

// message 키워드가 붙는 것은 Value Object 라고 보면 됨. 특이한 점은 필드의 순서를 정의한다는 점. 
// 또한 message 들은 빌더 패턴으로 생성됨.
message UserRequest {
    string id = 1;
}

message UserDetail {
    string id = 1;
    string name = 2;
    int32 age = 6;
    Sex sex = 4;
    string password = 3;
    string address = 5;
    repeated string hobbies = 7;
    map<string, string> auth = 8;
}
```

model module 를 빌드 하게 되면 아래와 같이 User.proto 가 class 파일로 컴파일 된 것을 알 수가 있습니다.

물론, class 외에도 java 소스 원본도 존재합니다. generated sources 폴더에 가면 원본 .java 파일이 생성 되어 있음을 알 수 있습니다.

<img src ="/images/grpc/model_generated.PNG">



### Server module source

server module 에서는 실제 원격 호출 될 로직이 존재하는 곳으로서 model module 에서 생성 된 구현체 들을 base 삼아서 로직을 작성하는 것이 핵심.

아래는 server module 의 메이븐 설정
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.1.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.glqdlt.ex.grpc</groupId>
	<artifactId>server</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>server</name>
	<description>Demo project for Spring Boot</description>

	<properties>
		<java.version>1.8</java.version>
		<grpc.version>1.17.1</grpc.version><!-- CURRENT_GRPC_VERSION -->
		<protobuf.version>3.5.1</protobuf.version>
		<protoc.version>3.5.1-1</protoc.version>
		<netty.tcnative.version>2.0.7.Final</netty.tcnative.version>
	</properties>

	<dependencies>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>

		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
        <!-- model module 을 의존 -->
		<dependency>
			<groupId>com.glqdlt.ex.grpc</groupId>
			<artifactId>model</artifactId>
			<version>1.0-SNAPSHOT</version>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>

		</plugins>
	</build>

</project>


```

proto 파일에서 생성 된 클래스를 base로 한 UserService 구현체
```java
package com.glqdlt.ex.grpcexam;

// model 모듈의 .proto 에서 생성된 소스들을 import
import com.glqdlt.ex.grpcexam.model.User;
import com.glqdlt.ex.grpcexam.model.UserServiceGrpc;
import io.grpc.stub.StreamObserver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
public class UserServiceGrpcImplement extends UserServiceGrpc.UserServiceImplBase {
    private final Logger logger = LoggerFactory.getLogger(UserServiceGrpcImplement.class);

    private static final String SOME_USER_ID = "glqdlt";

    private User.UserDetail generateUserDetail() {
        return User.UserDetail.newBuilder()
                .setId(SOME_USER_ID)
                .setAddress("Seoul")
                .setAge(20)
                .setName("Jhun")
                .setPassword("12345")
                .setSex(User.Sex.MAN)
                .addHobbies("Coding")
                .addHobbies("Walking")
                .putAuth("role", "admin")
                .build();
    }
    

    @Override
    public void getUserDetail(User.UserRequest request, StreamObserver<User.UserDetail> responseObserver) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Optional<String> req = Optional.ofNullable(request.getId());
        logger.info("Get Request : {}",req.orElse("Null?"));
        if (req.isPresent()) {
            if (req.get().toUpperCase().equals(SOME_USER_ID.toUpperCase())) {
                responseObserver.onNext(generateUserDetail());
                responseObserver.onCompleted();
            }
        } else {
            responseObserver.onError(new RuntimeException("Bad Wrong Request..!"));
        }
    }
}

```

아래는 위 구현체들을 로드 할 부트스트랩 클래스

```java
package com.glqdlt.ex.grpcexam;

import io.grpc.Server;
import io.grpc.ServerBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.IOException;


@Component
public class GrpcServer {

    private final Logger logger = LoggerFactory.getLogger(GrpcServer.class);

    private static final String prop = "grpc.server.port";

    @Value("${grpc.server.port}")
    private Integer port;

    @Autowired
    private UserServiceGrpcImplement userServiceGrpcImplement;

    private Server server;

    public void start() throws IOException, InterruptedException {
        if (port == null || port == 0) {
            logger.error("gRpc Server Port is Not SetUp..! '{}' need check!", prop);
            System.exit(-1);
        }
        server = ServerBuilder.forPort(port)
                .addService(userServiceGrpcImplement)
                .build();
        server.start();
        logger.info("gRPC Server  Started! Port : {} ", server.getPort());
        Runtime.getRuntime().addShutdownHook(new Thread(GrpcServer.this::stop));
        server.awaitTermination();
    }

    private void stop() {
        server.shutdown();
    }

}

```

### Client module source

gRPC 의 Client 에서 중요한 개념은 stub 이라는 개념이 중요합니다. TEST 를 하다 보면 마주치는 stub 이라는 용어와도 비슷합니다. TEST 에서의 stub 은 canned answer 의 의미를 갖는 객체인데, canned answer는 정해진 대답이란 사전적인 의미를 갖습니다. 쉽게 풀어 말하면 단어 외우기 시험과 비슷합니다, 출제 될 특정 단어들을 기재하고 실제 문제에서 해당 문제의 뜻을 작성하는 시험과 비슷하게 어떠한 것을 사전에 약속하고 질의응답을 하는 개념이죠.([Test Stub 이란 무엇인가](https://medium.com/@SlackBeck/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%85%81-test-stub-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-ff9c8840c1b0))

gRPC에서 Stub은 개념적인 의미로는 위와 같으며, 기대하는 응답에 대한 반응을 작성하는 걸 의미합니다. 그래서 실제 코드 블록을 보면 client 와 server간의 커뮤니케이션이 성공했을 때와 실패했을 때를 정의하는 것을 알 수 있습니다.([Stub Wiki](https://en.wikipedia.org/wiki/Stub_(distributed_computing))[Stub vs Mock](https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da))



```java

package com.glqdlt.ex.grpc.client;

import com.glqdlt.ex.grpcexam.model.User;
import com.glqdlt.ex.grpcexam.model.UserServiceGrpc;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.stub.StreamObserver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

@SpringBootApplication
public class ClientApplication implements CommandLineRunner {

    private static final String REQUEST_ID = "glqdlt";

    @Value("${grpc.server.port}")
    private Integer port;

    private final Logger logger = LoggerFactory.getLogger(ClientApplication.class);

    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
    }

    private void callBack(User.UserDetail userDetail) {
        logger.info("Received! Response : {}", userDetail);
    }

    @Override
    public void run(String... args) throws Exception {
        ManagedChannel channel = ManagedChannelBuilder
                .forAddress("localhost", port)
                .usePlaintext()
                .build();
        User.UserRequest req = User.UserRequest.newBuilder().setId(REQUEST_ID).build();

        UserServiceGrpc.UserServiceStub serverResponse = UserServiceGrpc.newStub(channel);
        serverResponse.getUserDetail(req, new StreamObserver<User.UserDetail>() {
            // 서버에서의 응답이 있을 때마다 호출되는 메소드.
            // onNext 는 서버에서 여러번 보낼 수 있다는 점을 유의
            @Override
            public void onNext(User.UserDetail userDetail) {
                callBack(userDetail);
            }

            // error 캐치
            @Override
            public void onError(Throwable throwable) {
                logger.error(throwable.getMessage(), throwable);
            }

            // 서버에서 finish 콜이 왔을 때 호출되는 메소드.
            @Override
            public void onCompleted() {
                logger.info("Done!");
            }
        });

        // 아래는 단순히 0~50번 까지 숫자를 찍는 스트림
        IntStream.rangeClosed(0, 50).forEach(x -> {
            try {
                logger.info("is Done ?  .. : {}", x);
                Thread.sleep(50);
            } catch (InterruptedException e) {
                logger.error(e.getMessage(), e);
            }
        });
        channel.awaitTermination(5, TimeUnit.SECONDS);
        logger.info("Channel Terminated");
    }

}


gRPC 는 총 3가지의 stub을 제공합니다. 기본적으로 동기/비동기로 구분되어 있으며, 동기 객체인 BlockingStub 을 제공하는 ```Grpc.newBrockingStub()```, 비동기로 finishCall 이 올때에 callback을 받는 FutreStub을 제공하는 ```Grpc.newFutureStub()```, stream을 세세하게 정의할 수 있는 ```Grpc.newStub()``` 정적 메소드 들로 구분이 됩니다.



- newBlockingStub() 
    
    동기 방식으로 구성 된 BlockingStub 입니다. 단방향으로 처리 되며, 서버에서의 응답 값이 오면 해당 응답값을 받는 동안 로직은 블록킹 되고, 응답이 오면 연결을 끊습니다.
    
    
- newFutureStub()

    비동기 async 메소드 이지만, Future 를 응답한다는 점에서 차이가 있음. Future를 직접 핸들링 해서 응답이 오기 까지 잠시 선행 작업을 처리하고 future.get()에 실제 응답이 오기까지 blocking 하고 싶을 경우 사용성이 더 적합함.


- newStub() 

    스트림을 세세히 정의 할 수 있는 stub 입니다. 


동기와 비동기의 차이는 아래 다이어그램으로 설명합니다.

##### 동기
<img src ="/images/grpc/sync.png"/>


##### 비동기
<img src="/images/grpc/async.png"/>





아래는 client module 의 메이븐 설정

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.1.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.glqdlt.ex.grpc</groupId>
    <artifactId>client</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>client</name>
    <description>Demo project for Spring Boot</description>

    <properties>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency><dependency>
        <!-- server module 과 마찬가지로 model module 을 의존 -->
        <groupId>com.glqdlt.ex.grpc</groupId>
        <artifactId>model</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```


# next step

- [Authentication](https://grpc.io/docs/guides/auth.html#java) : 이번 예제에는 보안을 고려안한 plainText() 로 접근만 했기에 보안 레이어가 적용된 것에 대한 탐구가 필요

- 양방향 스트리밍 

- [Loadbalacing](https://grpc.io/blog/loadbalancing) : gRPC 와 로드밸런싱

- [gRPC Web Frontend](https://github.com/improbable-eng/grpc-web) : 서드파티에서 구현한 gRPC 웹 프론트엔드의 탐구.

# ref

아래는 참고헀던 레퍼런스

- [공식 가이드](https://grpc.io/docs/tutorials/basic/java.html)

- [잘 정리된 블로그](https://medium.com/@goinhacker/microservices-with-grpc-d504133d191d)

- [gRPC - Ray Rsang](https://youtu.be/xpmFhTMqWhc)

- [Java Hello World Tutorial](https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/helloworld/HelloWorldServer.java)


- [https://github.com/saturnism/grpc-java-by-example](https://github.com/saturnism/grpc-java-by-example)


## Bidirectional Streaming(양방향 스트리밍)

[https://github.com/nddipiazza/grpc-java-bidirectional-streaming-example/blob/master/src/main/java/GrpcExampleClient.java](https://github.com/nddipiazza/grpc-java-bidirectional-streaming-example/blob/master/src/main/java/GrpcExampleClient.java)



[https://www.programcreek.com/java-api-examples/?api=io.grpc.stub.StreamObserver](https://www.programcreek.com/java-api-examples/?api=io.grpc.stub.StreamObserver)

[https://github.com/grpc/grpc-java/tree/master/examples](https://github.com/grpc/grpc-java/tree/master/examples)

[https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideClient.java](https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideClient.java)


[https://developers.google.com/web/fundamentals/performance/http2/?hl=ko#_8](https://developers.google.com/web/fundamentals/performance/http2/?hl=ko#_8)


## http2 와 서버 푸시(server push promise) 에 대한 단상

서버 푸시가 pub / sub 랑 동일한 개념이라고 생각을 했다. 이게 무슨 말이냐면, pub / sub 개념에서는 push 를 받고자 하는 client 가 server 에 구독 (subscribe)을 하며 push 가 올 것을 생각하고 있게 되고, server 에서는 푸시 조건이 트리거 되면 메세지를 구독자들에게 push 해주는 개념이다. 즉 요청이 없이 일방적으로도 push 를 할 수 있다.

나는 http2 의 서버푸시도 이와 같은 것이 아닌가 생각했다. 구글링을 해보면 많은 이들이 나와 똑같이 'http2 server push vs websocket' 이란 키워드로 검색이 많이 된다. websocket 은 브라우저와 웹 서버 간의 pub / sub 아키텍처 로 된 프로토콜이다. 즉 서버 푸시를 pub / sub 으로 오해하면 당연히 web socket 과 http2 서버 푸시를 비교하게 된다.

얘기가 많이 샜는 데, 말하고 싶은 바는 http2 에서의 서버 푸시는 pub / sub 와 달랐다. 이게 무슨 소리냐면 http 2 에서의 server push 는 pub /sub 처럼 일방적으로 푸시 하는 게 아니라, client의 단일 요청에서 여러가지 응답을 보낼수 있다는 것이다. 그리고 이 요청은 keep alive 에 의해 오래 유지될 뿐이고, 영원히 유지되지는 않는다. 아직 학습이 덜 되어서 개인적으로는 개선된 keep alive 로 생각하고 있다.

이걸 기존 http 1.1 과 비교를 해보면 쉽게 이해할 수 있다. 기존 http 1.1 에서는 server에서 특정 리소스와 데이터를 여러번 보내려면  req <-> server 요청과 응답이 4번 있어야 했다. 예를 들어서 아래와 같은 4개의 웹 리소스가 있다고 가정하자.

```
index.html
app.js
app.png
style.css
```

이 경우 http 1.1 은 아래와 같이 된다.

1. index.html 요청, 서버에서  index.html 응답

2. app.js 요청, 서버에서 app.js 응답

...

4. style.css 요청, 서버에서 style.css 응답

즉, 총 4번의 요청과 4번의 응답이 있다. 단순하게 서버에서 여러번 보내주면 되잖아? 로 생각할 수 있는 데.. 서버에서는 응답할 수 있는 건 1종류의 데이터타입으로 1건의 응답할 수 있다. 무조건이다, can 이 아니라 must -_-; 그래서 불가능했다.

반면 http 2 에서는

1. index.html 요청, 서버에서 index.html 응답

2. 서버에서 추가적으로 app.js , app.png , style.css 를 응답

최초의 요청에서 index.html 에 관련 된 모든 리소스들을 서버에서 한 요청(커넥션)에서 모두 다 보내줄 수 있다. 

1번의 요청에 4번의 응답 (정확히는 1번의 응답과 3번의 추가 push 이다.)

이게 바로 서버 푸시개념이다.

이 푸시 개념이 유익한 것은 '하나의 커넥션에서 병렬로 데이터를 수신' 할 수 있다는 점이 포인트이다, 이것만 기억하면 대부분 다 납득이 된다.

이걸 나는 pub / sub 처럼 생각하다보니, 요청 없이도 원하는 순간에 서버에서 push 해줄 수 있어야 하지 않나? 라는 생각에 사로잡혀서 삽질을 하고 있었다 -_-;

gRPC 를 보면.. onNext(){...}; 가 push 를 해주는 메소드이고(http2 spec 상에서 최대 100번까지 push 가 가능하다고 한다.), 마지막 onCompleted(){..} 에서  최종 응답 헤더(finish call)를 보내게 되면서, 커넥션이 닫히게 된다.

내가 했던 방법은 onNext 후에 onCompleted 를 여러번 호출해서 http1.1 에서 여러번 호출하는 것과 유사하게 처리한 것인데, 짧은 시간안에 여러번 호출하면 악의적인 행동으로 감지하고 자동으로 에러가 나는 것 이다. -_-;

그렇다면 gRPC 에서 pub / sub 모델처럼 client 와 server 사이에 원활하게 불특정 시간에 메세지(데이터)를 밀어넣는 것은 불가능할까? 무조건 client 에서 server 에서 메세지(데이터) 를 달라는 식의 단방향 요청식으로 처리해야할까?

이에 대해 고민을 해봤는 데, 쉽게 생각해봤을 때는 결론적으로 가능하단 생각이 들었다.

client 에서 원하는 시점에서 server 에 메세지를 달라고 요청할 수 있는 것이 RPC 이다. 이걸 이용하면 가능하다. client 와 server 의 역활을 바꾸어서, server 에서 client 에게 메세지를 가져가라고 알리는 notification 을 호출 당할 메소드를 client 에 정의해주면 된다. 이렇게 되면 client 의 메소드는 2개가 정의될 것이고, 서버에서는 1개가 될 것이다. 

클라이언트에서는 ```receiveNotification(notification){..};```  과 ``` receiveMessage(message){...} ``` 2개와, 서버에서는 ``` sendMessage(request)  ``` 1개가 구성된다. 

어떻게 보면 pub / sub 의 아키텍처와 매우 흡사하다.

이 외에도 gRPC 에 있는 양방향 스트리밍이 위와 같은 아키텍처와 유사하게 동작하는 지를 살펴본다면 더욱 더 깔끔한 방법으로 원하는 기능을 만들 수 있겠단 생각이 들었다.

살펴본 결과.. 양방향 스트리밍은 단순히 한 커넥션에서 N 개의 Request 와 N 개의 Response 를 응답하는 형태이다. 즉, pub / sub 형태로 개발은 위에서 고안한 아이디어로 notifiaction 을 알려주는 client method 를 정의해줘야 한다.

왜이렇게 만든 것일까


[https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideServer.java](https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideServer.java)





```java

 @io.grpc.stub.annotations.RpcMethod(
      fullMethodName = SERVICE_NAME + '/' + "serverToClientStream",
      requestType = com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest.class,
      responseType = com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse.class,
      methodType = io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)
  public static io.grpc.MethodDescriptor<com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest,
      com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse> getServerToClientStreamMethod() {
    io.grpc.MethodDescriptor<com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest, com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse> getServerToClientStreamMethod;
    if ((getServerToClientStreamMethod = SImpleServiceGrpc.getServerToClientStreamMethod) == null) {
      synchronized (SImpleServiceGrpc.class) {
        if ((getServerToClientStreamMethod = SImpleServiceGrpc.getServerToClientStreamMethod) == null) {
          SImpleServiceGrpc.getServerToClientStreamMethod = getServerToClientStreamMethod = 
              io.grpc.MethodDescriptor.<com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest, com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse>newBuilder()


              .setType(io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)



              .setFullMethodName(generateFullMethodName(
                  "com.glqdlt.ex.grpcexam.model.SImpleService", "serverToClientStream"))
              .setSampledToLocalTracing(true)
              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
                  com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest.getDefaultInstance()))
              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
                  com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse.getDefaultInstance()))
                  .setSchemaDescriptor(new SImpleServiceMethodDescriptorSupplier("serverToClientStream"))
                  .build();
          }
        }
     }
     return getServerToClientStreamMethod;
  }






  @io.grpc.stub.annotations.RpcMethod(
      fullMethodName = SERVICE_NAME + '/' + "serverToClient",
      requestType = com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest.class,
      responseType = com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse.class,
      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)
  public static io.grpc.MethodDescriptor<com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest,
      com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse> getServerToClientMethod() {
    io.grpc.MethodDescriptor<com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest, com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse> getServerToClientMethod;
    if ((getServerToClientMethod = SImpleServiceGrpc.getServerToClientMethod) == null) {
      synchronized (SImpleServiceGrpc.class) {
        if ((getServerToClientMethod = SImpleServiceGrpc.getServerToClientMethod) == null) {
          SImpleServiceGrpc.getServerToClientMethod = getServerToClientMethod = 
              io.grpc.MethodDescriptor.<com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest, com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse>newBuilder()



              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)


              .setFullMethodName(generateFullMethodName(
                  "com.glqdlt.ex.grpcexam.model.SImpleService", "serverToClient"))
              .setSampledToLocalTracing(true)
              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
                  com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest.getDefaultInstance()))
              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
                  com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse.getDefaultInstance()))
                  .setSchemaDescriptor(new SImpleServiceMethodDescriptorSupplier("serverToClient"))
                  .build();
          }
        }
     }
     return getServerToClientMethod;
  }


```

https://b.luavis.kr/http2/http2-overall-operation

https://developers.google.com/web/fundamentals/performance/http2/?hl=ko



https://github.com/saturnism/grpc-java-by-example/tree/master/metadata-context-example/src/main/java/com/example/grpc