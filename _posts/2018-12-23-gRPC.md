---
layout: post
title:  "gRPC"
author: "glqdlt"
---


아래에서 설명하는 소스는 모두 [github repo](https://github.com/glqdlt/ex-grpc) 에 올렸다.


# ref

아래는 참고하기 좋은 유튜브 래퍼런스들.

- [공식 가이드](https://grpc.io/docs/tutorials/basic/java.html)

- [gRPC - Ray Rsang](https://youtu.be/xpmFhTMqWhc)

- [Java Hello World Tutorial](https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/helloworld/HelloWorldServer.java)



# gRPC


## What is gRPC?

gRPC 는 RPC(Remote Procedure Call)의 범주에 해당 하는 프레임워크로 구글에서 만들어졌음.

MSA(Micro Service Architecture) 가 보편화되면서 현재의 파편화 된 서비스 node 들 간의 restful api 통신을 효율이 더 좋으나 사용성이 어려운 RPC 를 보다 쉽게 사용할 수 있게 하고자 만들어짐. (농단 반 진담 반으로 Restful API 대비 효율이 3배 좋다고 함, [gRPC vs REST](https://www.slideshare.net/borisovalex/grpc-vs-rest-let-the-battle-begin-81800634))

<img src="https://grpc.io/img/landing-2.svg"/>

(사족으로, MSA 에서 node 들 간의 메세지 교환에는 메세지 솔루션(예: apache kafka)들과도 비교할 수 있지 않은가 하는 생각을 해봤는 데, 좀 더 생각을 해보니 메세지 솔루션은 pub/sub 개념이고 대상을 명확하게 호출하는 RPC 와는 설계와 개념에서 차이가 남 ([gRPC vs Kafka](https://www.quora.com/How-should-I-choose-between-gRPC-and-Kafka-when-building-microservices)))

gRPC 의 특징으로는 언어 제약이 없는 [protocol buffers](https://developers.google.com/protocol-buffers/docs/overview) 통한 직렬화 된 바이너리 메세지와 Http/2 기반의 프로토콜을 사용하여 양방형 스트리밍이 가능함. 

지원하는 언어는 [여기](https://grpc.io/docs/quickstart/)서 참고할 수 있음.

- C++
- C#
- [Dart](https://www.dartlang.org/) (모르는 분들이 많을텐데, Google 에서 만든 Typescript. JVM 기반 Javascript Transpile Lang)
- Go
- Java
- Android Java
- Node.js
- Objective-C
- PHP
- Python
- Ruby

자세한 것은 [Official Concept](https://grpc.io/docs/guides/index.html) 에서 확인 가능함.

## RPC ?

RPC(Remote Procedure Call)은 말 그대로 원격지에서 guest 가 host 의 function(method)를 호출하고 그 결과를 받아 같은 소스상에서 자연스럽게 흘러가는 flow 를 가지자는 개념.

RPC 는 매우 오래 전 부터 있던 개념으로 (개인적으로 저는 약 3년 전에 [Adobe Flex ~ Java SOAP](https://www.tutorialspoint.com/flex/flex_rpc_services.htm)를 경험해본게 최초였음 -_-a) 매우 획기적인 컨셉에 비해 사용성이 어려워서 많이 알려지지 않음. 

어렵다는 이유는 원격지에서 호출한다는 개념 자체가 네트워킹으로 이루어진다는 것이고, Guest 와 Host 가 동일하게 협약된 구조를 가져야 한다는 전제 떄문에 사용성과 관리가 어려움.

RPC에는 대표적으로 

- CORBA
- SOAP
- Java RMI
- Microsoft RPC
- ODBC
- Apache Thrift

등이 있음.

최근에는 Thrift 가 소셜 네트워킹 기업들에서 사랑받으면서 많이들 사용하는 추세였음.


## gRPC architecture


<img src="https://image.slidesharecdn.com/grpctalk1-160507200742/95/grpc-overview-17-638.jpg?cb=1462651696">

출처 [gRPC Overview](https://www.slideshare.net/VarunTalwar4/grpc-overview)

gRPC 는 위 도식화에서도 알 수 있듯 총 3계층 구조로 되어있다.

Application Layer 에서는 .proto 파일을 정의해서 Proto Buffer를 통해 구현체들을 generated 한다. 이 generated 된 산출물들은(자바의 경우 .class) gRPC Core 를 통해 Http 2 구현 Server 들 위에 올라가게 되는 데, 이 과정의 제어와 서포트는 gRPC Core 에서 담당하는 구조이다.


# getting start

자바로 먹고 살고 있기에 당연히 예제 소스는 자바 기반 입니다. (추후 NodeJs 기반 Client 정도 작성 할지도 -_-;)

설명하는 모든 소스는 [github repo](https://github.com/glqdlt/ex-grpc) 에서 확인할 수 있습니다.

## working flow

gRPC 기반 프로젝트 워킹 플로우를 수행하면 아래와 같음.


사전 준비 단계

0. (java) source project init

1. (수동으로 할 경우) proto buf compiler 설치 

    - [https://github.com/protocolbuffers/protobuf/releases](https://github.com/protocolbuffers/protobuf/releases)


2. (mvn install 으로 처리할 경우) maven or gradle plugin 설정

    - [https://github.com/grpc/grpc-java/blob/master/README.md](https://github.com/grpc/grpc-java/blob/master/README.md)

실제 업무 흐름

1. .proto 작성

2. proto buf generate(compile) : Build Pipeline Add

3. proto buf base class와 서비스 구현체와 연결(extends)

4. Server 의 경우 Server Run()

5. Client 의 경우 server remote method call()


### Example Project Structure


[예제 소스](https://github.com/glqdlt/ex-grpc) 의 구조는 3개의 모듈로 이루어진 멀티 모듈 구조로 만들었음.

```
grpc-exam
ㄴclient : host method 를 호출 할 client 에 해당
ㄴmodel : proto 파일이 위치함. client 와 server 에서는 이 model module 을 의존.
ㄴserver : server 에 해당

```

### model

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>grpc-exam</artifactId>
        <groupId>groupId</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.glqdlt.ex.grpc</groupId>
    <artifactId>model</artifactId>

    <properties>
        <java.version>1.8</java.version>
        <grpc.version>1.17.1</grpc.version>
        <protobuf.version>3.5.1</protobuf.version>
        <protoc.version>3.5.1-1</protoc.version>
        <netty.tcnative.version>2.0.7.Final</netty.tcnative.version>
    </properties>


    <dependencies>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>20.0</version>
        </dependency>

        <dependency>
            <groupId>kr.motd.maven</groupId>
            <artifactId>os-maven-plugin</artifactId>
            <version>1.5.0.Final</version>
        </dependency>

        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-testing</artifactId>
            <version>${grpc.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java-util</artifactId>
            <version>${protobuf.version}</version>
        </dependency>

        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-netty-shaded</artifactId>
            <version>${grpc.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-protobuf</artifactId>
            <version>${grpc.version}</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-stub</artifactId>
            <version>${grpc.version}</version>
        </dependency>
    </dependencies>


    <build>
    <!-- 아래 build plugin 에 ${os.detected.classifier} OS 정보를 넣어주기 위한 확장 플러그인 -->
        <extensions>
            <extension>
                <groupId>kr.motd.maven</groupId>
                <artifactId>os-maven-plugin</artifactId>
                <version>1.5.0.Final</version>
            </extension>
        </extensions>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            <!-- maven 의 compile 단계에서 .proto 를 generate 플러그인 -->
            <plugin>
                <groupId>org.xolstice.maven.plugins</groupId>
                <artifactId>protobuf-maven-plugin</artifactId>
                <version>0.5.1</version>
                <configuration>
                    <protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}</protocArtifact>
                    <pluginId>grpc-java</pluginId>
                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>compile</goal>
                            <goal>compile-custom</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>


        </plugins>
    </build>


</project>
```


#### User.proto

```proto
// proto 파일의 버전을 서술, 문법에 해당한다고 보면 됨.
syntax = "proto3";

// proto 가 빌드될 target package. 생략되면 classpath:/  에 빌드됨
package com.glqdlt.ex.grpc.client.model;

// java 의 그 enum 과 같음
enum Sex{
    MAN = 0;
    WOMAN = 1;
}

// host 에 위치하게 될 서비스 class 의 이름
service UserService {
    // 실제 호출 될 메소드의 인터페이스를 정의
    rpc getUserDetail (UserRequest) returns (UserDetail) {};
}

// message 키워드가 붙는 것은 Value Object 라고 보면 됨. 특이한 점은 필드의 순서를 정의한다는 점. 
message UserRequest {
    string id = 1;
}

message UserDetail {
    string id = 1;
    string name = 2;
    int32 age = 6;
    Sex sex = 4;
    string password = 3;
    string address = 5;
    repeated string hobbies = 7;
    map<string, string> auth = 8;
}
```