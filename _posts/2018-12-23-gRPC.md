---
layout: post
title:  "gRPC(작성 중)"
author: "glqdlt"
---

# intro

이 아티클은 사내 프로젝트에 gRPC 를 적용하기 위한 고민과 경험을 기록한 내용입니다.
아래에 서술 된 모든 소스는 https://github.com/glqdlt/ex-grpc 에서 확인 하실 수 있습니다.

gRPC 는 http2 를 기반으로 사용하는 RPC 프레임워크입니다. gRPC 를 사용한다는 것은 http2 에 대해서도 알아간다는 것을 의미하며, http2의 이해가 없으면 gRPC를 이해하기 어렵습니다. 때문에 이 아티클에서는 gRPC 외에도 http2 에 대한 이야기도 중간중간 짤막하게 다루어봅니다.

# gRPC

<img src="https://grpc.io/img/landing-2.svg"/>

## What is gRPC

gRPC 는 Google 에서 만든 RPC(Remote Procedure Call) 프레임워크 입니다. gRPC 는 이름만 봐도 유추되듯 단순하게 google + RPC 란 의미를 가지고 있습니다.

최근 Micro Service Architecture가 보편화 되고 서비스 node 간의 통신 성능이 화두 되면서 자주 사용 되던 Restful API 보다 효율이 더 좋은 RPC 를 쉽게 사용하자는 취지로 만들어졌습니다. 

gRPC 는 로드 밸런싱, 추적, 상태 확인 및 인증을위한 플러그 가능한 지원을 통해 데이터 센터에서 또는 서비스 전반에 효율적으로 연결할 수 있습니다. (또한 농단 반 섞인 이야기이지만 기존 Restful API 대비 효율이 3배 좋다고 -_-a ) 자세한 이야기는 [gRpc 성능 차트](https://cloud.google.com/blog/products/gcp/announcing-grpc-alpha-for-google-cloud-pubsub) 에서 확인해 볼 수 있습니다.


<img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/grpc-pub-sub1ty07.max-400x400.PNG"/>



### RPC?

RPC(Remote Procedure Call)는 의미 그대로 원격지에서 client(consumer) 가 server(provider) 의 기능을 직접 호출하고 결과를 return 받는 자연스러운 로직 flow를 가지자는 개념입니다.

RPC 는 오래 전 부터 있던 개념이었는 데, 매우 획기적인 컨셉에 비해 사용성이 어려워서 많이 알려지지 않았습니다.

원격지에서 호출한다는 개념 자체가 client(consumer) 와 server(provider) 간의 통신을 관리되야 함을 의미하고, 공통 된 인터페이스를 정의하고 공유해야 한다는 전제 때문에 사용성과 관리가 어려웠습니다.

대표적인 RPC 구현체는 아래와 같습니다.

- CORBA
- SOAP
- Java RMI
- Microsoft RPC
- ODBC
- Apache Thrift

(개인적으로는 처음 접한 RPC는 신입 시절에 [Adobe Flex <-> Java SOAP](https://www.tutorialspoint.com/flex/flex_rpc_services.htm)를 다루어 본 게 최초였습니다. xml 에 사용 될 메서들을 클래스와 패키지 주소까지 나열해줘야 했던 게 참 끔찍했었네요.. -_-) 




## gRPC의 특징

gRPC 의 큰 특징으로는 [protocol buffers](https://developers.google.com/protocol-buffers/docs/overview)의 사용으로 특정 언어 종속 없이 폴리그랏한(polyglot) 환경을 꾸릴 수 있다는 점과 http/2 프로토콜 기반의 양방형 스트리밍을 할 수 있다는 점이 있습니다.

아래는 [official gRPC about](https://grpc.io/about/)에서 얘기하는 gRPC의 특징입니다.

Core Features that make it awesome:

- Idiomatic client libraries in 10 languages (10개의 언어로 된 클라이언트 라이브러리)

- Highly efficient on wire and with a simple service definition framework (효율적으로 서비스 정의를 간편하게 할 수 있음)

- Bi-directional streaming with http/2 based transport (http2 기반의 양방향 스트리밍 지원)

- Pluggable auth, tracing, load balancing and health checking (인증, 추적, 로드밸런싱 그리고 허트비트 기능 지원)


### 프로토콜 버퍼

<img src="/images/grpc/pb.PNG"/>

프로토콜 버퍼는 Google 에서 만든 데이터(또는 객체)를 직렬화하기 위한 언어 중립적인 도구입니다. 프로토콜 버퍼는 폴리그랏 프로그래밍에 아주 적절한 프레임워크입니다. proto 파일을 정의하여 언어 불문하고 다양한 언어로 컴파일 할 수 있습니다. 
(여기서 폴리그랏(polyglot) 이란 다각화 된 프로그래밍 언어를 의미를 가집니다.)

프로토콜 버퍼는 현재 대략 10개의 언어를 지원하고 있으며, 이는 gRPC 에서도 10개의 언어를 지원하다는 것과 같다는 의미를 가집니다.

- C++
- C#
- [Dart](https://www.dartlang.org/) (클라이언트 플랫폼을 위한 JVM 기반의 Transpile 언어. 모바일 기기와 브라우저 위에서 동작함. 일종의 Google 에서 만든 Typescript라 생각하면 쉽습니다.)
- Go
- Java & Android
- Node.js (공식적으로는 프론트엔드는 아직 미지원이지만 3rdpary 라이브러리로 [grpc-web](https://github.com/improbable-eng/grpc-web)가 존재합니다.)
- PHP
- Python
- Ruby

### 프로토콜 버퍼의 문법

gRPC를 통한 개발을 진행하면 가장 첫번째로 마주치는 것으로 프로토콜 버퍼를 정의하는 데에서 부터 시작합니다. 정의 된 proto 파일은 프로토콜 버퍼 컴파일러를 통해 메세징에 사용 될 Model 과 base service code(gRPC 에서만 지원)로 컴파일 됩니다.

기본적인 프로토콜 버퍼 문법은 아래와 같습니다.

```proto
message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}
```

enum 과 같은 열거형 상수 타입도 지원하며, repeated 키워드를 통해 배열도 선언할 수 있습니다. 프로토콜 버퍼는 기본적으로 [빌더 패턴](https://ko.wikipedia.org/wiki/%EB%B9%8C%EB%8D%94_%ED%8C%A8%ED%84%B4)을 사용하기에 required 와 optional 과 같은 객체 초기화에 꼭 필요한 필드를 강제화 하거나 선택적 옵션 필드로 선언할 수 있습니다.

여기에 gRPC 에서 사용되는 프로토콜 버퍼에서는 추가적으로 아래와 같 서비스 인터페이스를 정의할 수 있습니다.

```proto
enum Sex{
    MAN = 0;
    WOMAN = 1;
}

service UserService {
    rpc getUserDetail (UserRequest) returns (UserDetail) {};
}


message UserRequest {
    string id = 1;
}

message UserDetail {
    string id = 1;
    string name = 2;
    int32 age = 6;
    Sex sex = 4;
    string password = 3;
    string address = 5;
    repeated string hobbies = 7;
    map<string, string> auth = 8;
}

```

프로토콜 버퍼에 자세한 것은 [Official Protocol Buffers Develop Guide](https://developers.google.com/protocol-buffers/docs/overview?hl=ko) 를 참고해주세요.

### 스트리밍

gRPC 에서는 http2 프로토콜을 기반으로 동작합니다. http2 에는 기존 http1.1 과는 많이 진보된 구조를 가지기에 많은 차이가 있습니다.

대표적으로 기존 요청(reqeust)과 응답(response)을 확장판 '메세지(message)' 개념이 있고, 통신 단위인 '프레임(frame)'과 실제 메세징이 전송되는 파이프라인 인 '스트림(stream)'이 있습니다. 쉽게 기차를 예로 들면, 프레임은 기차의 열칸(1호, 2호)과 유사하며, 스트림은 기차에 해당하고, http2 는 철도라 이해 해볼 수 있습니다. (자세한 http2 에 대해서는 추가적인 아티클을 작성해서 다루어 보겠습니다. 자세한 것은 [http2  Official Blog](https://http2.github.io/)에서 참고하실 수 있습니다.)

<img src="https://developers.google.com/web/fundamentals/performance/http2/images/streams_messages_frames01.svg?hl=ko"/>

gRPC 에서 말하는 스트리밍이란 쉽게 말해서 http2 스트림을 사용한다는 의미입니다.

### http2 와 gRPC

gRPC 에서 사용 되는 http2 는 기존 http1.1 과 개념은 같지만, 매카니즘이 많이 다릅니다. http2 는 기존 http1.1 의 병렬 처리를 위한 다중 소켓을 사용하던 것과 다르게 단일 소켓만 사용합니다. http2는 병렬 처리를 위한 개념으로 스트림을 도입했습니다.  

http2 에서는 http1.1 과 달리 패킷 헤더 압축을 위해 기본적으로 peer 간의 지속적인 옅은 state를 가지게 됩니다. 다만 기존 http1.1과 유사하게 메세지(요청과 응답)이 필요할 때마다 새로운 스트림을 열어서 통신을 하는 구조를 가지고 있습니다. ([Http2 Why just one TCP connection?](https://http2.github.io/faq/#why-just-one-tcp-connection))

(메세지는 http1.1 에서는 1개의 요청과 1개의 응답이었던 반면, http2 에서는 N개의 요청과 N개의 응답을 보낼 수 있습니다.) 스트림을 새로 여는 비용은 기존 http1.1 의 다중 소켓(4~8개 정도)을 사용하는 것에 비하여 매우 효율적입니다.

이런 의미로 http2는 http1.1 을 대체하지 않은 새로운 규격이지만(stateless 하지 않음으로), 기존 http 처럼 요청과 응답이 있으며, 요청이 있을 때에만 통신 비용이 발생 하게 되는 http 의 사상을 깨지 않은(또는 물려 받은) 프로토콜입니다.

실제로 [http2 frc](https://tools.ietf.org/html/rfc7540) 의 도입 부분을 보면 아래와 같은 말이 나오는 데, 위의 내용을 대입해보면 어떠한 의미를 가지는 지를 알 수 있습니다.

> This specification is an alternative to, but does not obsolete, the
   HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.

> http2는 http1.1을 대안으로 하지 않으며, 기존 http의 의미를 깨지 않는다.

이런 http2의 특징은 gRPC 에서도 그대로 똑같이 적용 됩니다. 즉, gRPC의 peer 간의 커넥션은 지속적으로 맺고 있지만, RPC 사용(메세지 요청)이 있을 때에만 통신(리소스의 사용) 비용이 발생하게 됩니다.


## gRPC 구조


<img src="https://image.slidesharecdn.com/grpctalk1-160507200742/95/grpc-overview-17-638.jpg?cb=1462651696">

출처 : [gRPC Overview](https://www.slideshare.net/VarunTalwar4/grpc-overview)

gRPC 는 총 3개의 계층 구조를 가집니다.

Application Layer 에서는 정의 된 .proto 파일을 기반으로 Proto Buffer 에서 어플리케이션에 적용할 구현체(자바의 class)를 생성 하는 기능을 수행하고, 생성 된 구현체들은 gRPC Core 를 통해 Http 2 위에서 통신하게 되는 구조입니다.

참고로 gRPC 에서 같은 infra 환경 내의 서비스 노드 간의 커넥션은 최초 요청후 channel.terminate 요청 전까지는 계속 channel 이 서버에 커넥션 됩니다.

## gRPC 와 서블릿

gRPC 는 Http 2 기반이기에, http2 를 포함하는 Servlet4 구현체 중 하나인 tomcat 9 버전에서 쉽게 동작할 수 있지 않을까 생각을 했봤는 데, gRPC 에서 서블릿은 미지원이라는 것을 알게 되었습니다. (netty 프레임워크 나 okHttp 는 지원)

궁금해서 구글링을 통해 찾아보다가 [관련 토픽](https://github.com/grpc/grpc-java/issues/1621)에서 여러 이유를 알게 되었는 데,
 gRPC 는 http2의 모든 소켓을 완전히 제어할 수 있어야 한다는 전제가 필요 한것으로 보입니다.(이 완전 제어에 대해서는 좀 더 탐구해봐야할 거 같네요.) 서블릿은 이에 적합하지 않은 구조를 가지고 있어서 지원이 불가능하다는 것인데 그래도 영 불가능한 것은 아닌지, 몇몇 스레드를 보면 wildfly(jboss 의 오픈소스 버전)를 기반으로 시도한 흥미로운 사례도 있어 향후 어떻게 발전할지는 모르겠습니다. -_-a

정리를 하면 웹 프로젝트에 있어서는 서블릿 컨테이너의 http2 통신을 이용해서 gRPC 를 동작시키는 것은 불가능하고, 서블릿 컨테이너 위에서 okHttp 나 netty 등의 http2 구현체를 애드온 하는 형태로 개발 해야한다는 것을 의미합니다.



# Getting start

공식 가이드에 있는 예제를 통해 gRPC 를 살짝 맛 봤습니다.
당연한 이야기이지만, 자바로 먹고 살고 있기에 예제 소스는 자바와 메이븐 기반입니다. (추후 NodeJs 기반 Client 정도 작성 할지도 모르겠네요.)

## Working flow

gRPC 기반 프로젝트 워킹 플로우를 나열하면 아래와 같습니다.


1. .proto 정의

2. proto compile

    컴파일 방법은 아래 2가지 중 택 1

    1. (자동) [proto buffer generate plugin](https://github.com/xolstice/protobuf-maven-plugin) : 메이븐 빌드 커맨드에 애드온

        또는

    2. (수동) [proto buffer compiler](https://github.com/protocolbuffers/protobuf/releases) 를 직접 실행시켜 생성

3. compile 된 base source 와 어플리케이션 로직과의 연결

4. Server : Server Run()

5. Client : server remote method call()


## 단일 gRPC

gRPC 에서는 일반적인 RPC 형태인 단일의 단일 call 의 형태도 지원하고, 단일이지만 stream 자체를 전달받아 calls 를 호출 받는 형태도 지원합니다. 이런 구조를 응용해서 양방향 stream 지원합니다.

여기서 스트림이란 무엇일까요? [https://grpc.io/docs/guides/concepts.html#overview](https://grpc.io/docs/guides/concepts.html#overview) 

기본적으로 둘 다 어떠한 데이터를 응답받을 것이라는 stub 을 기대하는 것은 맞습니다. 차이가 있다면, 단일 call 의 경우에는 데이터의 최종 complete() 콜 까지 server 에 위임하고 client 는 그 기간동안 기다리는 것을 의미합니다. 예를 들어서 설명해보겠습니다. server 의 로직은 1L 물통을 준비하고 물이 다 찰 때까지 물을 채우는 일을 하는 로직을 가지고 있다고 칩시다. 여기서 단방향 call 은 1L 물통에 1L의 물이 가득찰 때 까지 대기하게 됩니다. 반면 client 의 stream 자체를 받아서 callback으로 물통에 물이 찰 때마다 client 에 callback 을 호출해주는 형태의 경우에는 물이 물통에 들어갈때마다 client 에 알려주는 차이가 있습니다.

이 차이는 매우 큽니다. 예를 들어 1L 물통의 물을 모두 빨간색으로 물들여야야 한다면, 물통이 다 가득차고 난뒤에 빨갛게 물들이는 것보다, 물이 들어올 떄 마다 빨간색으로 처리켜주는 것이 더 빠르게 끝날 수 있습니다.(비유를 하면 그렇습니다.)

이러한 방법을 기존 http 1.1 에서 진행할 때에는, 물통에 물이 들어올 때 마다 client 가 물에 물통을 넣어달라고 요청을 했었습니다. 반면 http2 에서는 이러한 요청작업이 매번 마다 일어나는 것은 아니고, 물이 당연히 들어올 거라고 기대하게 되는 형태(물이 들어오면 callback)입니다.

기존 http 에서 설계적으로 모든 http 패킷은 한번의 request 와 한번의 response 가 쌍을 이루는 형태로 설계되었습니다. 이것이 restfull 로 바라보면 되는 데, 문제는 웹을 이루는 asset 들은 단순히 html 파일 하나만 있거나 하는 것이 아니라 여러가지 js 와 img, html 파일들로 이루어진 하나의 group 된 단위로 이루어진다는 문제가 있습니다. 이런 문제 때문에 서비스 규모가 큰 웹 서비스에서는 asset 들을 다 받기만 하는 데도 병렬처리를 못하여 최대 몇 분 까지의 asset 들을 받는 경직된 시간을 가지게 됩니다.

이를 해결하고자 여러 방법들이 있었는 데, 그것도 한계가 있었습니다. 가장 유망했던 방법 중에서는 한 커넥션 세션에서 같은 도메인 상에서 4~6 개의 추가적인 스트림을 열어 병렬 추가 request 를 보내던 꼼수에서, http2 에 들어서 최대 [100개](https://stackoverflow.com/questions/36835972/does-the-per-host-connection-limit-is-raised-with-http-2) 까지의 추가 스트림을 열어서 병렬로 처리할 수 있게 되면서 이를 해결하고자 처리하게 된 것 입니다.

최대 100개 까지 하게 된 마법은 아래와 같습니다.

1. 최초 커넥션을 맺으며 서버에 request 를 보내고, start http header 를 보냄

2. close http header 를 보내기 전 까지 필요한 경우 single request or multi request 를 보냄

3. close http header 가 오면 서버에서 응답할 차례

4. 서버에서는 이후로 최대 100개까지의 스트림을 열어 파일을 push 할 수 있음(http server push)

5. 이 마법이 가능해지는 것은, http2 스펙의 압축된 header 정보를 기반으로 request 가 여러번 온 것 과 같은 상황을 가정할 수 있기 때문

6. 압축된 http header 를 기반으로 server 에서 최대 100개까지의 여러 asset 들을 push 보냄 (순서는 의미 없음)

7. asset 들이 모두 보내졌다고 판단한 server는 complete() 콜사인을 client 로 보내면서 자신의 모든 stream 이 닫혔다는 것을 client 에 보낸다.

8. client 는 complete() 사인을 받고 그때서야 커넥션 세션을 닫게 된다.






이에 대한 것은 [이곳](https://b.luavis.kr/http2/http2-overall-operation) 에서 잘 정리한 글이 있어 자세한 설명은 대체하겠습니다.



### gRPC with stream

gRPC 에서는 단일 통신과 스트리밍 통신을 제공합니다. 단일은 하나의 메소드를 제공하고, 스트리밍 통신에서는 3가지 타입의 메소드들을 제공합니다.

메소드 타입들은 proto 파일을 통해 base code가 생성될 때, stream 키워드가 있느냐 없느냐? 있다면 선언이 어디에 되어있느냐(Argument 또는 return)에 따라 어떻게 통신 할 지가 결정이 됩니다.

https://grpc.io/docs/guides/concepts.html#service-definition





#### Method Types

- UNARY : 단일
    
    1커넥션에서 1건의 요청과 이 요청에 답하는 1건의 응답이 있습니다.

    request <-> response

    proto syntax:

    ```rpc clientSideStream(stream SimpleRequest) returns (SimpleResponse);```

- CLIENT_STREAMING : 클라이언트 스트리밍

    1커넥션에서 0건 이상의 요청에 이 요청에 답하는 1건의 응답이 있습니다.

    request <|->>>>> response
    
    proto syntax:

    ```rpc serverSideStream(SimpleRequest) returns (stream SimpleResponse);```

- SERVER_STREAMING : 서버 스트리밍

    1커넥션에서 1개의 요청에 0개 이상의 응답이 있습니다.

    request <<<<<-> response

    proto syntax:

    ```rpc simpleServerToClient(SimpleRequest) returns (SimpleResponse);```

- BIDI_STREAMING : 양방향 스트리밍

    1커넥션에서 0개 이상의 응답과 요청이 있습니다.

    reqeust <<<<->>>> response

    proto syntax:

    ```rpc bidirectionalStream(stream SimpleRequest) returns (stream SimpleResponse);}```

메소드 타입에 대한 내용은 (JAVA 소스 기준) [MethodType Enum 자바 API 문서](https://grpc.io/grpc-java/javadoc/io/grpc/MethodDescriptor.MethodType.html) 에서도 자세한 설명을 얻을 수 있습니다.


클라이언트 소스 상에서 아래와 같이 호출 되는 시점을 인젝션하는 인터셉터를 등록해서 실제 해당 호출이 어떠한 Method Type 인지를 출력해 볼 수도 있습니다.

```java

public class ClientApplication {
public static void main(String[] args) {
        ManagedChannel channel = ManagedChannelBuilder

                ...

                .intercept(new SimpleHookClientInterceptor())
                .build();

    ...

}

public class SimpleHookClientInterceptor implements ClientInterceptor {
    private final static Logger logger = LoggerFactory.getLogger(SimpleHookClientInterceptor.class);

    @Override
    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {
        logger.info("method : {}, callOpt : {}, next : {}", method.getType(), callOptions.getCredentials(), next.authority());
        return next.newCall(method, callOptions);
    }
}


```

<img src="/images/grpc/method_types.PNG"/>

### Example Project Structure


[예제 소스](https://github.com/glqdlt/ex-grpc) 의 구조는 3개의 모듈로 이루어진 멀티 모듈 구조입니다.

각 모듈은 아래와 같습니다.

```
grpc-exam
ㄴclient : host method 를 호출 할 client 에 해당
ㄴmodel : proto 파일이 위치함. client 와 server 에서는 이 model module 을 의존.
ㄴserver : host method 를 제공 할 server 에 해당

```

### Model module source

model module source 에는 단순히 proto buffer 에 대한 정의를 하는 모듈입니다, 어떻게 보면 핵심이라고도 볼 수 있습니다. 

이 모듈에는 proto 의 정의와 이를 build 하기 위한 maven plugin 가 정의 됩니다.

아래는 model module 의 메이븐 설정.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>com.glqdlt.ex.grpc</groupId>
        <artifactId>grpc-exam</artifactId>
        <version>1.1</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.glqdlt.ex.grpc</groupId>
    <artifactId>model</artifactId>
    <version>1.0-SNAPSHOT</version>


    <properties>
        <java.version>1.8</java.version>
        <grpc.version>1.17.1</grpc.version>
        <protobuf.version>3.5.1</protobuf.version>
        <protoc.version>3.5.1-1</protoc.version>
        <netty.tcnative.version>2.0.7.Final</netty.tcnative.version>
    </properties>


    <dependencies>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>20.0</version>
        </dependency>

        <dependency>
            <groupId>kr.motd.maven</groupId>
            <artifactId>os-maven-plugin</artifactId>
            <version>1.5.0.Final</version>
        </dependency>

        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-testing</artifactId>
            <version>${grpc.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java-util</artifactId>
            <version>${protobuf.version}</version>
        </dependency>

        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-netty-shaded</artifactId>
            <version>${grpc.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-protobuf</artifactId>
            <version>${grpc.version}</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-stub</artifactId>
            <version>${grpc.version}</version>
        </dependency>
    </dependencies>


    <build>
    <!-- 아래 build plugin 에 ${os.detected.classifier} OS 정보를 넣어주기 위한 확장 플러그인 -->
        <extensions>
            <extension>
                <groupId>kr.motd.maven</groupId>
                <artifactId>os-maven-plugin</artifactId>
                <version>1.5.0.Final</version>
            </extension>
        </extensions>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            <!-- maven 의 compile 단계에서 .proto 를 generate 플러그인 -->
            <plugin>
                <groupId>org.xolstice.maven.plugins</groupId>
                <artifactId>protobuf-maven-plugin</artifactId>
                <version>0.5.1</version>
                <configuration>
                    <protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}</protocArtifact>
                    <pluginId>grpc-java</pluginId>
                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>compile</goal>
                            <goal>compile-custom</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>


        </plugins>
    </build>


</project>
```


#### User.proto

.proto 는 proto buffer 의 syntax 로 작성됩니다. 일반적인 객체 class 문법과 비슷합니다. 

```proto
// proto 파일의 버전을 서술, 문법에 해당한다고 보면 됨.
syntax = "proto3";

// proto 가 빌드될 target package. 생략되면 classpath:/ 루트에 빌드됨
package com.glqdlt.ex.grpc.client.model;

// java 의 enum 과 같음
enum Sex{
    MAN = 0;
    WOMAN = 1;
}

// host 에 위치하게 될 서비스 class 의 이름
service UserService {
    // 실제 호출 될 메소드의 인터페이스를 정의
    rpc getUserDetail (UserRequest) returns (UserDetail) {};
}

// message 키워드가 붙는 것은 Value Object 라고 보면 됨. 특이한 점은 필드의 순서를 정의한다는 점. 
// 또한 message 들은 빌더 패턴으로 생성됨.
message UserRequest {
    string id = 1;
}

message UserDetail {
    string id = 1;
    string name = 2;
    int32 age = 6;
    Sex sex = 4;
    string password = 3;
    string address = 5;
    repeated string hobbies = 7;
    map<string, string> auth = 8;
}
```

model module 를 빌드 하게 되면 아래와 같이 User.proto 가 class 파일로 컴파일 된 것을 알 수가 있습니다.

물론, class 외에도 java 소스 원본도 존재합니다. generated sources 폴더에 가면 원본 .java 파일이 생성 되어 있음을 알 수 있습니다.

<img src ="/images/grpc/model_generated.PNG">



### Server module source

server module 에서는 실제 원격 호출 될 로직이 존재하는 곳으로서 model module 에서 생성 된 구현체 들을 base 삼아서 로직을 작성하는 것이 핵심.

아래는 server module 의 메이븐 설정
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.1.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.glqdlt.ex.grpc</groupId>
	<artifactId>server</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>server</name>
	<description>Demo project for Spring Boot</description>

	<properties>
		<java.version>1.8</java.version>
		<grpc.version>1.17.1</grpc.version><!-- CURRENT_GRPC_VERSION -->
		<protobuf.version>3.5.1</protobuf.version>
		<protoc.version>3.5.1-1</protoc.version>
		<netty.tcnative.version>2.0.7.Final</netty.tcnative.version>
	</properties>

	<dependencies>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>

		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
        <!-- model module 을 의존 -->
		<dependency>
			<groupId>com.glqdlt.ex.grpc</groupId>
			<artifactId>model</artifactId>
			<version>1.0-SNAPSHOT</version>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>

		</plugins>
	</build>

</project>


```

proto 파일에서 생성 된 클래스를 base로 한 UserService 구현체
```java
package com.glqdlt.ex.grpcexam;

// model 모듈의 .proto 에서 생성된 소스들을 import
import com.glqdlt.ex.grpcexam.model.User;
import com.glqdlt.ex.grpcexam.model.UserServiceGrpc;
import io.grpc.stub.StreamObserver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
public class UserServiceGrpcImplement extends UserServiceGrpc.UserServiceImplBase {
    private final Logger logger = LoggerFactory.getLogger(UserServiceGrpcImplement.class);

    private static final String SOME_USER_ID = "glqdlt";

    private User.UserDetail generateUserDetail() {
        return User.UserDetail.newBuilder()
                .setId(SOME_USER_ID)
                .setAddress("Seoul")
                .setAge(20)
                .setName("Jhun")
                .setPassword("12345")
                .setSex(User.Sex.MAN)
                .addHobbies("Coding")
                .addHobbies("Walking")
                .putAuth("role", "admin")
                .build();
    }
    

    @Override
    public void getUserDetail(User.UserRequest request, StreamObserver<User.UserDetail> responseObserver) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Optional<String> req = Optional.ofNullable(request.getId());
        logger.info("Get Request : {}",req.orElse("Null?"));
        if (req.isPresent()) {
            if (req.get().toUpperCase().equals(SOME_USER_ID.toUpperCase())) {
                responseObserver.onNext(generateUserDetail());
                responseObserver.onCompleted();
            }
        } else {
            responseObserver.onError(new RuntimeException("Bad Wrong Request..!"));
        }
    }
}

```


GrpcServer.java
```java
package com.glqdlt.ex.grpcexam;

import io.grpc.Server;
import io.grpc.ServerBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.IOException;


@Component
public class GrpcServer {

    private final Logger logger = LoggerFactory.getLogger(GrpcServer.class);

    private static final String prop = "grpc.server.port";

    @Value("${grpc.server.port}")
    private Integer port;

    @Autowired
    private UserServiceGrpcImplement userServiceGrpcImplement;

    private Server server;

    public void start() throws IOException, InterruptedException {
        if (port == null || port == 0) {
            logger.error("gRpc Server Port is Not SetUp..! '{}' need check!", prop);
            System.exit(-1);
        }
        server = ServerBuilder.forPort(port)
                .addService(userServiceGrpcImplement)
                .build();
        server.start();
        logger.info("gRPC Server  Started! Port : {} ", server.getPort());
        Runtime.getRuntime().addShutdownHook(new Thread(GrpcServer.this::stop));
        server.awaitTermination();
    }

    private void stop() {
        server.shutdown();
    }

}

```

### Client module source

gRPC 의 Client 에서 중요한 개념은 stub 이라는 개념이 중요합니다. TEST 를 하다 보면 마주치는 stub 이라는 용어와도 비슷합니다. TEST 에서의 stub 은 canned answer 의 의미를 갖는 개념으로, canned answer는 정해진 대답이란 의미를 갖습니다. 

예를 들어보면 단어 외우기 시험과 비슷합니다. 출제 될 특정 단어들을 기재하고 실제 문제에서 해당 문제의 뜻을 작성하는 시험과 비슷하게 어떠한 것을 사전에 약속하고 질의응답을 하는 개념이죠.([Test Stub 이란 무엇인가](https://medium.com/@SlackBeck/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%85%81-test-stub-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-ff9c8840c1b0))

gRPC에서의 Stub도 위와 비슷한 의미를 가지며, 기대하는 응답에 대한 반응을 작성하는 걸 의미합니다. 그래서 실제 코드 블록을 보면 client 와 server간의 커뮤니케이션이 성공했을 때와 실패했을 때를 정의하는 것을 알 수 있습니다.([Stub Wiki](https://en.wikipedia.org/wiki/Stub_(distributed_computing))[Stub vs Mock](https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da))



```java

package com.glqdlt.ex.grpc.client;

import com.glqdlt.ex.grpcexam.model.User;
import com.glqdlt.ex.grpcexam.model.UserServiceGrpc;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.stub.StreamObserver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

@SpringBootApplication
public class ClientApplication implements CommandLineRunner {

    private static final String REQUEST_ID = "glqdlt";

    @Value("${grpc.server.port}")
    private Integer port;

    private final Logger logger = LoggerFactory.getLogger(ClientApplication.class);

    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
    }

    private void callBack(User.UserDetail userDetail) {
        logger.info("Received! Response : {}", userDetail);
    }

    @Override
    public void run(String... args) throws Exception {
        ManagedChannel channel = ManagedChannelBuilder
                .forAddress("localhost", port)
                .usePlaintext()
                .build();
        User.UserRequest req = User.UserRequest.newBuilder().setId(REQUEST_ID).build();

        UserServiceGrpc.UserServiceStub serverResponse = UserServiceGrpc.newStub(channel);
        serverResponse.getUserDetail(req, new StreamObserver<User.UserDetail>() {
            // 서버에서의 응답이 있을 때마다 호출되는 메소드.
            // onNext 는 서버에서 여러번 보낼 수 있다는 점을 유의
            @Override
            public void onNext(User.UserDetail userDetail) {
                callBack(userDetail);
            }

            // error 캐치
            @Override
            public void onError(Throwable throwable) {
                logger.error(throwable.getMessage(), throwable);
            }

            // 서버에서 finish 콜이 왔을 때 호출되는 메소드.
            @Override
            public void onCompleted() {
                logger.info("Done!");
            }
        });

        // 아래는 단순히 0~50번 까지 숫자를 찍는 스트림
        IntStream.rangeClosed(0, 50).forEach(x -> {
            try {
                logger.info("is Done ?  .. : {}", x);
                Thread.sleep(50);
            } catch (InterruptedException e) {
                logger.error(e.getMessage(), e);
            }
        });
        channel.awaitTermination(5, TimeUnit.SECONDS);
        logger.info("Channel Terminated");
    }

}


gRPC 는 총 3가지의 stub을 제공합니다. 기본적으로 동기/비동기로 구분되어 있으며, 동기 객체인 BlockingStub 을 제공하는 ```Grpc.newBrockingStub()```, 비동기로 finishCall 이 올때에 callback을 받는 FutreStub을 제공하는 ```Grpc.newFutureStub()```, stream을 세세하게 정의할 수 있는 ```Grpc.newStub()``` 정적 메소드 들로 구분이 됩니다.



- newBlockingStub() 
    
    동기 방식으로 구성 된 BlockingStub 입니다. 단방향으로 처리 되며, 서버에서의 응답 값이 오면 해당 응답값을 받는 동안 로직은 블록킹 되고, 응답이 오면 연결을 끊습니다.
    
    
- newFutureStub()

    비동기 async 메소드 이지만, Future 를 응답한다는 점에서 차이가 있음. Future를 직접 핸들링 해서 응답이 오기 까지 잠시 선행 작업을 처리하고 future.get()에 실제 응답이 오기까지 blocking 하고 싶을 경우 사용성이 더 적합함.


- newStub() 

    스트림을 세세히 정의 할 수 있는 stub 입니다. 


동기와 비동기의 차이는 아래 다이어그램으로 설명합니다.

##### 동기
<img src ="/images/grpc/sync.png"/>


##### 비동기
<img src="/images/grpc/async.png"/>





아래는 client module 의 메이븐 설정

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.1.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.glqdlt.ex.grpc</groupId>
    <artifactId>client</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>client</name>
    <description>Demo project for Spring Boot</description>

    <properties>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency><dependency>
        <!-- server module 과 마찬가지로 model module 을 의존 -->
        <groupId>com.glqdlt.ex.grpc</groupId>
        <artifactId>model</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

# grpc-spring-boot-starter

위에서는 환경설정을 포함해서 여러가지 부수적인 것을 직접 설정했다면, [grpc-spring-boot-starter](https://github.com/LogNet/grpc-spring-boot-starter)와 같은 스프링 부트 플러그인 형태의 모듈 프로젝트가 있다. 이 라이브러리를 사용하면 보다 쉽게 gRPC 를 사용할 수 있다.

예를 들면 아래와 같다.

아래와 같은 proto 파일이 있다고 가정하고,
```proto
service Greeter {
    rpc SayHello ( HelloRequest) returns (  HelloReply) {}
}
```

이를 상속 받은 구현체를 gRPC 코어에 등록하는 것은 아래와 같다.
간단히 어노테이션 기반으로 등록할 수 있고, 인터셉터도 어노테이션의 옵션으로 등록하여 처리할 수 있다.

```java
@GRpcService(interceptors = { LogInterceptor.class })
public  class GreeterService extends  GreeterGrpc.GreeterImplBase{
    // ommited
}
```

더 자세한 것은 [Official ReadMe](https://github.com/LogNet/grpc-spring-boot-starter) 읽어보길 바람.

# next step

- [Authentication](https://grpc.io/docs/guides/auth.html#java) : 이번 예제에는 보안을 고려안한 plainText() 로 접근만 했기에 보안 레이어가 적용된 것에 대한 탐구가 필요

- 양방향 스트리밍 

- [Loadbalacing](https://grpc.io/blog/loadbalancing) : gRPC 와 로드밸런싱

- [gRPC Web Frontend](https://github.com/improbable-eng/grpc-web) : 서드파티에서 구현한 gRPC 웹 프론트엔드의 탐구.

# ref

아래는 참고헀던 레퍼런스

- [공식 가이드](https://grpc.io/docs/tutorials/basic/java.html)

- [잘 정리된 블로그](https://medium.com/@goinhacker/microservices-with-grpc-d504133d191d)

- [gRPC - Ray Rsang](https://youtu.be/xpmFhTMqWhc)

- [Java Hello World Tutorial](https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/helloworld/HelloWorldServer.java)


- [https://github.com/saturnism/grpc-java-by-example](https://github.com/saturnism/grpc-java-by-example)


## Bidirectional Streaming(양방향 스트리밍)

[https://github.com/nddipiazza/grpc-java-bidirectional-streaming-example/blob/master/src/main/java/GrpcExampleClient.java](https://github.com/nddipiazza/grpc-java-bidirectional-streaming-example/blob/master/src/main/java/GrpcExampleClient.java)



[https://www.programcreek.com/java-api-examples/?api=io.grpc.stub.StreamObserver](https://www.programcreek.com/java-api-examples/?api=io.grpc.stub.StreamObserver)

[https://github.com/grpc/grpc-java/tree/master/examples](https://github.com/grpc/grpc-java/tree/master/examples)

[https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideClient.java](https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideClient.java)


[https://developers.google.com/web/fundamentals/performance/http2/?hl=ko#_8](https://developers.google.com/web/fundamentals/performance/http2/?hl=ko#_8)


## http2 와 서버 푸시(server push promise) 에 대한 단상

서버 푸시가 pub / sub 랑 동일한 개념이라고 생각을 했다. 이게 무슨 말이냐면, pub / sub 개념에서는 push 를 받고자 하는 client 가 server 에 구독 (subscribe)을 하며 push 가 올 것을 생각하고 있게 되고, server 에서는 푸시 조건이 트리거 되면 메세지를 구독자들에게 push 해주는 개념이다. 즉 요청이 없이 일방적으로도 push 를 할 수 있다.

나는 http2 의 서버푸시도 이와 같은 것이 아닌가 생각했다. 구글링을 해보면 많은 이들이 나와 똑같이 'http2 server push vs websocket' 이란 키워드로 검색이 많이 된다. websocket 은 브라우저와 웹 서버 간의 pub / sub 아키텍처 로 된 프로토콜이다. 즉 서버 푸시를 pub / sub 으로 오해하면 당연히 web socket 과 http2 서버 푸시를 비교하게 된다.

얘기가 많이 샜는 데, 말하고 싶은 바는 http2 에서의 서버 푸시는 pub / sub 와 달랐다. 이게 무슨 소리냐면 http 2 에서의 server push 는 pub /sub 처럼 일방적으로 푸시 하는 게 아니라, client의 단일 요청에서 여러가지 응답을 보낼수 있다는 것이다. 그리고 이 요청은 keep alive 에 의해 오래 유지될 뿐이고, 영원히 유지되지는 않는다. 아직 학습이 덜 되어서 개인적으로는 개선된 keep alive 로 생각하고 있다.

이걸 기존 http 1.1 과 비교를 해보면 쉽게 이해할 수 있다. 기존 http 1.1 에서는 server에서 특정 리소스와 데이터를 여러번 보내려면  req <-> server 요청과 응답이 4번 있어야 했다. 예를 들어서 아래와 같은 4개의 웹 리소스가 있다고 가정하자.

```
index.html
app.js
app.png
style.css
```

이 경우 http 1.1 은 아래와 같이 된다.

1. index.html 요청, 서버에서  index.html 응답

2. app.js 요청, 서버에서 app.js 응답

...

4. style.css 요청, 서버에서 style.css 응답

즉, 총 4번의 요청과 4번의 응답이 있다. 단순하게 서버에서 여러번 보내주면 되잖아? 로 생각할 수 있는 데.. 서버에서는 응답할 수 있는 건 1종류의 데이터타입으로 1건의 응답할 수 있다. 무조건이다, can 이 아니라 must -_-; 그래서 불가능했다.

반면 http 2 에서는

1. index.html 요청, 서버에서 index.html 응답

2. 서버에서 추가적으로 app.js , app.png , style.css 를 응답

최초의 요청에서 index.html 에 관련 된 모든 리소스들을 서버에서 한 요청(커넥션)에서 모두 다 보내줄 수 있다. 

1번의 요청에 4번의 응답 (정확히는 1번의 응답과 3번의 추가 push 이다.)

이게 바로 서버 푸시개념이다.

이 푸시 개념이 유익한 것은 '하나의 커넥션에서 병렬로 데이터를 수신' 할 수 있다는 점이 포인트이다, 이것만 기억하면 대부분 다 납득이 된다.

이걸 나는 pub / sub 처럼 생각하다보니, 요청 없이도 원하는 순간에 서버에서 push 해줄 수 있어야 하지 않나? 라는 생각에 사로잡혀서 삽질을 하고 있었다 -_-;

gRPC 를 보면.. onNext(){...}; 가 push 를 해주는 메소드이고(http2 spec 상에서 최대 100번까지 push 가 가능하다고 한다.), 마지막 onCompleted(){..} 에서  최종 응답 헤더(finish call)를 보내게 되면서, 커넥션이 닫히게 된다.

내가 했던 방법은 onNext 후에 onCompleted 를 여러번 호출해서 http1.1 에서 여러번 호출하는 것과 유사하게 처리한 것인데, 짧은 시간안에 여러번 호출하면 악의적인 행동으로 감지하고 자동으로 에러가 나는 것 이다. -_-;

그렇다면 gRPC 에서 pub / sub 모델처럼 client 와 server 사이에 원활하게 불특정 시간에 메세지(데이터)를 밀어넣는 것은 불가능할까? 무조건 client 에서 server 에서 메세지(데이터) 를 달라는 식의 단방향 요청식으로 처리해야할까?

이에 대해 고민을 해봤는 데, 쉽게 생각해봤을 때는 결론적으로 가능하단 생각이 들었다.

client 에서 원하는 시점에서 server 에 메세지를 달라고 요청할 수 있는 것이 RPC 이다. 이걸 이용하면 가능하다. client 와 server 의 역활을 바꾸어서, server 에서 client 에게 메세지를 가져가라고 알리는 notification 을 호출 당할 메소드를 client 에 정의해주면 된다. 이렇게 되면 client 의 메소드는 2개가 정의될 것이고, 서버에서는 1개가 될 것이다. 

클라이언트에서는 ```receiveNotification(notification){..};```  과 ``` receiveMessage(message){...} ``` 2개와, 서버에서는 ``` sendMessage(request)  ``` 1개가 구성된다. 

어떻게 보면 pub / sub 의 아키텍처와 매우 흡사하다.

이 외에도 gRPC 에 있는 양방향 스트리밍이 위와 같은 아키텍처와 유사하게 동작하는 지를 살펴본다면 더욱 더 깔끔한 방법으로 원하는 기능을 만들 수 있겠단 생각이 들었다.

살펴본 결과.. 양방향 스트리밍은 단순히 한 커넥션에서 N 개의 Request 와 N 개의 Response 를 응답하는 형태이다. 즉, pub / sub 형태로 개발은 위에서 고안한 아이디어로 notifiaction 을 알려주는 client method 를 정의해줘야 한다.

왜이렇게 만든 것일까


[https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideServer.java](https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideServer.java)





```java

 @io.grpc.stub.annotations.RpcMethod(
      fullMethodName = SERVICE_NAME + '/' + "serverToClientStream",
      requestType = com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest.class,
      responseType = com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse.class,
      methodType = io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)
  public static io.grpc.MethodDescriptor<com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest,
      com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse> getServerToClientStreamMethod() {
    io.grpc.MethodDescriptor<com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest, com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse> getServerToClientStreamMethod;
    if ((getServerToClientStreamMethod = SImpleServiceGrpc.getServerToClientStreamMethod) == null) {
      synchronized (SImpleServiceGrpc.class) {
        if ((getServerToClientStreamMethod = SImpleServiceGrpc.getServerToClientStreamMethod) == null) {
          SImpleServiceGrpc.getServerToClientStreamMethod = getServerToClientStreamMethod = 
              io.grpc.MethodDescriptor.<com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest, com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse>newBuilder()


              .setType(io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)



              .setFullMethodName(generateFullMethodName(
                  "com.glqdlt.ex.grpcexam.model.SImpleService", "serverToClientStream"))
              .setSampledToLocalTracing(true)
              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
                  com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest.getDefaultInstance()))
              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
                  com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse.getDefaultInstance()))
                  .setSchemaDescriptor(new SImpleServiceMethodDescriptorSupplier("serverToClientStream"))
                  .build();
          }
        }
     }
     return getServerToClientStreamMethod;
  }


  @io.grpc.stub.annotations.RpcMethod(
      fullMethodName = SERVICE_NAME + '/' + "serverToClient",
      requestType = com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest.class,
      responseType = com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse.class,
      methodType = io.grpc.MethodDescriptor.MethodType.UNARY)
  public static io.grpc.MethodDescriptor<com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest,
      com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse> getServerToClientMethod() {
    io.grpc.MethodDescriptor<com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest, com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse> getServerToClientMethod;
    if ((getServerToClientMethod = SImpleServiceGrpc.getServerToClientMethod) == null) {
      synchronized (SImpleServiceGrpc.class) {
        if ((getServerToClientMethod = SImpleServiceGrpc.getServerToClientMethod) == null) {
          SImpleServiceGrpc.getServerToClientMethod = getServerToClientMethod = 
              io.grpc.MethodDescriptor.<com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest, com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse>newBuilder()



              .setType(io.grpc.MethodDescriptor.MethodType.UNARY)


              .setFullMethodName(generateFullMethodName(
                  "com.glqdlt.ex.grpcexam.model.SImpleService", "serverToClient"))
              .setSampledToLocalTracing(true)
              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
                  com.glqdlt.ex.grpcexam.model.Simple.SimpleRequest.getDefaultInstance()))
              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
                  com.glqdlt.ex.grpcexam.model.Simple.SimpleResponse.getDefaultInstance()))
                  .setSchemaDescriptor(new SImpleServiceMethodDescriptorSupplier("serverToClient"))
                  .build();
          }
        }
     }
     return getServerToClientMethod;
  }


```

https://b.luavis.kr/http2/http2-overall-operation

https://developers.google.com/web/fundamentals/performance/http2/?hl=ko



https://github.com/saturnism/grpc-java-by-example/tree/master/metadata-context-example/src/main/java/com/example/grpc


## next

- gRPC 인증 과 보안






