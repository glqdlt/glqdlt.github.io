---
layout: post
title:  "gRPC"
author: "glqdlt"
---


# gRPC

본 아티클은 사내에서 차기 프로젝트에서 gRPC 를 사용할 일이 생겨, 토이 프로젝트를 진행해본 것을 기록한 내용입니다.

아래에 서술 된 모든 소스는 [https://github.com/glqdlt/ex-grpc](https://github.com/glqdlt/ex-grpc) 에서 확인할 수 있습니다.



## gRPC 란

gRPC 는 Google 에서 만든 RPC(Remote Procedure Call)에 속하는 프레임워크.

클라우드와 MSA(Micro Service Architecture)가 보편화되어, 분산 된 서비스 node 간의 통신이 중요해지면서 기존 Restful API 보다 효율이 더 좋은 RPC 를 보다 쉽게 사용할 수 있게 하고자 만들어졌습니다. 

농단 반 섞인 이야기로 Restful API 대비 효율이 3배 좋다고 하는데요 -_-; 자세한 것은 [gRPC vs REST slideshare](https://www.slideshare.net/borisovalex/grpc-vs-rest-let-the-battle-begin-81800634) 에서 정보를 얻을 수 있습니다.


<img src="https://grpc.io/img/landing-2.svg"/>


gRPC 의 가장 큰 특징으로는 언어 제약이 없는 [protocol buffers](https://developers.google.com/protocol-buffers/docs/overview)을 통한 바이너리 메세지와 Http/2 기반의 프로토콜을 사용하여 양방형 스트리밍이 가능하다는 점이 있습니다.

지원하는 언어는 아래와 같으며, 자세한 것은 [공식 문서](https://grpc.io/docs/quickstart/)에서 참고할 수 있습니다.

- C++
- C#
- [Dart](https://www.dartlang.org/) (Google 에서 만든 Typescript라 생각하면 쉽습니다,  JVM 기반 Transpile Language.)
- Go
- Java
- Android Java
- Node.js (프론트엔드는 공식적으로는 아직 미지원이나, [써드파티](https://github.com/improbable-eng/grpc-web) 라이브러리가 존재.)
- Objective-C
- PHP
- Python
- Ruby



여담으로 조금 다른 이야기이지만 MSA 에서 node 들 간의 통신에서 restful api 외에도 메세지 솔루션(예: apache kafka)들과도 비교할 수 있지 않은가 하는 생각을 해봤는 데, 곰곰히 생각을 해보니 메세지 솔루션은 pub/sub 개념이고 원하는 시점에 호출하는 RPC 와는 설계와 개념에서 차이가 있기에 의미 있는 고민은 아니란 생각이 들었네요. ([gRPC vs Kafka](https://www.quora.com/How-should-I-choose-between-gRPC-and-Kafka-when-building-microservices) )

## RPC 란

RPC(Remote Procedure Call)는 의미 그대로 원격지에서 guest 가 host 의 function(method)을 호출하고 그 결과를 받는 식의 자연스러운 로직 flow를 가지자는 개념입니다.

RPC 는 오래 전 부터 있던 개념으로 매우 획기적인 컨셉에 비해 사용성이 어려워서 많이 알려지지 않았습니다.
(개인적으로는 처음 접한 RPC는 신입 시절 [Adobe Flex ~ Java SOAP](https://www.tutorialspoint.com/flex/flex_rpc_services.htm)를 경험해본게 최초였네요. -_-a) 

원격지에서 호출한다는 개념 자체가 Guest 와 Host 간의 네트워킹이 관리되야 함을 의미하고, 여기에 공통 된 프로토콜을 정의해야 한다는 전제 떄문에 사용성과 관리가 어려웠습니다.

RPC 구현체로는 대표적으로 아래와 같습니다.

- CORBA
- SOAP
- Java RMI
- Microsoft RPC
- ODBC
- Apache Thrift

최근에는 Thrift 가 소셜 네트워킹 기업에서 사랑 받으면서 점차 RPC의 관심도가 커지고 있는 추세입니다.


## gRPC 구조


<img src="https://image.slidesharecdn.com/grpctalk1-160507200742/95/grpc-overview-17-638.jpg?cb=1462651696">

출처 : [gRPC Overview](https://www.slideshare.net/VarunTalwar4/grpc-overview)

gRPC 는 총 3개의 계층 구조를 가집니다.

Application Layer 에서는 정의 된 .proto 파일을 기반으로 Proto Buffer 에서 어플리케이션에 적용할 구현체(자바의 class)를 생성 하는 기능을 수행하고, 생성 된 구현체들은 gRPC Core 를 통해 Http 2 위에서 통신하게 되는 구조입니다.

## gRPC 와 톰캣

gRPC 는 Http 2 기반이기에, http2 를 포함하는 Servlet4 구현체 중 하나인 tomcat 9 버전에서 쉽게 동작할 수 있지 않을까 생각을 했봤는 데, 서블릿으로는 미지원이라는 것을 알게 되었습니다. (netty 프레임워크 나 okHttp 는 지원)

궁금해서 구글링을 통해 찾아보다가 [관련 토픽](https://github.com/grpc/grpc-java/issues/1621)에서 여러 이유를 알게 되었는 데,
 gRPC 는 http2의 모든 소켓을 완전히 제어할 수 있어야 한다는 전제가 필요 한것으로 보입니다.(이 완전 제어에 대해서는 좀 더 탐구해봐야할 거 같네요.) 서블릿은 이에 적합하지 않은 구조를 가지고 있어서 지원이 불가능하다는 것인데 그래도 영 불가능한 것은 아닌지, 몇몇 스레드를 보면 jboss 의 오픈소스 버전인 wildfly 를 기반으로 시도한 흥미로운 사례도 있어 향후 어떻게 발전할지는 모르겠습니다. -_-a

정리를 하면 웹 프로젝트에 있어서는 서블릿 컨테이너의 http2 통신을 이용해서 gRPC 를 동작시키는 것은 불가능하고, 서블릿 컨테이너 위에서 okHttp 나 netty 등의 http2 구현체를 애드온 하는 형태로 개발 해야한다는 것을 의미합니다.



# getting start

공식 가이드에 있는 예제를 통해 gRPC 를 살짝 맛 봤습니다.
당연한 이야기이지만, 자바로 먹고 살고 있기에 예제 소스는 자바와 메이븐 기반입니다. (추후 NodeJs 기반 Client 정도 작성 할지도 모르겠네요.)

## working flow

gRPC 기반 프로젝트 워킹 플로우를 수행하면 아래와 같습니다.


### work enviroment

0. (java) source project init

1. (수동으로 할 경우) proto buf compiler 설치 

    - [https://github.com/protocolbuffers/protobuf/releases](https://github.com/protocolbuffers/protobuf/releases)


2. (mvn install 으로 처리할 경우) maven or gradle plugin 설정

    - [https://github.com/grpc/grpc-java/blob/master/README.md](https://github.com/grpc/grpc-java/blob/master/README.md)

### work flow

1. .proto 작성

2. proto buffer 구현체 생성

    1. proto buffer generate plugin : 빌드 커맨드에 애드온

        또는

    2. proto buffer compiler 를 통해 수동으로 generate

3. proto buffer 생성 된 구현체와 어플리케이션 로직과의 연결

4. Server : Server Run()

5. Client : server remote method call()


### Example Project Structure


[예제 소스](https://github.com/glqdlt/ex-grpc) 의 구조는 3개의 모듈로 이루어진 멀티 모듈 구조입니다.

각 모듈은 아래와 같습니다.

```
grpc-exam
ㄴclient : host method 를 호출 할 client 에 해당
ㄴmodel : proto 파일이 위치함. client 와 server 에서는 이 model module 을 의존.
ㄴserver : host method 를 호출 당 할 server 에 해당

```

### model

model module source 에는 단순히 proto buffer 에 대한 정의를 하는 모듈이기에, 어떻게 보면 핵심이라 할 수 있습니다. 
이 모듈에는 proto 의 정의와 이를 build 하기 위한 maven plugin 가 정의 됩니다.


아래는 model module 의 메이븐 설정.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>com.glqdlt.ex.grpc</groupId>
        <artifactId>grpc-exam</artifactId>
        <version>1.1</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.glqdlt.ex.grpc</groupId>
    <artifactId>model</artifactId>
    <version>1.0-SNAPSHOT</version>


    <properties>
        <java.version>1.8</java.version>
        <grpc.version>1.17.1</grpc.version>
        <protobuf.version>3.5.1</protobuf.version>
        <protoc.version>3.5.1-1</protoc.version>
        <netty.tcnative.version>2.0.7.Final</netty.tcnative.version>
    </properties>


    <dependencies>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>20.0</version>
        </dependency>

        <dependency>
            <groupId>kr.motd.maven</groupId>
            <artifactId>os-maven-plugin</artifactId>
            <version>1.5.0.Final</version>
        </dependency>

        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-testing</artifactId>
            <version>${grpc.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java-util</artifactId>
            <version>${protobuf.version}</version>
        </dependency>

        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-netty-shaded</artifactId>
            <version>${grpc.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-protobuf</artifactId>
            <version>${grpc.version}</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-stub</artifactId>
            <version>${grpc.version}</version>
        </dependency>
    </dependencies>


    <build>
    <!-- 아래 build plugin 에 ${os.detected.classifier} OS 정보를 넣어주기 위한 확장 플러그인 -->
        <extensions>
            <extension>
                <groupId>kr.motd.maven</groupId>
                <artifactId>os-maven-plugin</artifactId>
                <version>1.5.0.Final</version>
            </extension>
        </extensions>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            <!-- maven 의 compile 단계에서 .proto 를 generate 플러그인 -->
            <plugin>
                <groupId>org.xolstice.maven.plugins</groupId>
                <artifactId>protobuf-maven-plugin</artifactId>
                <version>0.5.1</version>
                <configuration>
                    <protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}</protocArtifact>
                    <pluginId>grpc-java</pluginId>
                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>compile</goal>
                            <goal>compile-custom</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>


        </plugins>
    </build>


</project>
```


#### User.proto

.proto 는 proto buffer 의 syntax 로 작성됩니다. 일반적인 객체 class 문법과 비슷합니다. 

```proto
// proto 파일의 버전을 서술, 문법에 해당한다고 보면 됨.
syntax = "proto3";

// proto 가 빌드될 target package. 생략되면 classpath:/ 루트에 빌드됨
package com.glqdlt.ex.grpc.client.model;

// java 의 enum 과 같음
enum Sex{
    MAN = 0;
    WOMAN = 1;
}

// host 에 위치하게 될 서비스 class 의 이름
service UserService {
    // 실제 호출 될 메소드의 인터페이스를 정의
    rpc getUserDetail (UserRequest) returns (UserDetail) {};
}

// message 키워드가 붙는 것은 Value Object 라고 보면 됨. 특이한 점은 필드의 순서를 정의한다는 점. 
// 또한 message 들은 빌더 패턴으로 생성됨.
message UserRequest {
    string id = 1;
}

message UserDetail {
    string id = 1;
    string name = 2;
    int32 age = 6;
    Sex sex = 4;
    string password = 3;
    string address = 5;
    repeated string hobbies = 7;
    map<string, string> auth = 8;
}
```

model module 를 빌드 하게 되면 아래와 같이 User.proto 가 class 파일로 컴파일 된 것을 알 수가 있습니다.

물론, class 외에도 java 소스 원본도 존재합니다. generated sources 폴더에 가면 원본 .java 파일이 생성 되어 있음을 알 수 있습니다.

<img src ="/images/grpc/model_generated.PNG">



### server

server module 에서는 실제 remoted 될 host 의 로직이 존재하는 곳으로서 model module 에서 generated 된 class 들을 base 삼아서 구현체를 작성하는 것이 핵심.

아래는 server module 의 메이븐 설정
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.1.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.glqdlt.ex.grpc</groupId>
	<artifactId>server</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>server</name>
	<description>Demo project for Spring Boot</description>

	<properties>
		<java.version>1.8</java.version>
		<grpc.version>1.17.1</grpc.version><!-- CURRENT_GRPC_VERSION -->
		<protobuf.version>3.5.1</protobuf.version>
		<protoc.version>3.5.1-1</protoc.version>
		<netty.tcnative.version>2.0.7.Final</netty.tcnative.version>
	</properties>

	<dependencies>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>

		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
        <!-- model module 을 의존 -->
		<dependency>
			<groupId>com.glqdlt.ex.grpc</groupId>
			<artifactId>model</artifactId>
			<version>1.0-SNAPSHOT</version>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>

		</plugins>
	</build>

</project>


```

proto 파일에서 생성 된 클래스를 base로 한 UserService 구현체
```java
package com.glqdlt.ex.grpcexam;

// model 모듈의 .proto 에서 생성된 소스들을 import
import com.glqdlt.ex.grpcexam.model.User;
import com.glqdlt.ex.grpcexam.model.UserServiceGrpc;
import io.grpc.stub.StreamObserver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
public class UserServiceGrpcImplement extends UserServiceGrpc.UserServiceImplBase {
    private final Logger logger = LoggerFactory.getLogger(UserServiceGrpcImplement.class);

    private static final String SOME_USER_ID = "glqdlt";

    private User.UserDetail generateUserDetail() {
        return User.UserDetail.newBuilder()
                .setId(SOME_USER_ID)
                .setAddress("Seoul")
                .setAge(20)
                .setName("Kim")
                .setPassword("12345")
                .setSex(User.Sex.MAN)
                .addHobbies("Coding")
                .addHobbies("Driving")
                .addHobbies("Walking")
                .putAuth("role", "admin")
                .build();
    }

    @Override
    public void getUserDetail(User.UserRequest request, StreamObserver<User.UserDetail> responseObserver) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Optional<String> req = Optional.ofNullable(request.getId());
        logger.info("Get Request : {}",req.orElse("Null?"));
        if (req.isPresent()) {
            if (req.get().toUpperCase().equals(SOME_USER_ID.toUpperCase())) {
                responseObserver.onNext(generateUserDetail());
                responseObserver.onCompleted();
            }
        } else {
            responseObserver.onError(new RuntimeException("Bad Wrong Request..!"));
        }
    }
}

```

아래는 위 구현체들을 로드 할 부트스트랩 클래스

```java
package com.glqdlt.ex.grpcexam;

import io.grpc.Server;
import io.grpc.ServerBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.IOException;


@Component
public class GrpcServer {

    private final Logger logger = LoggerFactory.getLogger(GrpcServer.class);

    private static final String prop = "grpc.server.port";

    @Value("${grpc.server.port}")
    private Integer port;

    @Autowired
    private UserServiceGrpcImplement userServiceGrpcImplement;

    private Server server;

    public void start() throws IOException, InterruptedException {
        if (port == null || port == 0) {
            logger.error("gRpc Server Port is Not SetUp..! '{}' need check!", prop);
            System.exit(-1);
        }
        server = ServerBuilder.forPort(port)
                .addService(userServiceGrpcImplement)
                .build();
        server.start();
        logger.info("gRPC Server  Started! Port : {} ", server.getPort());
        Runtime.getRuntime().addShutdownHook(new Thread(GrpcServer.this::stop));
        server.awaitTermination();
    }

    private void stop() {
        server.shutdown();
    }

}

```

### client

gRPC 의 Client 에서 중요한 개념은 stub 이라는 개념이 중요합니다. Stub은 개념적인 의미로 rpc 에서 전달되는 매개변수 코드 조각을 의미합니다.( [Method Stub Wiki](https://en.wikipedia.org/wiki/Method_stub) , [Stub Wiki](https://en.wikipedia.org/wiki/Stub_(distributed_computing)))



```java

package com.glqdlt.ex.grpc.client;

import com.glqdlt.ex.grpcexam.model.User;
import com.glqdlt.ex.grpcexam.model.UserServiceGrpc;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.stub.StreamObserver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

@SpringBootApplication
public class ClientApplication implements CommandLineRunner {

    private static final String REQUEST_ID = "glqdlt";

    @Value("${grpc.server.port}")
    private Integer port;

    private final Logger logger = LoggerFactory.getLogger(ClientApplication.class);

    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
    }

    private void callBack(User.UserDetail userDetail) {
        logger.info("Received! Response : {}", userDetail);
    }

    @Override
    public void run(String... args) throws Exception {
        ManagedChannel channel = ManagedChannelBuilder
                .forAddress("localhost", port)
                .usePlaintext()
                .build();
        User.UserRequest req = User.UserRequest.newBuilder().setId(REQUEST_ID).build();

        UserServiceGrpc.UserServiceStub serverResponse = UserServiceGrpc.newStub(channel);
        serverResponse.getUserDetail(req, new StreamObserver<User.UserDetail>() {
            // 서버에서의 응답이 있을 때마다 호출되는 메소드.
            // onNext 는 서버에서 여러번 보낼 수 있다는 점을 유의
            @Override
            public void onNext(User.UserDetail userDetail) {
                callBack(userDetail);
            }

            // error 캐치
            @Override
            public void onError(Throwable throwable) {
                logger.error(throwable.getMessage(), throwable);
            }

            // 서버에서 finish 콜이 왔을 때 호출되는 메소드.
            @Override
            public void onCompleted() {
                logger.info("Done!");
            }
        });

        // 아래는 단순히 0~50번 까지 숫자를 찍는 스트림
        IntStream.rangeClosed(0, 50).forEach(x -> {
            try {
                logger.info("is Done ?  .. : {}", x);
                Thread.sleep(50);
            } catch (InterruptedException e) {
                logger.error(e.getMessage(), e);
            }
        });
        channel.awaitTermination(5, TimeUnit.SECONDS);
        logger.info("Channel Terminated");
    }

}



```

- newBlockingStub() 
    
    sync 해당 메소드에서 block 이 일어남. 일반적으로 친근하게 느낄 형태.


- newStub() 

    async 메소드. 아래 client 코드를 보면 알 수 있지만, jquery ajax 를 다뤄본 사람이라면 친근하게 느낄 수 있음.
    
- newFutureStub()

    newStub() 과 같은 async 메소드 이지만, Future 를 응답한다는 점에서 차이가 있음. Future를 직접 핸들링 해서 응답이 오기 까지 잠시 선행 작업을 처리하고 future.get()에 실제 응답이 오기까지 blocking 하고 싶을 경우 사용성이 더 적합함.


Sync와 Async의 차이는 아래 다이어그램으로 설명합니다.

##### Sync
<img src ="/images/grpc/sync.png"/>


##### Async
<img src="/images/grpc/async.png"/>





아래는 client module 의 메이븐 설정

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.1.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.glqdlt.ex.grpc</groupId>
    <artifactId>client</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>client</name>
    <description>Demo project for Spring Boot</description>

    <properties>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency><dependency>
        <!-- server module 과 마찬가지로 model module 을 의존 -->
        <groupId>com.glqdlt.ex.grpc</groupId>
        <artifactId>model</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```


# next step

- Server to client push : pub / sub 같은 push 모델을 구현할 수 있는지 탐구.

- [Loadbalacing](https://grpc.io/blog/loadbalancing) : gRPC 와 로그밸런싱

- [gRPC Web Frontend](https://github.com/improbable-eng/grpc-web) : 서드파티에서 구현한 gRPC 웹 프론트엔드의 탐구.

# ref

아래는 참고헀던 레퍼런스

- [공식 가이드](https://grpc.io/docs/tutorials/basic/java.html)

- [잘 정리된 블로그](https://medium.com/@goinhacker/microservices-with-grpc-d504133d191d)

- [gRPC - Ray Rsang](https://youtu.be/xpmFhTMqWhc)

- [Java Hello World Tutorial](https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/helloworld/HelloWorldServer.java)

