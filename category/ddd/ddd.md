# Domain Driven Dev

DDD 관련해서 작성 했던 토막글을 정리.


### 에그리게이트 상태, 버전 관리에 대하여

일반적으로 사용되는 에그리게이트의 버전 관리는 아래와 같다.

![](495aad64.png)

detail은 에그리게이트의 root 외의 서브 도메인 객체의 스냅샷 이다. 관계형 데이터베이스로 풀수도 있겠지만 복잡도가 높아지니 대부분 TEXT 컬럼이나 JSON 컬럼으로 한다. DDD가 커플링을 배제하기 위해 낙관적 잠금을 사용하다 보니, 이런 구조를 보면 자연스레 nosql 이 당겨진다.

하고 싶은 얘기는 위에서 version 컬럼이 number 인 것이다. INT 형이라면 결국 32비트 정수 최대인 32억(3억이었나?) 까지 도달하면 정수를 더 올릴수 없을것이다, 결국 끝이 있다. 그래서 일 단위로 초기화할수 있게 하는 date 라는 컬럼을 추가하고 date+version 의 복합 유니크키로 구성이 되는 것이 흔하다.

version 을 순차 증가 정수형으로 쓰는 이유는 단순한데, 모든 컴포넌트들이 사용할수 있는 쉽고 정확한 알고리즘인 number++ 연산 때문이다. 내가 알고 있는 정수에서 +1 만 한다는 간단한 식이니 얼마나 편한가.

문제는 위예시로 보면 2022-03-15에서 2022-03-16으로 넘어가는 시점에 발생한다. 15일에서 16일로 넘기는 것은 number++ 와 달리 나노미터초 기준으로 오차가 발생할수있는 어려운 문제이다. 예를 들어서 

레코드 마지막은 date 는 2022-03-15 , version 99 이고,  

2022-03-15 23:59:59 에 접근한 A와, 2022-03-16 00:00:00 에 접근한 B가 있다고 가정하자

둘다 모두 2022-03-15,version99 를 가져 왔지만, A는 15일에 접근했기에 version 100 으로 올리기만 하고 B는 다음날에 접근했기 때문에 version 을 1로 초기화하게 된다. 아래의 그림처럼 처리 된다. 
 
![](335f8499.png)
   
   
이런 불상사를 해결하고자 단순하게 접근하면 커밋을 하는 시점이 23시에서 24시 사이라면 무조건 다음 날자로 버전업을 한다 라고 가정해볼수도 있는데, 22시에서 23시로 넘어가는 시점에 똑같은 문제가 발생한다.

결국 이런 version 을 관리하는 주체가 필요해지는 문제가 된다. 

단순히 date+version 이 아니라, sequence 라는 개념의 bigint 컬럼을 잡고 단순히 정수를 증가시키는 auto increment 컬럼으로 파더라도, 1달에 한번 누군가는 이 auto increment 를 1 값으로 초기화 시켜주어야 한다.

그런데 가만 또 생각해보니, 이전버전+새로운버전으로 조합하면 UUID 로도 처리가가능하곘다 싶었다.

아래의 그림을 보자

 ![](635f1074.png)
 
이전 버전과 현재 버전을 각각 독립적인 유니크키의 커럼으로 만든다. 즉 유니크컬럼이 2개있다.

이렇게 하면 A와 B 모두 접근헀을 버전은 A2가 마지막이었기에, 이 A2를 가지고 prev_version에 insert 를 동시에 하려 하게된다.

하지만 prev_version 컬럼은 유니크하기 때문에 먼저 등록한 A의 처리가 등록이 되고, B는 중복 에러로 인해 실패하게 된다.