DDD 와 MSA 그리고 클라우드 전반적인 부분을 정리해준 고마운 책이다.

책 제목은 입문서적 같지만, 굉장히 넓고 포괄적인 개념을 담고 있기에, 매우 가볍게 입문 서적으로 훑으면서 이런게 있구나 하면서 단어들을 눈에 익히는 정도로 끝내고, 에릭 에반스의 DDD 와 같은 바이블을 정독한 뒤에 다시 돌아와서 개념을 정리하면 매우 놀라운 학습 성과를 얻을 수 있는 책이다. (왜냐면 어쩌다 보니 내가 이렇게 하고 있었고 효과를 봤기 때문)

## 바운디드 컨텍스트

도메인의 경계에 대한 이야기이다. 도메인의 개념을 외부로 부터 오염 받지 않기 위한 경계를 말한다. 외부로 부터 오염 받는다니? 라 생각이 들수 있는 데, 관점이나 맥락에 따라서 개념이 지칭하는 단어가 다르게 해석될 수 있는 걸 오염이라고 말할수 있다.
예를 들어 '고객' 이라는 단어 자체만을 놓고 보자. 결제 팀과 배송 팀에서 고객이라는 단어를 모두 사용할수 있다. 결제 팀에서의 고객은 상품을 구매하기 위해 '결제를 행하는 사람'을 말한다. 배송 팀에서의 고객은 '상품을 수령하는 사람'을 말한다. 내가 부모님에게 보내드릴 상품을 결제하였고, 실제 상품은 부모님의 집으로 배송이 되었다고 해보자. 여기서 결제팀의 고객은 '나' 를 의미하고, 배송팀에서의 고객은 '부모님' 을 가르키게 된다. 완전히 다른 개념이 된다. 이러한 환경에서 결제팀과 배송팀이 서로 고객에 대해 얘기 또는 협업을 한다면 다른 의미로 의사소통 하게 되어 비지니스 혼란을 야기할수 있다.

> 명확하게 결제 서비스에서는 결제자의 개념으로, 배송 서비스에서는 수취자의 개념으로 모델링해야 한다. - 도메인 주도 설계로 시작하는 마이크로서비스 개발

결제 팀에서 고객이란 모델을 모델링 한다면 '결제' 가 가능한 회원 계정을 말할 것이다. 일반적으로 로그인한 유저가 자신의 보유한 결제방법으로 결제를 하게 됨으로, 회원 계정을 포커싱할수도 있지만, 사실 회원 계정은 결제방법이 없는 계정도 존재함으로 고객팀에서의 고객이란 결제방법을 보유한 회원계정으로 정의 하고 모델링에 접근해야 한다.

배송 팀에서 고객이란 상품을 수령 받는 사람이다. 앞서 말한 예시처럼 선물을 한다는 개념으로 보면 '부모님' 은 회원 계정과 전혀 상관이 없는 사람이다. 배송 팀에서는 고객이라는 단어가 핵심적이지는 않다. 상품을 배송 하는 과정에 누가 받아야할지를 표기하는 개념일 뿐이기 때문이다. 그래서 고객이란 개념은 상품이 수령될 수령지와 수령인의 이름이 조합된 개념으로 보게 된다. 수령인의 이름으로만 치면 해당 지역에 살고있는 동명이인이 있을수도 있기에 명확히 수령지에 거주하고 있는 수령인으로 접근해야한다.

고객이란 모델을 놓고 이를 클래스로 표현해보자. 결제 팀에서의 고객은 필수적으로 결제방법이라는 속성이 존재하게 된다. 만약 회원 가입 팀이라는 팀이 존재한다면 이 팀에서의 고객 모델에는 결제 방법 속성이 필요하지 않다. 배송 팀 입장에서는 고객이라는 개념은 주소와 수령인이라는 문자열에만 집중할수 있다.

결제팀 고객
- 이름 : 문자열
- 계정명(id) : 문자열
- 결제방법 : 리스트
- 포인트 : 정수
- 캐시 : 정수

배송팀 고객
- 상품구매계정명(id) : 문자열
- 수령인 성명 : 문자열
- 수령인의 주소 : 문자열
- 수령 요청 메세지 : 문자열

회원팀 고객
- 이름 : 문자열
- 계정명(id) 문자열
- 휴대폰 번호 : 문자열
- 이메일 주소 : 문자열
- 가입 추천인 : 문자열

 (5분만에 생각해본 모델링이기에 허접할수 있다, 참고만하자)
 
 이렇게 각 팀에서는 팀이 존재하는 이유에 따른 업무 관심사 속성들이 고객에 내포하게 된다. 배송팀 입장에서는 결제방법에 따라서 비지니스 정책이 바뀌거나, 코드의 로직이 바뀔 일이 없다. 반면 결제팀 입장에서는 결제 방법에 따라서 포인트가 더 누적이 되거나, 캐시를 사용할 수 없거나 하는 비지니스 정책 조합이 결정이 됨으로 중요하다. 
 
 복습차원의 보너스로 상품이란 개념도 각 팀에서의 온도차이를 생각해보자. 결제팀에서의 상품은 실제 실물을 대상으로 하지 않는다. 결제를 하기 위한 상품의 가격을 의미하는 개념적인 비실물이다. 반면 배송팀에서의 상품은 실제 실물을 대상으로 한다. 
 조금 더 현실적으로 말하면 결제팀에서의 상품은 불량품이 없다. 반면 배송팀 입장에서는 상품은 불량품이 있거나 잘못 포장된 다른 상품일 수도 있다.
 
 
 ### 바운디드 컨텍스트 간의 매핑 패턴
 
 개발팀은 다른 개발팀과 연계되거나 상호협력하게 되어 비지니스를 수행하게 된다. 여기서 각 개발팀은 자신의 주관심사인 바운디드 컨텍스트를 보호하고 커뮤니케이션을 원활하게 하기 위한 접점에 대해 고민을 해보아야 한다.
 
 아래에는 업스트림 다운스트림 이라는 개념이 있다. 개인적으로 고생을 많이 했는데, Restful API 로 공급자에게 직접 데이터를 달라는 요청에 익숙했기 때문에 고생을 했다. 이벤트 주도 개발론의 이벤트 전파라는 개념으로 보면 업스트림 다운스트림이 이해가 된다. 
 
 예를 들어서 결제가 완료가 되면 배송이 시작된다는 비지니스 흐름이 있다고 하자. 결제팀과 배송팀 2팀의 서비스 시스템이 존재할 것이다. 결제팀의 시스템은 결제가 완료되면 배송 시스템에 배송을 시작해라고 요청하게 될 것이다. 이 관계에서 결제팀은 업스트림이고 배송팀은 다운스트림이다.
 
 #### 공유 커널
 
 A팀과 B팀이 공통적인 모델을 서로 공유하여 의사소통한다.  이 공통 모델은 인터페이스나 추상 클래스일 가능성이 높다. 공통 모델은 각 팀이 상호 협의하에 관리가 되어야 문제가 발생하지 않는다. 예를 들어 A팀에서 특정 속성 필드명을 바꾸게 된다면 한다면 B팀에서 장애가발생할 것이다. 
  공유 모델은 특정 팀에서 메인터넌스를 가지고 배포와 수명주기 관리를 하는 것이 일반적이다.
  
#### 소비자(upstream)와 공급자(downstream)

개념 자체는 소비자와 공급자란 단어가 정확하지만, 소비자를 consumer, client ,browser 로 보고, 공급자를 provider, service, web server 로 생각하면 이해하기 수월해진다. 참고로 에릭에반스에서는 소비자와 공급자라 하지 않고 업스트림, 다운스트림으로 표현을 한다. (그래서 너무 어려웠다.)

이 패턴에서는 공급자에서 소비자로 데이터의 흐름이 흐르게 된다. 대표적인 사레로는 뷰어-서버 모델을 들수 있다.

소비자와 공급자 패턴은 데이터 흐름이 일방적으로 흐르는 데에 특징이 있고, 따라서 데이터를 보내주는 주체에서 모델에 대한 설계와 메인터넌스 책임이 생긴다. 서버는 뷰어에게 데이터를 전달할 책임이 있고, 뷰어는 서버가 보내준 데이터를 표현만 하게 된다. 서버에서는 XML 기반의 직렬화 데잍러를 전송만했는데, 최신 뷰어가 데이터를 JSON 직렬화 구조로만 받을수 있다면, 서버에서는 JSON 직렬화 방식도 지원하여서 공급해주어야 한다. 즉 소비자를 존중하여 공급자가 이에 필요한 기능이나 모델을 제공하는 것이 특징인 패턴이다.

#### 준수자 (confirm)

소비자와 공급자와 같은 데이터 흐름을 가진다. 모든 것이 유사하지만 가장 큰 특징으로 공급자는 소비자에게 기능을 제공할 의무가 없다. 따라서 소비자는 공급자가 주는 데로 받아서 쓰게 된다. 소비자 공급자에서 xml-> json 으로 공급자가 바꾸었던 특징이 있엇다면, 준수자에서는 xml -> xml 로 소비자가 xml 을 아쉬운데로 써야 한다. 보통 이런 경우는 구글이나 Azure, AWS 와 같은 대형 벤더의 서비스를 이용할 때 자주 보여지는 패턴이다.

#### 충돌(부패) 방지 계층 (ACL; Anti Corruption Layer)

준수자와 같은 데이터 흐름을 가진다. 준수자처럼 공급자는 소비자에게 기능을 제공할 이유가 없다. xml -> xml 사레처럼 말이다. 충돌 방지 계층의 패턴에서는 소비자가 xml 을 json 으로 바꾸는 어뎁터를 두는 것이 특징이다. 충동을 방지한다는 말처럼 xml -> xml 을 사용하게 되면 소비자의 내부 핵심 로직들이 변질되거나 버그가 발생할 소지가 있으니, 이를 막기 위해서 xml -> json 으로 내부적으로 변환하는 아답터를 두고 내부 핵심 로직을 보호하려하는 특징을 가진다. (참고로 에릭 에반스의 DDD 에서는 충돌 방지 계층이 아닌 부패 방지 계층이라고 번역되고 있다.)  

#### 공개 호스트 서비스 (Open Host Service)

소비자가 공급자를 직접 호출해서 사용하는 기능들을 직접 조합하고 사용하거나 할때 발생하는 패턴이다. 소비자 공급자, 준수자, 충돌 방지 계층의 특징은 데이터 흐름이나 데이터 조합을 소비자가 직접 제어하지 못하는 데, 공개 호스트 서비스에서는 소비자가 용이하게 사용할수 있도록 공급자가 API 를 외부에 노출하는 것을 의미한다. 따라서 공급자의 바운디드 컨텍스트에 접근할수 있는 외부의 창구를 오픈하는 셈이기 때문에, 핵심 도메인이 노출될수도 있는 보안적인 부분에 대한 고려가 필요하다.

위의 결제팀과 배송팀에 대한 환경으로 시나리오를 짜보면 아래와 같은 공개 호스트 서비스를 생각해볼수 있다. 결제 시스템에서 배송 시스템으로 배송 요청이란 데이터 흐름이 발생했을 때, 배송 시스템에서 특정한 로직에 의해 결제한 사람의 상세 로그가 필요할수도 있다. (여기서 특정한 로직은 아무 의미 없다.) 이때 배송 시스템은 결제 시스템의 공개 호스트 서비스 API 를 통해 상세 로그를 조회하여 로그 데이터를 취득하고자 할수 있다. 이러한 시나리오를 예로 들수 있다.

#### 발행된 언어

모든 사례에서 나온 json 이나 xml 과 같은 전세계 공통적인 표준 교환 스펙의 정의를 어떻게 하는지에 대한 이야기이다. 이것이 필요한 것은 공개 호스트 서비스 패턴을 적용할 때, 독자 규격을 사용하는 API를 공개하는 것보다 표준 데이터 스팩으로 공개를 하는 것이 더 사용성이 좋을 수 있다. 예를 들어 어떠한 공급자가 공개 호스트 서비스로 자사의 상품 정보를 알려주는 공개 Restful API를 만들었는데, Content-Type 이 표준 타입이 아닌 독자 규격 'Content-Type : myTextFormat' 이라면 소비작 입장에서 이 포맷을 익히고 해석하는 추가적인 비용이 발생하게 된다. 이를 방지하기 나온 당연한 패턴이다. 


 

이 책에는 클린 아키텍처라는 말이 많이 언급되는 데 빈도 수에 비해 별도로 다루고 있지는 않다. 사실 헥사고날 아키텍처를 설명할때, 이의 전신이 되는 것이 로버트 마틴의 클린 아키텍처이다.

클린 아키텍처는 "중요한 것과 중요하지 않은 것을 구분하고, 중요하지 않은 것에 의존하지 않도록 잘 분리하여 설계한다" 라는 개념을 갖고 있다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlxciD%2FbtqG3lIG6ym%2FkcSRUhV2779YNl8j0ELiO1%2Fimg.jpg">

핵사고날 아키텍처에서는 포트 앤 어뎁터 아키텍처(ports and adapters acrchitecture)라는 이름으로 외부와의 경계를 느슨하게 연결하는 용어를 쓰고 있다. 클래스로 치면 인터페이스를 말한다. 내부 영역에서는 어플리케이션 내에서 계층이 만들어진다. 여기서는 아답터 패턴과 같은 걸 의미하는 데, 아답터를 쓰는 이유는 다양한 프레임워크를 쉽게 변경하기 위해서이다. 

사실 이는 우리가 MVC 와 같은 계층형 구조에서 이미 익숙하게 느낀 방법론이다. MVC 에서 Model(M) 비지니스 도메인 영역에 해당하고, View(V) 는 표현 계층 영역, 컨트롤러는 뷰어와 모델을 이어주기 위한 계층으로, 계층과 계층을 이어주는 컨트롤러가 아답터와 유사하다. 뷰어가 웹 기반이든, 콘솔 GUI 이든 간에 비지니스 모델은 변하지 않고, 컨트롤러가 이를 완충해준다.
 MVC 는 모놀리스한 앱, 앱 자신에만 구성을 맞추고 있기 때문에 외부 인프라와의 연계에 대해서는 다소 고민을 하지 않는 아키텍처이다. 
 
 같은 개념으로 핵사고날 아키텍처에서는 다양한 인프라와 프레임워크와의 결합에 초점을 맞춘다. 포트는 외부 인프라와의 결합을 위한 것을 목적으로 하고, 어댑터는 어플리케이션 내부의 계층과 계층을 연결하거나, 프레임워크와 연결하는 것에 초점을 둔다.

## 엔터프라이즈 업무 규칙

## 애플리케이션 업무 규칙

## 인터페이스 어댑터

## 프레임워크와 드라이버


https://dailyheumsi.tistory.com/239 