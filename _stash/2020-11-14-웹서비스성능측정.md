# 웹 서비스 성능

일반적으로 웹 서비스의 성능이란 성능이란 단어에 따라서 속도를 의미한다. 트랜잭션 완료 시간을 중요시하게 보는 경향이 있다. 즉, 화면의 로딩이 빨리 끝나냐 안 끝나냐로 본다.

웹 서비스 성능은 관점이 어디냐의 기준에 따라서 달라질수 있다. 사용자 경험성을 중요시하는 관점의 사람은 응답속도를 중요시하게 볼것이고, 서비스 관리자 입장에서는 가용성(availability)와 포용성(capacity)를 중요시하게 보겠지만 이 2가지를 나누면 안되고 같은 동등한 레벨로 접근을 해야한다. 이유는 1명의 사용자가 접근할때와 100명의 사용자가 접근할때 속도는 달라질수 있기 때문이다. 

암달의 법칙 그래프에 따르면 병렬컴퓨팅에서는 병렬수가 많아진다고 해서 속도가 리니어하게 상승하는 것은 아니고, 일정 수치에 도달하면 성능이 증가되지 않고 유지되는 걸 볼수가 있다. 



서버의 동시 처리량은 깔대기 이론(Funnel theory) 에 비유할수 있다.

깔대기는 모양새가 인풋은 많은걸 받을 수 있지만 아웃풋은 입구가 좁아서 인풋만큼 아웃풋이 되지는 않고 병목이 발생하는 구조이다.



## 용어 정리

성능을 측정하는 단어들에 대해 정리를 한다. 보통 일반적으로 시간 당 처리량에 관점을 두게 된다. 'TPS, 'PPS', 'HPS, 'RPS' 등이 있다.

### 서비스 계층

2계층 구조, 3계층 구조에 대한 이야기를 들어봤을 수 있다. 웹 서비스는 관점에 따라서 2계층이 될수도 3계층.. 또는 N계층이 될수도 있다. 

2계층 구조는 단순하다. Client-Server 형태의 서로 식별 가능하게 맞닿아있는 구조이다. 대표적으로 FTP를 예시로 볼수 있다.

만약 OS에 Client 툴을 설치해서 실행하는 DB 접속 툴의 경우도, 2계층 구조라고 할수있다.

반면 일반적으로 DB를 끼고 웹 서비스 개발을 하면 기본적으로는 3계층 구조를 가지게 된다.

클라이언트 입장에서 DB에 저장된 데이터를 조회하거나 핸들링하는 것이 일반적인 웹 서비스의 기본 형태인데, DB를 가기 위해서는 웹어플리케이션서버(WAS)를 거쳐서 제어가 되기 때문이다.

즉 2계층은 클라이언트가 DB서버를 바로 식별할수 있지만.. N계층 구조는 식별이 불가능하다. 이는 여러가지 장단점이 있다.

단점은 일단 서비스 구성 복잡도가 높아지고, 성능 병목 지점이 올수 있다. 복잡도는 2개보다는 3개가.. 3개보다는 4개.. 단순히 봐도 갯수가 많아질수록 관리 포인트가 높아지니깐 당연히 복잡해진다.

병목이란 A->B->C 라는 3티어 구성에서 A가 C까지 도달하려는데, B에서 장애가 생기거나 성능하락이 발생하면.. B때문에 서비스 전체 성능이 떨어지게 되는 걸 의미한다.

장점은 무엇일까? 객체지향 방법론에도 주로 나오는 결합도가 낮아지는 효과가 여기에도 발생한다. CLIENT >> WAS >> DB 의 구조에서 DB를 Mysql로 사용하다가 Oracle 로 바꾸거나, DB가 갑자기 죽더라도.. Client 는 영향을 받지 않기 때문에 서비스 이슈 파급력이 클라이언트까지 전달되지 않는다.  보안도 장점이 된다. 2티어 구조에서는 비지니스 로직이 클라이언트에 포함될수도 있기 때문에 리버싱(역공학, 일반적으로 해킹이라고도 함) 을 통해 해당 로직이 노출이 될수도 있다. 온라인게임 중에서 게임클라이언트를 뜯어서 수치를 바꾸거나 하는 사례가 간혹 뉴스에 나오는것을 알수 있다. 이러한 경우에 해당한다. 3계층 구조는 클라이언트는 단순히 명령을 요청하는 기능만 탑재하고, 실제 명령의 로직은 중간계층인 WAS 에 포함시켜서 구성이 된다. 이게 무슨 말이냐면 예를 들어서 홍부가 놀부에게 10만원을 송금한다고 치면, 홍부의 통장에서 10만원을 차감하고 놀부의 통장에 10만원을 입금해야하는 개념이다. 만약 2계층 구조에서 이를 클라이언트에서 수행하다가 해킹에 의해 홍부의 통장을 차감시키지 않고 놀부의 통장에 10만원을 입금만 시키게 한다면.. 말 그대로 돈복사 이슈가 발생할 것이다. 3계층 구조에서는 클라이언트는 홍부가 놀부에게 10만원 송금 요청이라는 명령만 수행할수 있고, 실제 복잡한 입/출금 처리는 WAS에서 처리가 됨으로 이슈가 없다.




### TPS

TPS는 가장 보편적으로 사용되는 단어이다. 어원은 과거 2티어 타입의 응용프로그램이 DB에 접속해서 트랜잭션(조회 포함)을 유발시킨 후 원하는 목적을 응답(데이터 처리 나 데이터 조회 등)을 받았을 때까지의 시간을 초 기준으로 보는 것이다. 필자가 자주 사용하는 mysql 의 heidisql 프로그램이 대표적인 예로 둘 수 있다. 
아래와 같은 쿼리를 해당 툴에서 날리면 몇초 걸렸는지 결과가 나온다.

```
select * from user;
/* 영향 받은 행: 0  찾은 행: 20  경고: 0  지속 시간 1 쿼리: 0.016 초 */
```


## 웹 서비스 성능 계산

### 동시접속자

동시접속자는 웹서버의 유휴 session 을 보고 판단하게 된다. 다만 동시접속자가 active 유저인 것은 아니다. 웹서버는 기본적으로 stateless 하기 때문에 유저가 로그아웃 기능을 사용치 않고 단순히 브라우저를 끄기만 한다고 해서 session 이 제거되지 않기 때문이다.

### 송수관 이론 (water pipe theory)

송수관의 성능을 판단하는 가장 이상적인 기준은 관의 굵기, 물의 압력이 아니라, 단위 시간당 흘려보낼수 있는 수량을 말한다. 
단위 시간당 흘려보낼수 있는 수량이 결정되는 것은 관의 굵기가 크고, 물의 압력이 관의 굵기만큼 보내줄수있어야 한다. 송수관은 '수도 계량기' 를 이용해서 특정 시간에서 시간까지 얼마만큼 수도를 사용했는가로 볼수가 있다.

### 웹서버 성능 측정

송수관 이론에서는 계량기가 있지만 웹서버는 여러가지 요인으로 인해 쉽게 측정하기 어렵다. 평균응답시간으로 접근하면 리소스를 모두 사용하는 (많은 유저가 몰릴때) 에는 전체 유저의 응답시간이 높아지는 게 보여진다. 반면 TPS로 접근하게 되면, 이러한 이슈가 없기 때문에 일반적으로 TPS로 접근한다.

TPS는 시간을 기준으로 접근이 된다. 기본적으로 1초를 기준으로 보는 데, TPS 100이라면 1초에 100건의 처리량을 얘기한다. 만약에 TPS 2초 기준으로 보면 TPS 가 150으로 증가할수도 있다.


# Ref

- https://www.slideshare.net/sunnykwak90/ss-44875669
- https://johngrib.github.io/wiki/amdahl-s-law/
