Q. 검색 알고리즘
A. 

공간복잡도는 메모리 사용 규모를 의미한다. 시간복잡도는 알고리즘의 명령이 수행되는 횟수이고, 가장 최적의 알고리즘은 시간복잡도가 낮고 공간복잡도도 낮은 것이 좋지만, 사실상 시간복잡도가 낮으면 그만큼 연산에 필요한 공간복잡도가 높을 수 밖에 없는 반비례를 가지게 된다.

빅오표기법으로 안다. 빅오표기법은 알고리즘의 최악의 속도를 기준으로 한다. 실무에서는 최악의 속도를 측정하는것이 중요하니깐.

참고로

- 빅오는 최악의 시간

- 오메가는 최상의 시간

- 세타는 평균시간을 의미한다.


개인적으로는 알고리즘 성능에 대해서는 관심을 갖고 있지만, 실제 구현 단계에서의 고려를 할 기회는 거의 없었다. 그래서 위의 시간복잡도와 공간복잡도를 계산해서 구현체들을 어떠한걸 쓰는 게 좋을지에 대해 관심을 가지는 편이다. 간단히 일반적으로 알고 있는 알고리즘은 신입 시절 면접을 위한 수준의 이해와 구현 밖에 모른다. 병합정렬과 퀵 정렬에 대한 이야기가 주로 많다. 퀵 정렬이 가장 빠르지만 리스크도 있는 걸로 다들 안다. 사실 퀵 정렬이 병합정렬보다 빠른 이유는 내부 정렬 배열을 생성하는 로직에서 차이가 있다.

n 이 16이라고 가정하면

- O(1) 상수시간 
    
    - O(1) = 1

- O(log n) 로그 시간:  특정 요인에 의해서 n으로 순환하는 게 아니라 줄어드는 경우

    - O(log 16) = 4*4 = 16 =>  4
    

- O(n) 직선시간 : 

    - 막대기는 완곡한 대각선으로 그려짐

    - O(16) => 16

- O(n^2) 2차 시간 :

    - 막대기가 수평에 가깝게 변함

    - O(16^2) => 16 * 16 =  256

- O(C^n) 지수 시간

    - O(2^16) => (16 * 16  ) * ( 16* 16) => 65536




- 선택정렬 O(n^2) 

- 삽입정렬 O(n^2)

- 버블정렬 O(n^2)

- 병합정렬 O(log n)

- 퀵정렬 O(log n) 사실 퀵정렬은 특정한 상황에 최악의 상황이 나타날수있기 때문에 빅오 표기법으로는 O(n^2)가 맞다. 그러나 이런 경우에 대해 회피하는 방어 코드가 시중에 많이 보편화되어서 사실상 n log n 으로 보고 있다.


