---
layout: post
title:  "Bottle VS Flask"
author: "glqdlt"
---

전통적인 top-down 형태의 script 구문을 삽입하여 개발해 온 나 같은 개발자들은 요즘 나오는 mv** 패턴의 프레임워크들 'react', 'angular', 'vue' 등에 대해 접근하기가 어렵고 헤맬 부분이 많다. 나도 이러한 사람으로써 과정에서 많이 삽질하고 정말 이것만 이해하면 되는구나를 꺠우친 것을 글로 남겨본다.

mv**(mvvc,mvvp 등) 패턴은 상태체크를 위한 패턴이다. data-bind 라는 개념으로 접근하면 쉽게 이해 된다. 데이터를 만드는 JS(메모리상의 데이터)와 브라우저에 보이는 데이터를 묶어보자는 아이디어다. 유례는 실버라이트 & native app에서 만이들 쓰이던 디자인 패턴 이다.

## 모든 것은 '모듈' 때문이다.

모듈을 하면 이득보는 것은, 코드의 재사용, 유지보수 상승, TDD의 적극적인 반영, 충돌 회피 등이 있다. (이는 나중에 포스팅 하겠다)

commonJs (일종의 자바스크립트 표준을 위한 라이브러리다, 다른 언어에는 이거있더라를 우리도 사용하자란 개념으로, 이를 언어 수준에서가 아닌 써드파티에서 해결하고자 한 것이다.) 의 require('') 구문이 있다. 이 구문으로 자바의 import package 와 같이 외부의 모듈(자바로 치면 클래스가 되겠죠)을 불러와서 재사용할 수 있는 데..
nodeJs는 지원하지만 브라우저에서는 지원하고 있질 않다.

http://kangax.github.io/compat-table/es6/



아이러니한 것은 ES6에 들어와서 import 구문이 생겼는 데, 작성 시간 기준으로 구현한 js엔진이 없다. 이를 사용하기 위해서는 트랜스파일러를 적용해야 한다.(babel, typescript 등..)

어쨋든 언제까지고 script 구문을 넣어서 통짜배기로 개발을 할수 있는 노릇도 아니고.. 편하게 npm install 로 라이브러리를 다운 받고 개발 형상에서 개발 및 테스트를 맞췄는 데 막상 배포를 하고 보면 브라우저에서 동작을 못하는 것이( error : what is require()? 란 느낌..) 문제인 것이다.

이를 해결하기 위해 나온 써드-파티 로 requireJs와 같은 lib 파티션들이 나타나기 시작했다.
지금에 와서는 하나의 archive 처럼 모든 .js .css 를 빌드 해서 http1.* 의 문제점인 커넥션 오버헤드를 줄이는 이득도 보는 '번들링'이란 개념의 webpack 과 같은 번들 파티션들도 생겨났다.

