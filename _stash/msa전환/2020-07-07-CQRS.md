# CQRS 패턴

CQRS 는 명령 계층과 조회 계층을 나누어야 한다는 개념이다. 필자는 처음에 엥? 그거 읽기 API 쓰기 API 로 따로 놔두면 되는거 아님? 이라 생각했는데, 단순하게 인터페이스를 분리한다는 개념을 넘어서 반환 객체 조차 차이를 두어야 한다. 즉 계층을 나눈다는 것은 모델이 나누어진다는 것을 의미한다.  읽기API 와 쓰기 API가 각자의 길로 다른 객체와 로직을 사용하는 것이 주 포인트이다.

CQRS 가 나온 것은 비지니스 복잡도가 높아짐에 따라 시스템적으로 대응하기 어려운 것을 해소하고자 나온 것이다.
말은 쉽지 ㅋ 이 말을 쉽게 풀어보려고 한다. 참고로 순수하게 CQRS 에 대해서만 얘기할거다, 일반적으로 이벤트 소싱이나 EDD 를 같이 엮어서 얘기를 많이 하는데.. 그러면 CQRS 를 이해하는 데에 오히려 복잡해지니깐 말이다.

가장 단순한 예제는 이런 경우다.

User 라는 개념의 엔티티가 있을 때, 회원가입을 할때에는 Password 라는 속성이 필요하지만

회원가입이라는 개념 외에는 User 라는 개념을 UI에서 표현할때에는 Password 가 노출이 되면 안된다.

이런 경우 UserEntity 와 UserViewObject 라는 개념으로 나눌수도 있다.

즉 여기서 회원가입이라는 개념은 명령 계층이, 회원조회라는 개념에서는 조회 계층이 원하는 바가 다르다는 걸 알수 있다.

---

이번엔 서비스 성능적인 이슈로 보자. 

보통 표현계층에서 유저 경험성을 위해 여러가지 요소들이 표현되기도 한다.

예를 들어서 필자는 게임 회사에 있음으로 게임에서 자신의 계정의 상태에 대한 세부내역을 보는 프로필 개념의 기능이 있다고 가정하자.

여기에는 계정의 생성 정보와 계정아이디 그리고 게임 전적 등의 요소들을 보여줄수 있다.

계정 아이디는 단순하니깐 넘어가겠다, 뭐랄까 User 란 이름의 스키마가 존재할테지

문제는 게임 전적이다. 게임 전적은 보통 이런거다.

|승리|패배|최다득점|
|---|---|---| 
|17|91|92030점|


게임 전적은 보통 유저들의 게임 플레이 로그를 기반으로 만들어지는 집계 개념의 데이터이다.

조회 하는 시점에 모든 로그 데이터 레코드 셋을 연산해서 표현할수도 있고, 전자의 방법이 부하가 크기 때문에 특정 시점에 배치작업으로 스냅샷을 하거나 애초에 게임이 끝날때 전적 집계를 어딘가에 저장하는 형태로 할수도 있다. 

여기서도 이미 CQRS 의 의도가 필요한 부분이 나온다. 표현 계층에서는 플레이 로그에서 전적을 집계한 형태를 화면에 노출해야한다는 비지니스 의도만 있을 뿐이다. 이를 해결하기 위해 표현 계층에서 매 순간순간 집계를 하는 형태가 된다면 데이터베이스의 부하나 유저 반응성에 문제가 생긴다. 우리는 게임 데이터가 몇 없는데요, 라고 한다면 그냥 조회 시점에 집계를 해도 된다. CQRS 는 롤과 같은 대형 게임서비스 에서의 니즈이다, 영세 SI 회사에서 CQRS 를 맞볼일은 거의 없을테지.

반대로 표현 계층에서 조회 할 때 집계한 순간순간 스냅샷해주면 되지 않을까? 생각할수도 있다. 이는 조회를 할때 캐싱해두자는 개념과 유사한데, 조회를 1달 정도 안해서 캐싱이 된게 없다면? 1달 치를 연산해서 캐싱해야한다면??? 말도 안되는 일이 생길거다.. 웹 페이지라면.. 타임아웃으로 인해서 유저는 503 에러를 볼수있을테다.  보통 이런 아이디어는 표현 계층 부서에 힘이 없는 경우 이딴 소리가 나온다.

자 그러면 이제 게임 플레이를 저장하는 곳에서 집계에 대해서도 같이 남기자가 얘기가 될수 있다. 게임 서버에서 남길지.. 아니면 별도의 배치에서 남길지는 또 그들안에서의 문제이다. 표현 계층은 집계가 된 데이터를 조회만 하면 됨으로 역활이 명확하게 구분이 되며, 유저 사용성과 데이터베이스 부하도 줄일 수 있다. 


---

기술적인 성능 이슈로도 보자

명령 계층과 조회 계층을 나누면 얻는 이점은 다양하다.

트랜잭션 관점으로 봤을 때, 명령 계층은 보통 일부에 대한 업데이트를 수행한다. 반면 조회 계층은 여러 레퍼런스 데이터를 정리해서 보여주거나 일부 필드에 대해 컨버팅이나 부수작업으로 유저에게 만족을 주는 데이터로 재가공하기도 한다.

RDB 이든 NOSQL 이든 명령 계층은 최소한의 트랜잭션을 유지해야 성능적 이점이 생긴다.

A -- B -- C 라는 스키마가 있고 이 스키마들이 표현될때에는 모두 같이 조회될수 있지만 저장에서는 A만 트랜잭션을 걸고 저장하거나 업데이트 하는 식으로 된다. A 만 저장하면 되는데 A--B--C 모두 트랜잭션을 걸어버리면 B를 조회하거나 저장하는 주체에도 영향이 간다.

표현 계층에서의 관점으로 봐도 얘기할 거리는 많다. A--B--C 라는 스키마가 있는데, A는 용량이 100기가이고, B는 1기가 C는 100메가 라고 생각해보자.

A와 B와 C 의 조인 연산을 하는 데에 비용이 어마어마하게 들것이다. 이런 경우 조회를 위해서 테이블 사이즈를 줄여야 성능이점을 꽤할수 있다. 명령 계층은 테이블 사이즈가 어떻건 간에 크게 영향을 받지 않는다. 관점의 차이가 다르다는 게 이해가 되는가?

 
 ---
 
 이러한 사례들로 보면 조회 계층과 명령 계층의 관심사가 차이가 난다는 것을 알수가 있다.
 
 CQRS 는 이러한 사례들을 해결하기 위해 조회 계층과 명령 계층 간의 분리를 꽤하자는 이야기를 하는 개념이다.
 
 즉 서로 갈길을 가야지 제 성능이 나오고 신속하게 대응할수 있다 이다.
 
 폴리그랏 데이터베이스라는 용어도 여기서 나온다. 3번쨰 사례에서 말했던 테이블 사이즈를 줄이기 위해서 조회 계층은 조회에 이점이 있는 인메모리 기반의 경량 DB 또는 샤딩이 된 NOSQL 를 사용하고 저장 계층은 RDB를 사용하는 경우가 대표적이다.
 
 위에서 잠깐 얘기헀던 이벤트 소싱에 대한 이야기는 서로 분리된 DB 간의 정합성을 어떻게 맞출것인가? 에 대한 니즈를 해결하기 위해 곁들여지는 얘기이고..
 
 

# 레퍼런스

- https://martinfowler.com/bliki/CQRS.html
