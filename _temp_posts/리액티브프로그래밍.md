APACHE 웹서버 vs  NGINX 웹서버에 대한 성능 차이는 아키텍처에서 오는 거라는 것은 누구나 알고 있다.

그 근간이 되는 리액티브 패러다임에 대해 핫해진 것도 이것이 이유이다.

전통적인 스레드 기반 다중 병렬 프로그래밍과 리액티브 프로그래밍의 차이는 사실 디테일한 부분을 제외하면 없다.

리액티브 프로그래밍을 싱글스레드로 동작하는 것으로 이해하는 사람들이 많은데 (나도 그랬다) 다중 스레드를 사용 하는 것은 다를 게 없다.

그렇다면 무엇이 리액티브 프로그래밍으로 했을 때 비약적으로 성능을 증가시킬수 있었던 것일까?

전통 블록킹 스레드 병렬 프로그래밍의 경우, 어떠한 목적을 가진 로직(또는 프로세스)가 있을 때 이 로직의 시작과 종료가 하나의 스레드에 할당이 된다.

반면, 리액티브 프로그래밍에서는 로직의 시작과 종료의 수많은 기능(함수)들이 각기 개별적으로 랜덤한 스레드에 할당이 된다.

이 차이가 무엇이냐면, 예를 들어서 아래의 경우를 보면 확연하게 차이가 난다.

환경 : 은행에 100명의 인원이 방문했고, 은행 창구는 10개 뿐이다.

전통적인 블록킹 스레드 방식 : 각 창구에서 신원 조회 (5분 대기) ->  서류 발행 (1분)  -> 업무 처리 (10분) -> 최종 완료를 모두 같은 창구에서 진행이 된다.

리액티브 프로그래밍 : 각 창구에서 신원 조회 (5분 대기 중에 다른 창구를 도와줄수 있음) -> -> 서류 발행 (1분) -> 업무 처리 (10분) -> 최종 완료는 상황에 따라서 다른 여유로운 창구에서 진행할수도 있다.

리액티브 프로그래밍은 이런 구성 탓에 CPU가 놀 틈을 주지 않는다.

매우 복잡해보이지만 매우 심플하다. 모든 것은 배열(또는 콜렉션) 과 같은 작업이라는 개념의 집합에 등록만 하면 처리가 된다.

각 스레드들은 자신의 작업이 완료되면 다음 처리해야할 작업을 작업 큐(배열)에 등록을 한다. 큐에 등록된 작업은 작업 분배자가 여유가 되는 스레드에 할당을 해준다.

재밌는 것은, 자신의 작업이 완료되어 다음 작업을 자신이 등록했는데, 자기가 일을 할수 도있다. 누가 일할지는 모른다.


