APACHE 웹서버 vs  NGINX 웹서버에 대한 성능 차이는 아키텍처에서 오는 거라는 것은 누구나 알고 있다.

그 근간이 되는 리액티브 패러다임에 대해 핫해진 것도 이것이 이유이다.

전통적인 스레드 기반 다중 병렬 프로그래밍과 리액티브 프로그래밍의 차이는 사실 디테일한 부분을 제외하면 없다.

리액티브 프로그래밍을 싱글스레드로 동작하는 것으로 이해하는 사람들이 많은데 (나도 그랬다) 다중 스레드를 사용 하는 것은 다를 게 없다.

그렇다면 무엇이 리액티브 프로그래밍으로 했을 때 비약적으로 성능을 증가시킬수 있었던 것일까?

전통 블록킹 스레드 병렬 프로그래밍의 경우, 어떠한 목적을 가진 로직(또는 프로세스)가 있을 때 이 로직의 시작과 종료가 하나의 스레드에 할당이 된다.

반면, 리액티브 프로그래밍에서는 로직의 시작과 종료의 수많은 기능(함수)들이 각기 개별적으로 랜덤한 스레드에 할당이 된다.

이 차이가 무엇이냐면, 예를 들어서 아래의 경우를 보면 확연하게 차이가 난다.

환경 : 은행에 100명의 인원이 방문했고, 은행 창구는 10개 뿐이다.

전통적인 블록킹 스레드 방식 : 각 창구에서 신원 조회 (5분 대기) ->  서류 발행 (1분)  -> 업무 처리 (10분) -> 최종 완료를 모두 같은 창구에서 진행이 된다.

리액티브 프로그래밍 : 각 창구에서 신원 조회 (5분 대기 중에 다른 창구를 도와줄수 있음) -> -> 서류 발행 (1분) -> 업무 처리 (10분) -> 최종 완료는 상황에 따라서 다른 여유로운 창구에서 진행할수도 있다.

리액티브 프로그래밍은 이런 구성 탓에 CPU가 놀 틈을 주지 않는다.

매우 복잡해보이지만 매우 심플하다. 모든 것은 배열(또는 콜렉션) 과 같은 작업이라는 개념의 집합에 등록만 하면 처리가 된다.

각 스레드들은 자신의 작업이 완료되면 다음 처리해야할 작업을 작업 큐(배열)에 등록을 한다. 큐에 등록된 작업은 작업 분배자가 여유가 되는 스레드에 할당을 해준다.

재밌는 것은, 자신의 작업이 완료되어 다음 작업을 자신이 등록했는데, 자기가 일을 할수 도있다. 누가 일할지는 모른다.

이런 방식 떄문에 리액티브 프로그래밍을 도와주는 프레임워크들을 보면, 함수 체이닝에서 .subscribe() 와 같은 구독 또는 .observing() 관찰 이라는 개념 또는 .when() .done() 어떠한 일이 ~완료되면 이라는 구문으로 기능 정의를 하는 걸 살펴볼수있다.

리액티브 프로그래밍은 디버깅이 어렵다.

그도 그럴것이 전통적인 블록 스레드 병렬 프로그래밍은 로직의 시작과 끝이 같은 스레드에서 일련의 순서대로 진행이 되기 때문에, 한 파이프라인에서 진행되었음이 가지런하게 정렬되어있다. 

반면 리액티브 프로그래밍은 기능 단위마다 이 기능이 어디 스레드에 할당될지 알수가 없다. 그렇다보니 트레이스하기가 매우 번거롭다.

하나의 서버에서 모든 일을 처리하는 모노리스 아키텍처와, 여러 서버 노드들이 기능의 조합으로 이루어진 MSA 아키텍처에서 하나의 처리 파이프라인을 비교하는 개념과 비슷하다.

MSA에서는 일련의 파이프라인을 나타내는 토큰 또는 트랜잭션Id라고 하는 파이프라인 구별자를 모든 패킷에 들고 다닌다. 

나중에 트레이스 할 때에는 모든 패킷을 다 펼쳐놓고, 트랜잭션 ID를 집계해서 같은 트랙잭션 ID이 패킷만 모아서 트레이스한다.

마찬가지로 리액티브 프로그래밍도 같은 개념이다.


---

위에 내용은 참 ㅋㅋ 초보스럽다, 너무 성능이점에서 글을 썼다.

리액티브 프로그래밍은 선언형 프로그래밍의 일종이라 할수 있다.

전통적인 명령형 프로그래밍 vs 선언형 프로그래밍의 결정적인 차이는

주저리주저리 적어가면서 하는 프로그래밍이 아니라, 어떠한 작업 이후에는 이 작업을 해줘라고 어떻게 반응할건지를 선언하는 것이 포인트이다.

반응형 프로그래밍 역시 어떠한 잡 흐름에서 어떠한 이벤트가 일어나면 이 로직이 실행되어야 한다는 선언형 스타일을 고수한다.




---

리액티브 프로그래밍

pull vs push

출처 : https://rxjs-dev.firebaseapp.com/guide/observable

리액티브 프로그래밍에서 당기기 아키텍처와 밀어주기 아키텍처 (pull vs push) 에 대한 얘기가 나오는 걸 볼수있다.

당기기는 자바의 stream 과 자바스크립트 api의 대다수 비동기 함수가 당기기에 해당한다.

푸시는 자바스크립트의 promise 와 여러 리액티브를 구현한 라이브러리에서 지워나는 개념이다.

두 개의 차이점은, 어느 시점에 데이터가 생성되느냐의 차이점이다.

당기기 모델은 구독자가 발행자에게 데이터를 요청하는 순간에, 발행자가 데이터를 생성하는 구조이다. 좀 더 로지컬하게 얘기하면 발행자의 함수를 구독자가 호출하는 시점에 호출하게 되는 개념이다.

밀어주기 모델은 발행자가 원하는 시점에 데이터를 생성한다. 데이터를 생성되는 시점에 구독자는 이에 반응(trigger) 하는 개념 이다. 로지컬하게 보면 옵저버패턴과 동일하다.

옵저버패턴과 동일해서인지 대부분 구독자는 (subscribe, observer) 로 용어를 통일하는데, 뜬금없이 Observables 과 같은 용어가 나온다. 이 Observables 은 구독자에게 데이터를 보내주는 중간 대리자이다. 즉, 발행자(Provider) 와 구독자(Subscribe,Observer,Consumer) 간의 브릿지 역활을 하는 인터페이스  Observables 이다. 

Observables 이 하는 역활은 단순히 발행자의 데이터를 구독자에게 전달해주는 역활도 있지만, 프록시 패턴처럼 흐름제어를 하는 역활도 있다. 여기서 어떠한 흐름을 제어하느냐면, 추후에 서술하겠지만 발행자의 데이터 발신이 순간적으로 너무 많이 오거나, 너무 빨리 오는 경우.. 구독자의 부담을 덜어주는 제어를 하기도 한다. 즉, 버퍼를 뜨하며.. 이걸 고급진 용어로 배압(Backpressure) 이라고 부른다.

증기기관차의 그 배압과 동일한 용어이다. 


---

Spring Webflux 와 전통적인 MVC

Spring 에서 RX를 구현한 것으로 Spring Reactor 라는 프로젝트가 있다.

Spring Webflux 는 이 Reactor 를 Web MVC API 위에 얹힌 녀석이다. 즉 리액티브 웹 프로그래밍이 가능케 한다.

전통적인 MVC 모듈과 달리 내부 CORE 아키텍쳐는 달라졌지만, 사용방법은 기존과 동일하게 어노테이션 방법으로 선언만 하면 된다.

우리가 기재한 어노테이션을 메타데이터 삼아 내부적으로 리액터 컴포넌트로 생성해서 사용되기 때문에 일어나는 마법이다.

리액티브 프로그래밍은 함수 소스(자바에서는 메소드 블록)를 공유하는 개념이다. 멀티스레딩에 최적화하기 위한 기법인데, 메소드 블록이 어떠한 context(일반적으로 스레드)에서 실행될지 최적화 담당 주체에게 맡길 뿐이다. 전통적인 MVC 모듈은 컴포넌트 블록으로 처리가 되기 때문에 스레드 번호만 알면 trace 와 같은 데에는 이슈가 없다, 다만 webflux 로 접근하게 되면 메소드 블록들이 파편화 되어 랜덤 스레드에 할당되기 때문에 trace 가 매우 어렵다.

서비스적인 이슈가 발생해서 서버 로그를 확인 할 일이 많은데, webflux 에서는 많은 고민이 발생하게 된다.

에러 역시 해당 스레드의 메소드 호출 스택에서의 예외를 trace 하는 것이기 때문에, 스레드 A에서 작업이 끝나고 이후 메소드는 스레드B에서 실행되었다면, 스레드B 가 최초의 ROOT 가 되어버린다.

Baeldung 에서는 이러한 상황에 대한 가이드를 작성했다(https://www.baeldung.com/spring-webflux-errors) 다만 수준은 서비스에 사용하기에 매우 빈약하다.

서비스 개발 담당조직에서 대부분의 이슈는 다른 부서와의 협업이 많은 데, 해당 부서에서 나의 API를 호출했을 때 이슈 발생시에 니가 잘났니 내가 잘났니 시비를 가리는 경우가 많다.

전통적인 MVC 모듈 기반의 경우 보통 타 부서에서 몇시에, 어떠한 값으로 호출했다 라고 하는 정보가 있다면, 그 해당 값을 처리한 스레드의 아규먼트를 로깅한 부분을 찾아서 이슈를 탐색하는 경우가 잦다.

조금 더 고도화를 하다보면, 로그 파일을 뒤지지 않고 바로 확인을 위해 관제 솔루션을 도입하거나, 로그 모니터링 툴을 도입할수 있다. 

이 경우 로그에 대한 확실한 추적을 용이하게 하기 위해서, Request와 Response 를 한 트랜잭션 단위로 묶을 수 있는 어떠한 Identity 를 정의하고 싶어지는 데 (조회 쿼리를 용이하게 하기 위해) 대형 공룡 기업들의 로그에 항상 딸려있는, id 필드나 logId, logSequence 등의 이름으로 불리는 개념이 이와 같다.

모든 웹 컴포넌트의 파라미터 타입을 이 id 필드를 가지고 있거나, 어떠한 상속모델로 사용해도 가능은 하다. 다만 이 경우 기존 레거시 시스템에는 적용이 어렵다는 점과 이러한 프로세스에 프로그래밍 방법이 커플링을 맺게 되는 결과가 되기 때문에 우아하지 못하다. 웹 프로젝트가 아닌 여러 프로젝트에서 사용되는 컴포넌트의 파라미터가 로그ID를 요구한다면 모양새가 이상하지 않겠는가?

다만 webflux 에서는 이러한 개념이 없기 때문에, 

THREADLOCAL 을 사용하려고 해도 스레드CONTEXT 가 계속 바뀌기 때문에 스레드로컬에 저장된 것을 얻으려고 할때에 이슈가 발생한다.

이를 극복하려고 한 InheritableThreadLocal 란 확장 개념이 있다. 시작 스레드에서 다른 스레드로 CONTEXT 가 바뀌는 경우, 기존 CONTEXT의 내용을 CLONE 하면서 넘겨주는 개념이다.

Spring Webflux 는 이를 Context 라는 이름으로 API 를 규정했다. 구족자는 .subscriberContext() 라는 메소드를  통해 ThreadLocal 과 동등한 기능을 사용할수 있다.



https://godekdls.github.io/Reactor%20Core/advancedfeaturesandconcepts/#98-adding-a-context-to-a-reactive-sequence

https://www.baeldung.com/spring-webflux-errors

https://dlsrb6342.github.io/2019/07/15/ThreadLocal-vs-InheritableThreadLocal/




