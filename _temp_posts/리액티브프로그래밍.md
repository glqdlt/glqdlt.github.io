APACHE 웹서버 vs  NGINX 웹서버에 대한 성능 차이는 아키텍처에서 오는 거라는 것은 누구나 알고 있다.

그 근간이 되는 리액티브 패러다임에 대해 핫해진 것도 이것이 이유이다.

전통적인 스레드 기반 다중 병렬 프로그래밍과 리액티브 프로그래밍의 차이는 사실 디테일한 부분을 제외하면 없다.

리액티브 프로그래밍을 싱글스레드로 동작하는 것으로 이해하는 사람들이 많은데 (나도 그랬다) 다중 스레드를 사용 하는 것은 다를 게 없다.

그렇다면 무엇이 리액티브 프로그래밍으로 했을 때 비약적으로 성능을 증가시킬수 있었던 것일까?

전통 블록킹 스레드 병렬 프로그래밍의 경우, 어떠한 목적을 가진 로직(또는 프로세스)가 있을 때 이 로직의 시작과 종료가 하나의 스레드에 할당이 된다.

반면, 리액티브 프로그래밍에서는 로직의 시작과 종료의 수많은 기능(함수)들이 각기 개별적으로 랜덤한 스레드에 할당이 된다.

이 차이가 무엇이냐면, 예를 들어서 아래의 경우를 보면 확연하게 차이가 난다.

환경 : 은행에 100명의 인원이 방문했고, 은행 창구는 10개 뿐이다.

전통적인 블록킹 스레드 방식 : 각 창구에서 신원 조회 (5분 대기) ->  서류 발행 (1분)  -> 업무 처리 (10분) -> 최종 완료를 모두 같은 창구에서 진행이 된다.

리액티브 프로그래밍 : 각 창구에서 신원 조회 (5분 대기 중에 다른 창구를 도와줄수 있음) -> -> 서류 발행 (1분) -> 업무 처리 (10분) -> 최종 완료는 상황에 따라서 다른 여유로운 창구에서 진행할수도 있다.

리액티브 프로그래밍은 이런 구성 탓에 CPU가 놀 틈을 주지 않는다.

매우 복잡해보이지만 매우 심플하다. 모든 것은 배열(또는 콜렉션) 과 같은 작업이라는 개념의 집합에 등록만 하면 처리가 된다.

각 스레드들은 자신의 작업이 완료되면 다음 처리해야할 작업을 작업 큐(배열)에 등록을 한다. 큐에 등록된 작업은 작업 분배자가 여유가 되는 스레드에 할당을 해준다.

재밌는 것은, 자신의 작업이 완료되어 다음 작업을 자신이 등록했는데, 자기가 일을 할수 도있다. 누가 일할지는 모른다.

이런 방식 떄문에 리액티브 프로그래밍을 도와주는 프레임워크들을 보면, 함수 체이닝에서 .subscribe() 와 같은 구독 또는 .observing() 관찰 이라는 개념 또는 .when() .done() 어떠한 일이 ~완료되면 이라는 구문으로 기능 정의를 하는 걸 살펴볼수있다.

리액티브 프로그래밍은 디버깅이 어렵다.

그도 그럴것이 전통적인 블록 스레드 병렬 프로그래밍은 로직의 시작과 끝이 같은 스레드에서 일련의 순서대로 진행이 되기 때문에, 한 파이프라인에서 진행되었음이 가지런하게 정렬되어있다. 

반면 리액티브 프로그래밍은 기능 단위마다 이 기능이 어디 스레드에 할당될지 알수가 없다. 그렇다보니 트레이스하기가 매우 번거롭다.

하나의 서버에서 모든 일을 처리하는 모노리스 아키텍처와, 여러 서버 노드들이 기능의 조합으로 이루어진 MSA 아키텍처에서 하나의 처리 파이프라인을 비교하는 개념과 비슷하다.

MSA에서는 일련의 파이프라인을 나타내는 토큰 또는 트랜잭션Id라고 하는 파이프라인 구별자를 모든 패킷에 들고 다닌다. 

나중에 트레이스 할 때에는 모든 패킷을 다 펼쳐놓고, 트랜잭션 ID를 집계해서 같은 트랙잭션 ID이 패킷만 모아서 트레이스한다.

마찬가지로 리액티브 프로그래밍도 같은 개념이다.


---

위에 내용은 참 ㅋㅋ 초보스럽다, 너무 성능이점에서 글을 썼다.

리액티브 프로그래밍은 선언형 프로그래밍의 일종이라 할수 있다.

전통적인 명령형 프로그래밍 vs 선언형 프로그래밍의 결정적인 차이는

주저리주저리 적어가면서 하는 프로그래밍이 아니라, 어떠한 작업 이후에는 이 작업을 해줘라고 어떻게 반응할건지를 선언하는 것이 포인트이다.

반응형 프로그래밍 역시 어떠한 잡 흐름에서 어떠한 이벤트가 일어나면 이 로직이 실행되어야 한다는 선언형 스타일을 고수한다.
