---
layout: post
title:  "JTA와 XA 트랜잭션"
author: "glqdlt"
---

일반적으로 대부분의 JDBC 를 통한 트랜잭션 단위는 단일 연결(Local Transaction)의 트랜잭션만 지원을 한다. 이게 무슨 말이냐면, 물리적으로 하나의 Database 스토리지 안에서 논리적으로 나뉘어진 여러 Database 스키마들에 대해선 연결 한 session 안에서 이루어지기 때문에 트랜잭션이 공유되는 듯이 동작 할 수 있지만, 물리적으로 분리 된(떨어 진) 데이터베이스에는 트랜잭션을 걸 수가 없다는 이유이다. [JDBC 분산 트랜잭션 참고](https://www.ibm.com/support/knowledgecenter/ko/ssw_ibm_i_73/rzaha/distrans.htm) 


물리적으로 분리 된 트랜잭션이 필요한 것은 글로벌 트랜잭션(Global Transaction)이라고 하는 데, 여러 리소스(DB 또는 스토리지, 혹은 메세지) 사이에서 처리된다하여 분산트랜잭션(Distributed Transaction) 이라고도 한다. 이 분산을 줄여서 쓴 말이 XA 트랜잭션이라고 표현한다. [RFC2372](https://tools.ietf.org/html/rfc2372), [XA spec](http://pubs.opengroup.org/onlinepubs/009680699/toc.pdf)

예를 들어서 물리적으로 떨어진 A데이터베이스와 B데이터베이스에 원자성을 지키기 위한 글로벌 트랜잭션이 필요하다고 가정을 해보자.

나의 경우에는 PC게임와 모바일 게임 간의 쿠폰을 통한 재화 지급을 한 트랜잭션에 처리해야하는 일이 있었다. 심지어 DB 벤더(MSSQL와 Mysql)도 다르고 물리적 위치도 한없이 다른 상태. -_-;;


일반적으로 단일 트랜잭션은 1PC로 동작한다. 이는 원자성에 대한 시퀀스를 나타내는 데, 흐름은 아래와 같다.

1PC (one phase commit)

```
BEGIN(시작) --> END(종료) --> COMMIT(반영)
```

다만 글로벌트랜잭션은 2PC 로 동작한다.(상황에 따라 1PC로도 진행한다.)

2PC (two phase commit)
```
BEGIN(시작) --> END(종료) --> PREPARE(준비) --> COMMIT(반영)
```

차이점은 보면 알겠듯이, 준비 단계의 생략 여부이다. 당연하겠지만 생략 된 것이 훨씬 빠르고 안정적이다. 일반적으로 JDBC 드라이버 벤더들은 1PC와 2PC 를 모두 지원하도록 개발한다. Mysql 의 경우에는 아래의 2가지 타입의 DataSourc가 준비되어 있다.

```
- com.mysql.jdbc.jdbc2.optional.MysqlXADataSource
- com.mysql.jdbc.jdbc2.optional.MysqlDataSource

```


글로벌 트랜잭션을 위한 기술로 자바에서는 [JTA](https://www.oracle.com/technetwork/java/javaee/jta/index.html) 라는 표준 스펙이 있다. JTA 는 XA 트랜잭션을 지원하는 자바 API이다. JTA 는 JavaEE 의 스펙이기에 일반적으로 WAS 제공자(Jboss 등등)에서 대부분 지원해준다. 다만, 일반적으로 많이 사용하는 Full스펙을 지원하지 않는 서블릿 컨테이너의 경우(예: 톰캣)에는 이 JTA 기능이 빠져있다.

[XA 트랜잭션]() 은 표준 트랜잭션 스펙으로, 나의 관심사는 Mssql 과 Mysql 이었다.

- [Mssql 의 경우](https://docs.microsoft.com/ko-kr/sql/connect/jdbc/understanding-xa-transactions?view=sql-server-2017)

- [Mysql 의 경우](http://www.mysqlkorea.com/sub.html?mcode=manual&scode=01&m_no=21646&cat1=13&cat2=382&cat3=413&lang=k)

Mssql의 경우에는 물리적으로만 떨어진 DB 장비끼리의 글로벌 트랜잭션을 [Ms-DTC](https://docs.microsoft.com/ko-kr/sql/database-engine/availability-groups/windows/cluster-dtc-for-sql-server-2016-availability-groups?view=sql-server-2017) 라는 기술을 지원하고 있는 데, 다른 벤더 DB와의 트랜잭션을 위한 XA 트랜잭션의 경우 이 DTC 도 활성화되어 하고, XA 옵션도 활성화 되어야 한다.

Mysql 은 특별한 설정은 없으나, InnoDB 엔진을 사용한 스키마만 지원이 가능하다.


## 스프링의 트랜잭션

대한민국에서 스프링 프레임워크를 뺸 자바프로젝트를 찾기가 어려울 정도로 많이 쓰여진다. 그 말은 스프링 프레임워크의 종속적이란 말이고 트랜잭션 역시 스프링 프레임워크의 트랜잭션을 많이 사용한다.

명시적인 방법과 선언적인 방법이 있는 데, 나는 명시적인 방법```@Transactional()``` 을 좋아하기에 어노테이션 기반으로 설명하려 한다.

아래의 코드 흐름을 보자

```java

public class pc게임서비스{

    ...

   @Transactional(transactionManager = "pcTxm")
   public void pc쿠폰보상지급(...){
        this.쿠폰조회(..);
        this.유저조회(..);
        mobile게임서비스.쿠폰보상지급(..);
   }

   @Transactional(transactionManager = "pcTxm")
   public void 쿠폰조회(...){
       ...
   }

   
   @Transactional(transactionManager = "pcTxm")
   public void 유저조회(...){
       ...
   }

}

public class mobile게임서비스{

    ...

   @Transactional(transactionManager = "mobTxm")
   public void 쿠폰보상지급(...){

   }

```

일반적으로 이런 코드를 많이 작성했을 것이다. 이 코드는 물리적으로 같이 존재하는 동일한 타입의 데이터베이스 인 경우 트랜잭션이 잘 동작한다. 3가지의 모두 어디에서 예외처리가 나더라도 



# 레퍼런스

- [https://swdev.tistory.com/4](https://swdev.tistory.com/4)

- https://soul0.tistory.com/282