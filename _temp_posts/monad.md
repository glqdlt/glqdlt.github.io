
자바의 Optional 이 flatMap() 이 존재하고, wrapping 하며, generic 처럼 반환되는 타입을 보장한다는 점 때문에 모나딕(모나드하다) 이라고들 얘기를 하더라.

처음엔 그런가보다 싶었는데, 함수형 개념을 이해하면 할수록 괴리감이 생겼다. 이해하는 함수형 프로그래밍이란 객체 자체에 일련의 변화를 주지 않고, 즉 객체 상태를 변경시키지 않은 채로

어떠한 목적이 필요할 때에만 사용할 수 있는 로지컬한 부분만 정의를 하여서, 어떠한 목적이 필요한 시점을 제어하자 (어떠한 함수를 실행할 시점을 제어) 하는 데에 의의를 두는 걸로 이해하고 있다.

객체지향 프로그래밍은 어떠한 로직이 진행되는 데에 있어서 객체의 상태를 변화시켜가며 작업하는 일련의 실행이 되어야 넘어가는 (상태가 변화되어야 하는) 패러다임이기에 기능은 항상 즉시실현되어야한다. 즉 객체의 상태를 어떻게 처리할 것인가? 에 초점을 맞춘것이 객체지향 방법이다.  객체지향에서의 함수란 메소드라고 불리우는 것이 이해가 되는 것이다. (메소드는 객체안에 존재하는 기능이며, 일반적으로 객체 자신의 속성을 변화시키는 데 사용한다.)

반면 함수형 프로그래밍은 이름 그대로 객체가 아닌, 함수가 먼저 나오는 것을 보면 연산에 대해 집중하기 때문에 값의 상태가 어떻건 말건 연산 위주로 정의를 하는 데에 목적을 두고 이 연산이 언제, 어떻게 실행시킬것인가? 연산을 어떻게 확장시킬것인가? 에 대해 관점을 둔다. 연산 자체에 초점을 두기 떄문에, 연산은 멱등성을 증명해야기 때문에 외부의 변화에 방어가 되어야 하는 함수 내부의 고유한 CONTEXT를 가지는데에 고민을 하게 된다. 외부로 부터 고유한 CONTEXT를 가지는 탓에 캡슐화 특성도 가지게 되며 또한 이런 특성으로 함수를 값으로도 취급할 수 있다. 왜냐면 함수 안에 고유한 데이터가 캡슐화되어 잘보관되고 있기 때문이다.

모나드의 쓰임새는 파이프 연산과 유사하다. 어떠한 값이 함수 체이닝을 통해 가공될 것이며, 이 가공되는 과정이 안전하게 전달되고 가공하는 함수를 연결(바인딩) 하는데에 의의를 둔다.

함수 체이닝은 함수의 연결이라는 말인데, 메소드 체이닝과 개념이 다르다. 좀 더 정확한 의미는 함수 합성이 옳은 표현이다. 객체지향으로 치면 데코레이터 패턴과 거의 유사하다. 차이가 있다면 데코레이터 패턴은 데코레이터 할 대상의 로직의 결과에 추가 작업을 하는 개념이고, 함수 합성은 데코레이터 할 대상의 로직에 추가 로직을 넣는 개념이다. 

개념적으로는 같지만 데코레이터는 의존적인 반면 함수 합성은 자유롭다. 

그런데 입력과 출력이 다른 두 함수를 어떻게 자유롭게 합성시킬수있을까? 뜬구름 잡는 소리 같다.

함수 f(number) 는 정수를 인자로 받고 함수 f2(string) 은 문자를 입력받는다.

모나드는 이러한 2함수를 연결하기 위한 일종의 아답터인 개념이다. f(monad<number>) , f2(monad<String>) 이런식으로 서로 모나드를 인자로 받고 모나드로 반환하면 연결이 가능해진다.
    
함수 합성을 위한 래핑 타입인 샘이다.

아래에서 설명하지만 모나드는 자바의 Future 처럼 사용될수도 있다.

함수합성시에 모나드를 주고받는다면 A + B 함수가 합성이 될때, A의 연산이 끝나면 B의 연산을 호출시켜줘라고 모나드가 느슨하게 연결할수도 있다.

반대로 모나드 안의 값이 아직 존재 하지 않지만 언젠간 있을거라는 Future 의 개념도 적용해볼수있다.

나는 지금 얘기한 이 부분에서 조금 더 공부가 필요하다

-----

이런 개념으로 봐서는 자바 Optional 은 모나딕하지 않다.

이유는 Optional.get() 은 이미 연산된 값이 들어가있는 것을 반환할뿐이다. 즉시냐 나중에 실행되냐의 차이가 크다.

```
public final class Optional<T> {

    public static <T> Optional<T> of(T value) {
        return new Optional<>(value);
    }
    
        private Optional(T value) {
        this.value = Objects.requireNonNull(value);
    }

    public T get() {
        if (value == null) {
            throw new NoSuchElementException("No value present");
        }
        return value;
    }
    
    public<U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper) {
        Objects.requireNonNull(mapper);
        if (!isPresent())
            return empty();
        else {
            return Objects.requireNonNull(mapper.apply(value));
        }
    }
    
}
```
flatMap은 순수하게 일련의 Optional 로 평면화를 할 뿐이다. 

참고로 평면화란 ["a", ["b","c"], ["d",["e","f"]]]  이러한 복잡한 집합 엔트리를 단순하게 ["a","b","c","d","e","f"]  이런식으로 특정 목적의 균일한 요소로 평탄화하는 것을 의미한다.

아래는 실제로 내가 흉내내본 모나딕한 자료구조이다.

```
  public class MyMonad<T> {
        private T value;

        private Function<T, T> binder;

        public MyMonad(T value, Function<T, T> binder) {
            this.value = value;
            this.binder = binder;
        }

        public T getValue() {
            return binder.apply(value);
        }
    }
```

값의 원형에 매핑되는 바인더는 실제 getValue()를 호출하는 시점에 실행이 된다.

Optional과 사뭇 느낌이 다르다.
