---
layout: post
title:  "객체지향 위키"
author: "glqdlt"
---

## 상속과 위임

상속과 위임은 클래스다이어그램에서 일반화 단계에서 많이 마주하게 되는 개념이다.

### 상속(inheritance)

상속을 표현한 클래스 다이어그램은 아래와 같다.

상속은 클래스 사이의 관계를 표현한다. 클래스는 정적이다, 상속 역시 정적인 다이어그램이다.


<img src="http://www.plantuml.com/plantuml/uml/Iyv9B2vMSCpBp4tCuU9A1lDSyjEXBEV44YukYAI2JOskBbWAcGzM0000"/>

### 위임 패턴 (Delegation Pattern)

맡긴다는 의미의 위임 패턴은, 사용자가 외부 인스턴스를 직접 생성해 강한 커플링으로 가지는 패턴이다. (uml 에서 색이 칠해진다.) 집합 관계에서 합성composition(색이 칠해짐) 와 집약 aggregation(색이 없음 : 흰색) 2가지로 나뉘는 데, 합성과 집합의 가장 큰 차이점은 외부 인스턴스 생성을 사용자 자기 자신이 하거나 외부에서 주입받는 지의 차이점이 있다. 


- 의존관계

    내부의 기능이 외부의 인스턴스의 기능을 사용해서 처리하게 되는 경우를 의존한다고 표현한다.

- 집합관계

    집합 관계는 외부 객체를 자신의 속성으로 의존하는 경우를 말한다.

    - 합성(composition) : 외부 인스턴스를 집합하는 속성을 자기 스스로가 직접 생성해서 사용한다. 강한 커플링을 가진다.
    - 집약(aggregation) : 외부 인스턴스를 집합하는 속성을 외부에서 생성된 것을 주입받아 사용한다. 느슨한 커플링을 가진다.

위임 패턴에서는 composition 을 사용하고 있다. 자바로 배우는 리팩토링 임문에서는 이를 contains 라고 표현하고 있다.

사용자의 기능을 외부의 기능을 호출하기 위해 외부 인스턴스를 사용자가 포함할 때를 위임이라고 표현한다. 위임은 클래스처럼 정적이지 않고 동적이다, 이유는 런타임 시점 이후에 바뀔 수 있기 때문이다. 

- 집합관계 vs 의존관계

위의 의존관계와 집합 관계가 외부의 기능을 참조한다는 것에 비슷해보이지만, 집합 관계는 의존되는 외부 객체를 자기 속성을 가지고, 의존 관계는 기능 사용시에만 외부 객체를 넘겨받아 호출하는 차이점이 있다. 즉 집합관계에서는 외부 의존도가 객체의 생성부터 소멸까지 계속 의존되는 형태이고, 의존관계는 실제 기능이 사용될 때에만 의존하게 되는 라이프사이클 차이가 있다.

<img src="http://www.plantuml.com/plantuml/uml/Iyv9B2vM2CXCJapEAAtcKW02xSIIaiJaR0rDhbekhcIml5TcU7u-H5Qt0ABM2ge7LKirL5OF9c1T2p85h5z1IrSNPXCN0000"/>



## 패키지(모듈) 의 구성은 어떻게 해야할까?

패키지 구성과 구조에 관해서는 정답은 없다. 이에 한해서는 각 도메인마다 특색에 맞추어서 작업하기를 대부분 권고를 한다.

따로 체계가 없는 한국식 SI 개발들을 보면 무의식적으로 컨트롤러는 컨트롤러에 서비스는 서비스에 영속성은 영속성이나 dao 란 이름하에 구조를 잡는 걸 많이 볼 수 있다. 예를 들면 아래와 같다.

- application
    - service
        - user
    - controller
        - user
    - dao
        - user

user 라는 기능을 각 컴포넌트 성격 별로 구조를 잡아 나누어져 있다. 이럴 경우 장점은 컨트롤러는 컨트롤러에 대해서 

### 자바 접근제어지시 중 protected 와 default 에 대한 견해

protected 와 default 는 접근 제어자들 중에서 같은 패키지 내에 존재하면 접근을 허용하는 지시자이다. com.glqdlt.a 이면, com.glqdlt.a 안에 있는 클래스들은 모두 접근이 가능하다. 
예를 들어 아래의 ```SimepleClass``` 가 있다고 가정을 해보자. 아래 클래스는 field 라는 객체 멤버 변수가 있는 데, 접근 지시자는 default 로 선언되어 있다.

```java
package com.glqdlt.a;

public class SimpleClass{
    int field;
}

```
default 접근 제어시의 패키지 접근 정책

대상: com.glqdlt.a.SimpleClass 의 field 에 접근
|클래스|접근가능|
|---|---|
|com.glqdlt.a.Simple2Class|o|
|com.glqdlt.a.b.BClass|x|
|com.glqdlt.HighClass|x|

default 와 protected 에서 같은 패키지에서 접근은 무조건 같은 패키지 명에서만 접근할 수가 있다.

그런데 만약 아래의 경우면 어떻게 될까?

대상: com.glqdlt.a.SimpleClass 의 field 에 접근
|만든사람|아티팩트|클래스|접근가능|
|---|---|---|---|
|glqdlt|glqdlt-my-java.jar|com.glqdlt.a.Simple2Class|o|
|superman|superman-java.jar|com.glqdlt.a.HaHaClass|o|

우연찮게 superman 이 만든 자바 어플리케이션의 패키지가 동일한 클래스가 있었다면 SimpleClass 로의 접근이 가능하다. 즉, 단순하게 package 명이 똑같으냐 안 똑같으냐로만 접근 지시를 허용하기 때문이다. (이 부분은 자바의 패키지가 대격변이 된 자바9의 직소에서도 고쳐지지 않은 부분이다. 자바9 직소에 대한 것은 [Project Jigsaw](http://openjdk.java.net/projects/jigsaw/) 공식 문서에서 확인하길 바란다.) 근데 사실 위의 예시는 거의 일어나기 어렵다. 왜냐면 같은 도메인에 속하지 않은 사람이 같은 도메인일 경우는 거의 희박하기 때문이다. 위 사례인 superman 의 경우라면 com.superman.a.HaHaClass 가 일반적 관점에서 정상적인 패키지명이라 볼 수가 있다.