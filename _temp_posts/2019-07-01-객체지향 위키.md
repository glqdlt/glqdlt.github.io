---
layout: post
title:  "객체지향 위키"
author: "glqdlt"
---

## 상속과 위임

상속과 위임은 클래스다이어그램에서 일반화 단계에서 많이 마주하게 되는 개념이다.

### 상속(inheritance)

상속을 표현한 클래스 다이어그램은 아래와 같다.

상속은 클래스 사이의 관계를 표현한다. 클래스는 정적이다, 상속 역시 정적인 다이어그램이다.


<img src="http://www.plantuml.com/plantuml/uml/Iyv9B2vMSCpBp4tCuU9A1lDSyjEXBEV44YukYAI2JOskBbWAcGzM0000"/>

### 위임 패턴 (Delegation Pattern)

맡긴다는 의미의 위임 패턴은, 사용자가 외부 인스턴스를 직접 생성해 강한 커플링으로 가지는 패턴이다. (uml 에서 색이 칠해진다.) 집합 관계에서 합성composition(색이 칠해짐) 와 집약 aggregation(색이 없음 : 흰색) 2가지로 나뉘는 데, 합성과 집합의 가장 큰 차이점은 외부 인스턴스 생성을 사용자 자기 자신이 하거나 외부에서 주입받는 지의 차이점이 있다. 


- 의존관계

    내부의 기능이 외부의 인스턴스의 기능을 사용해서 처리하게 되는 경우를 의존한다고 표현한다.

- 집합관계

    집합 관계는 외부 객체를 자신의 속성으로 의존하는 경우를 말한다.

    - 합성(composition) : 외부 인스턴스를 집합하는 속성을 자기 스스로가 직접 생성해서 사용한다. 강한 커플링을 가진다.
    - 집약(aggregation) : 외부 인스턴스를 집합하는 속성을 외부에서 생성된 것을 주입받아 사용한다. 느슨한 커플링을 가진다.

위임 패턴에서는 composition 을 사용하고 있다. 자바로 배우는 리팩토링 임문에서는 이를 contains 라고 표현하고 있다.

사용자의 기능을 외부의 기능을 호출하기 위해 외부 인스턴스를 사용자가 포함할 때를 위임이라고 표현한다. 위임은 클래스처럼 정적이지 않고 동적이다, 이유는 런타임 시점 이후에 바뀔 수 있기 때문이다. 

- 집합관계 vs 의존관계

위의 의존관계와 집합 관계가 외부의 기능을 참조한다는 것에 비슷해보이지만, 집합 관계는 의존되는 외부 객체를 자기 속성을 가지고, 의존 관계는 기능 사용시에만 외부 객체를 넘겨받아 호출하는 차이점이 있다. 즉 집합관계에서는 외부 의존도가 객체의 생성부터 소멸까지 계속 의존되는 형태이고, 의존관계는 실제 기능이 사용될 때에만 의존하게 되는 라이프사이클 차이가 있다.

<img src="http://www.plantuml.com/plantuml/uml/Iyv9B2vM2CXCJapEAAtcKW02xSIIaiJaR0rDhbekhcIml5TcU7u-H5Qt0ABM2ge7LKirL5OF9c1T2p85h5z1IrSNPXCN0000"/>



## 패키지(모듈) 의 구성은 어떻게 해야할까?

패키지 구성과 구조에 관해서는 정답은 없다. 이에 한해서는 각 도메인마다 특색에 맞추어서 작업하기를 대부분 권고를 한다.

따로 체계가 없는 한국식 SI 개발들을 보면 무의식적으로 컨트롤러는 컨트롤러에 서비스는 서비스에 영속성은 영속성이나 dao 란 이름하에 구조를 잡는 걸 많이 볼 수 있다. 예를 들면 아래와 같다.

- application
    - service
        - user
    - controller
        - user
    - dao
        - user

user 라는 기능을 각 컴포넌트 성격 별로 구조를 잡아 나누어져 있다. 이럴 경우 장점은 컨트롤러는 컨트롤러에 대해서 

### 자바 접근제어지시 중 protected 와 default 에 대한 견해

protected 와 default 는 접근 제어자들 중에서 같은 패키지 내에 존재하면 접근을 허용하는 지시자이다. com.glqdlt.a 이면, com.glqdlt.a 안에 있는 클래스들은 모두 접근이 가능하다. 
예를 들어 아래의 ```SimepleClass``` 가 있다고 가정을 해보자. 아래 클래스는 field 라는 객체 멤버 변수가 있는 데, 접근 지시자는 default 로 선언되어 있다.

```java
package com.glqdlt.a;

public class SimpleClass{
    int field;
}

```
default 접근 제어시의 패키지 접근 정책

대상: com.glqdlt.a.SimpleClass 의 field 에 접근
|클래스|접근가능|
|---|---|
|com.glqdlt.a.Simple2Class|o|
|com.glqdlt.a.b.BClass|x|
|com.glqdlt.HighClass|x|

default 와 protected 에서 같은 패키지에서 접근은 무조건 같은 패키지 명에서만 접근할 수가 있다.

그런데 만약 아래의 경우면 어떻게 될까?

대상: com.glqdlt.a.SimpleClass 의 field 에 접근
|만든사람|아티팩트|클래스|접근가능|
|---|---|---|---|
|glqdlt|glqdlt-my-java.jar|com.glqdlt.a.Simple2Class|o|
|superman|superman-java.jar|com.glqdlt.a.HaHaClass|o|

우연찮게 superman 이 만든 자바 어플리케이션의 패키지가 동일한 클래스가 있었다면 SimpleClass 로의 접근이 가능하다. 즉, 단순하게 package 명이 똑같으냐 안 똑같으냐로만 접근 지시를 허용하기 때문이다. (이 부분은 자바의 패키지가 대격변이 된 자바9의 직소에서도 고쳐지지 않은 부분이다. 자바9 직소에 대한 것은 [Project Jigsaw](http://openjdk.java.net/projects/jigsaw/) 공식 문서에서 확인하길 바란다.) 근데 사실 위의 예시는 거의 일어나기 어렵다. 왜냐면 같은 도메인에 속하지 않은 사람이 같은 도메인일 경우는 거의 희박하기 때문이다. 위 사례인 superman 의 경우라면 com.superman.a.HaHaClass 가 일반적 관점에서 정상적인 패키지명이라 볼 수가 있다.



## abstract 와 interface 를 바로 구현하면 어떤 타입일까?

```java
public class SimpleStaticLoaderTest {

    public static void main(String[] args) {
        System.out.println("start application.");
        SimpleStaticLoader loader1 = new SimpleStaticLoader("loader1");
        SimpleStaticLoader loader2 = new SimpleStaticLoader("loader2");
        loader1.echo();
        loader2.echo();
        System.out.println("end application");
    }

    @Test
    public void name() {
        SimpleAbstractClass simpleAbstractClass = new SimpleAbstractClass() {
            @Override
            public void echo() {
                System.out.println("hi");
            }
        };
        System.out.println(simpleAbstractClass.getClass().getName());

        SimpleInterface simpleInterface = new SimpleInterface() {
            @Override
            public void echo() {
                System.out.println("oo");
            }
        };
        System.out.println(simpleInterface.getClass().getName());

        SimpleInterface simpleInterface2 = () -> System.out.println("oo");
        System.out.println(simpleInterface2.getClass().getName());

        SimpleAbstractClassImpl simpleAbstractClassImpl = new SimpleAbstractClassImpl();
        System.out.println(simpleAbstractClassImpl.getClass().getName());
    }

    /**
     * inner interface 는 암묵적으로 static 이다. 또한 inner enum 또한 암묵적으로 static 이다.
     * @see <a href='https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.5.1'>https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.5.1</a>
     */
    public interface SimpleInterface {
        void echo();
    }

    public class SimpleAbstractClassImpl extends SimpleAbstractClass {
        @Override
        public void echo() {
            System.out.println("Hello");
        }
    }

    public static abstract class SimpleAbstractClass {
        public abstract void echo();
    }
}

```

위 소스를 실행했을 때에는 아래의 결과가 나온다.

```
com.glqdlt.SimpleStaticLoaderTest$1
com.glqdlt.SimpleStaticLoaderTest$2
com.glqdlt.SimpleStaticLoaderTest$$Lambda$1/317983781
com.glqdlt.SimpleStaticLoaderTest$SimpleAbstractClassImpl
```

abstract 클래스와 인터페이스를 객체 생성하는 시점에 구현을 해버리면 익명 객체로 생성이 된다. 그래서 getClass.getName() 을 호출하면 특정한 타입이 아닌 익명 객체로 나오게 된다. 반면 class 에서 상속이나 구현을 해서 class 레퍼런스가 존재하는 SimplAbstractClassImpl 에 대해서는 명확하게 레퍼런스 이름이 나타난다. 1 과 2가 뜻하는 것은 생성을 누가 빨리 했냐의 정도의 시퀀스 정도의 의미를 가진다. 재밌는 것은 java8 에서 @FunctionalInterface 가 도입이 되면서 new 키워드로 생성하지 않고 람다식으로 생성하면 익명 함수 취급을 하기 때문에 claaType 이 익명 함수라는 키워드인 Lambda 가 붙는 걸 볼 수 있다. 

재밌는 것이 하나 더 있는 데, inner class 는 static 을 붙여줘야 외부에서 접근할 수 있는 반면 interface 는 inner class 이더라도 static 이 필요없다. static 은 클래스의 멤버 유형을 나타내는 의미이다. 자바8 이전까지는 method area(static area) 에 보관되었었지만, 자바8 이후는 heap area 에 저장되는 것으로 바뀌었다. 이는 무분별하게 static 키워드를 사용하면서 동적으로 관리되는 heap area 가 아닌 메모리 용량이 고정인 static area 에서 메모리 부족 에러를 자주 상기시니 관련해서 처리한 것이다. 자세한 것은 [JVM T메모리 구조](#) 포스트를 참고하라.

## static 블록과 그냥 블록의 차이점은?

static 블록은 클래스가 로드 되는 시점에 한번만 실행이 된다. 반면 비 static (일반 또는 객체 블록) 블록은 객체가 생성되는 최초 시점에 실행이 된다. 객체 블록 선언은 생성자가 호출되는 시점에 실행이 되기 때문에 생성자가 끝나는 시점에 호출되는 내부 메소드 ```competedObject();``` 보다 더 빠르게 콘솔에 데이터가 찍히는 걸 볼 수가 있다.

```java
/**
 * @author Jhun
 * 2019-08-02
 */
public class SimpleStaticLoader {

    private String name;

    /**
     * @see <a href='https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.6'>https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.6</a>
     */
    {
        System.out.println("This Object has been load into the 'heap area'.");
    }

    /**
     * @see <a href='https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.7'>https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.7</a>
     */
    static {
        System.out.println("The class has been load into the 'class area'.");
    }

    public SimpleStaticLoader(String name) {
        this.name = name;
        competedObject();
    }

    public void competedObject(){
        System.out.println("This Object Created!");
    }
    public void echo() {
        System.out.println(String.format("My Name is ! %s", this.name));
    }
}

```

## 응집도(cohesion)와 결합도(coupling)

보통 응집도는 높이고 결합도는 낮추라는 말을 많이 들었을 것이다. 여기서 응집도는 무엇이며 결합도는 무엇일까?

- 응집도(cohesion)

    특정 로직에 대한 책임이 한점으로 모이는 것을 의미 한다. 개별적으로 똑같은 로직을 각각 작성하는 것이 아니라, 하나의 context (클래스나 함수, 포괄적으로 모듈이나 라이브러리로 봐도 무관) 에 위임하고 그를 호출해서 사용하는 것이다. 
    어떻게 보면 DRY(dont repeat yourself) 패턴을 제거하는 것으로 이해하면 쉽게 접근할 수도 있다.

- 결합도(coupling)

    응집도에서 조금 더 확장되는 내용이다. 기능 사용자와 기능 제공자를 분리할 수 있어야 한다는 의미이다. 결합도가 높은 것과 낮은 것에 대한 예시를 통해 이해할 수 있다.

    - 결합도가 높다 
        
        사용자 A 는 기능 제공자 A에게서만 기능을 사용할 수 있다. 

    - 결합도가 낮다

        사용자 A는 기능 제공자 A 외에도 B,C,D,E 누구든지 교체할 수 있다.

    결합도에 가장 밀접한 디자인 패턴이라면 전략(stragy) 패턴을 꼽아볼 수 있다.

