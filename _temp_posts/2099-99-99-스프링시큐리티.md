---
layout: post
title:  "스프링 시큐리티"
author: "glqdlt"
---

기존 회사 소스 중에 스프링 시큐리티의 hasRole 에 값이 없는 걸 확인했다.


문제는 일반적으로 (개인적 경험으로) 접근 권한에 대해서 hasRole()로 'ROLE_USER,ROLE_ADMIN' 과 같은 정책을 많이 썼었다.


아래 코드에서 DB에 있는 권한을 메모리에 올리는 과정이 있다.


```java
    @Override
    public List<GrantedAuthority> extractAuthorities(Map<String, Object> map) {
        String authorities = "ROLE_USER";
        if (map.containsKey(AUTHORITIES)) {
            authorities = asAuthorities(map.get(AUTHORITIES));
        }
        return AuthorityUtils.commaSeparatedStringToAuthorityList(authorities);
    }

    private String asAuthorities(Object object) {
        List<Object> authorities = new ArrayList<Object>();
        if (object instanceof Collection) {
            Collection<?> collection = (Collection<?>) object;
            object = collection.toArray(new Object[0]);
        }
        if (ObjectUtils.isArray(object)) {
            Object[] array = (Object[]) object;
            for (Object value : array) {
                if (value instanceof String) {
                    authorities.add(value);
                }
                else if (value instanceof Map) {
                    authorities.add(asAuthority((Map<?, ?>) value));
                }
                else {
                    authorities.add(value);
                }
            }
            return StringUtils.collectionToCommaDelimitedString(authorities);
        }
        return object.toString();
    }

    private Object asAuthority(Map<?, ?> map) {
        if (map.size() == 1) {
            return map.values().iterator().next();
        }
        for (String key : AUTHORITY_KEYS) {
            if (map.containsKey(key)) {
                return map.get(key);
            }
        }
        return map;
    }


```

hasRole()을 때려도 데이터를 못가져오길래, 한번 뒤져봤다.

```java

ExpressionUrlAuthorizationConfigurer.class

...

  private static String hasAnyAuthority(String... authorities) {
        String anyAuthorities = StringUtils.arrayToDelimitedString(authorities, "','");
        return "hasAnyAuthority('" + anyAuthorities + "')";
    }

...

 private static String hasRole(String role) {
        Assert.notNull(role, "role cannot be null");
        if (role.startsWith("ROLE_")) {
            throw new IllegalArgumentException("role should not start with 'ROLE_' since it is automatically inserted. Got '" + role + "'");
        } else {
            return "hasRole('ROLE_" + role + "')";
        }
    }

```

보면 2개가 다르게 동작하고 있고, 보관하는 주소(key)도 다른 것을 알았다.

그래서 구글링 해보았더니, 좋은 레퍼런스가 있었다. [레퍼런스](https://www.baeldung.com/role-and-privilege-for-spring-security-registration)

> spring security authority vs role ?


    the User
    the Role – this represents the high-level roles of the user in the system; each role will have a set of low-level privileges
    the Privilege – represents a low-level, granular privilege/authority in the system


라고 하는 데, 조금 알것 같다.. 나름대로 해석해보았다.

- 사용자(User)

말 그대로 사용자

- 역할(Role) -이 시스템에서 사용자의 높은 수준의 역할을 나타냅니다; 각 역할에는 하위 수준  권한 집합이 있습니다.

서비스의 계층 별 접근가능한 신분을 나타낸다. 예를 들면 ROLE_ADMIN 이면 관리자 기능의 페이지에 접근가능할 테고, ROLE_GUEST 이면 둘러보기 기능만 접근할 수 있다던지 말이다.

- 특권(privilege/authority) - 시스템에서 낮은 수준의 세분화 된 권한 / 권한을 나타냅니다

계층 별로 수행할 수 있는 펑션에 대해 이야기한다. 대부분 'read', 'write', 'delete', 이런 식의 CRUD를 의미하는 듯.







조금 더 관찰력이 좋았다면, Authority 에 값을 넣는 걸 파악할 수 있었을 텐데 기초가 부족해서 놓치고 말았다.





프리마커 템플릿에서도 ```<@security.authorize access=hasRole(...)``` 이나 ```<@security.authorize access=hasAuthority(...)```와 같이 구문을 선언해서 사용할 수 있다.


