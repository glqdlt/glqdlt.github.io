---
layout: post
title:  "자바8과 스트림"
author: "glqdlt"
---
자바8 과 스트림


아래코드는 테스트에 사용할 픽스처를 만드는 셋업 메소드이다.
클래스 명을 보면 알겠지만, 게임머니 관련 된 로그인데, 집계하는 로직을 위한 픽스처이다.

1을 시작으로 총 10000000번의 리스트를 생성하는 로직인데, 기본 스트림으로 할 경우 이는 ```16s 353ms``` 결과가 나온다, 어림잡아 말하면 17초쯤이라 보면 될듯. 
```java
 @Before
    public void setUp() throws Exception {

        final Integer i1 = 10;
        final Integer i2 = 2000;
        this.fixture =
                IntStream.rangeClosed(1, 10000000)
                        .boxed()
                        .map(x -> {
                            Log log = new LogGameMoney();
                            log.setSeq((long) x);
                            log.setFrom((x % 2 == 0 ? null : "B_CN"));
                            log.setTo((x % 3 == 0 ? "PID1" : "PID2"));
                            log.setChangeAmount((x % 3 == 0 ? 1000L : 200L));

                            Long current = log.getChangeAmount();
                            log.setFeeMinusChangeAmount(current - ((long) (current * 0.03)));
                            log.setBeforeChangeAmount(0L);
                            log.setCurrentAmount(log.getFeeMinusChangeAmount() + log.getBeforeChangeAmount());
                            log.setRemoteIp("127.0.0.1");
                            log.setRoute(ExchangeRoute.PC_TO_MOB);
                            log.setWorkStatus(((x % 7 != 0)));
                            log.setRegDate(DateUtils.asDate(LocalDateTime.of(2011, 1, 1, 1, 1).plusMinutes(x * 2)));

                            return log;
                        }).collect(Collectors.toList());

        this.queryResponse = this.fixture.stream()
                .filter(ExchangeLog::getWorkStatus)
                .filter(x -> {
                    Long a = x.getChangeAmount();
                    return (a >= i1 && a <= i2);
                })
                .collect(Collectors.toList());

    }
```

반면 아래처럼 ```.parallel()``` 메소드를 호출해서 병렬 스트림으로 전환시키고 난 이후의 결과는.. 놀랍게도 ```10s 685ms``` 걸린다. 기존 17초에서 11초로 대략 30% 정도의 좋은 퍼포먼스가 나왔다.


```java
 @Before
    public void setUp() throws Exception {

        final Integer i1 = 10;
        final Integer i2 = 2000;
        this.fixture =
                IntStream.rangeClosed(1, 10000000)
// 병렬 스트림으로 전환
                        .parallel()

                        .boxed()
                        .map(x -> {
                            Log log = new LogGameMoney();
                            log.setSeq((long) x);
                            log.setFrom((x % 2 == 0 ? null : "B_CN"));
                            log.setTo((x % 3 == 0 ? "PID1" : "PID2"));
                            log.setChangeAmount((x % 3 == 0 ? 1000L : 200L));

                            Long current = log.getChangeAmount();
                            log.setFeeMinusChangeAmount(current - ((long) (current * 0.03)));
                            log.setBeforeChangeAmount(0L);
                            log.setCurrentAmount(log.getFeeMinusChangeAmount() + log.getBeforeChangeAmount());
                            log.setRemoteIp("127.0.0.1");
                            log.setRoute(ExchangeRoute.PC_TO_MOB);
                            log.setWorkStatus(((x % 7 != 0)));
                            log.setRegDate(DateUtils.asDate(LocalDateTime.of(2011, 1, 1, 1, 1).plusMinutes(x * 2)));

                            return log;
                        }).collect(Collectors.toList());

        this.queryResponse = this.fixture.stream()
                .filter(ExchangeLog::getWorkStatus)
                .filter(x -> {
                    Long a = x.getChangeAmount();
                    return (a >= i1 && a <= i2);
                })
                .collect(Collectors.toList());

    }
```

parallel 시의 스레드 수는 방법이 2개가 있다. 

1. 시스템 프로퍼티 값 수정

```java
System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism","6");
```

2. 직접 ForkJoinPool 을 생성해서 사용

위 처럼 ```ForkJoinPool``` 기본 구현체의 프로퍼티를 변경해서 사용하지 않고, 아래처럼 ForkJoinPool 인스턴스를 직접 만들어서 설정할수도 있다.

```java
ForkJoinPool forkjoinPool = new ForkJoinPool(5);
forkjoinPool.submit(() -> {
	someArr.parallelStream().forEach(System.out::println);
}).get();
```


## 레퍼런스

- [티몬 블로그](http://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220945933678)

- [baeldung](https://www.baeldung.com/java-groupingby-collector)