---
layout: post
title:  "자바 제네릭의 이해"
author: "glqdlt"
---

자바 제네릭은 잘못 디자인 되기로 많이 유명하다. 특히 C# 에서는 인터페이스를 구현한 익명 클래스 (자바8의 Functional Interface 의 구동 원리) 를 통한 함수형 처리와 함께 제네릭을 엄청나게 깐다. 자바 개발자인 나 역시 실무를 하다 보면 자바 제네릭이 매우 비논리적인 모습을 보곤 욕하기도 한다. 주로 하는 욕은 아래와 같다.

아래와 같은 객체들이 있다고 하자.


```java
public interface Animal {
    void walk();

    public static class Dog implements Animal {

        @Override
        public void walk() {
            System.out.println("dog is walk");
        }

        public void balk() {
            System.out.println("bow wow");
        }
    }

    public static class Cat implements Animal {

        @Override
        public void walk() {
            System.out.println("cat is walk");
        }
    }

    public static class Sparrow implements Animal,Bird{

        @Override
        public void walk() {
            System.out.println("Sparrow is walk");
        }

        @Override
        public void fly() {
            System.out.println("Fly~~");
        }
    }
}


```

Animal 이라는 슈퍼 타입을 구현하는 Cat과 Dog 가 있다. (물론 새인 Sparow 도 있다.)

자 여기서 아래의 코드를 테스트해보면 놀라운 일이 벌어질 것이다.

```java

    @Test
    public void name2() {
        List<Animal.Dog> dog = new ArrayList<>();
        List<Animal.Cat> cat = new ArrayList<>();

        Assert.assertSame(dog, dog);

        Assert.assertSame(dog, cat);

    }

```

dog와 dog 의 비교에서는 성공한다. 반면, dog 와 cat 의 비교에서는 실패한다. dog 와 cat 은 Animal 을 슈퍼 타입으로 가지는 구현체들이다. 왜 Dog와 Cat 이 같다고 생각하지 않는걸까?

이유는 이러하다. 자바의 제네릭에서는 위 비교문을 아래처럼 비교한다.

```
List<Dog> == List<Cat>
```

'Dog 형 List 객체'와 'Cat 형 List 객체'가 같은 지를 물어본다.  즉, List 자료형을 비교하는 꼴이다.


## 자바 제네릭에서 와일드카드의 의미


<T extends SuperType> 과 <? extends SuperType> 의 차이점에 대해 얘기해보려한다.

<T extends SuperType> 는 SuperType 을 상속 또는 구현하는 하위 클래스가 들어올 것이라고 명시한 것이며, <? extends SuperType> 또한 SuperType 을 상속 또는 구현하는 어떠한 하위 클래스가 들어올 것이라고 명시한다. 억양의 차이는 있지만 의미하는 바는 똑같다.

아래의 코드는 똑같이 동작하며, 작성 문법만 다를 뿐이다.

```java
    public <T extends Animal> void generic(List<T> list) {
        ...

    }
    public void wildcard(List<? extends Animal> list) {
        ...
    }

```

그렇다면 <T extends SupertType> 과 <? extends SuperType> 은 왜 존재하는 걸까?

각각의 쓰임새가 미묘하게 다른 구간이 있기 때문이다.

<T extends SupertType> 과 <? extends SuperType> 은 큰 차이점은 와일드카드의 경우 return 형(타입) 과 복수의 파라미터에 특정 형(타입)을 강제화하지 못한다.

예를 들면 아래와 같다.

```java
    public <T extends Animal> List<T> generic(List<T> list, List<T> list2, T t) {
    
        ...

        return new ArrayList<>();

    }
```

<T extends SuperType>을 사용한 위 코드처럼 Animal 을 구현, 상속하는 하나의 형을 강제화하고 싶을 때에는 와일드카드를 사용하면 안 된다. 


```java
    public List<Animal> generic(List<? extend Animal> list, List<? extend Animal> list2, Animal t) {
    
        ...
        return new ArrayList<>();

    }
```

위의 경우에는 list 와 list2가 같은 자료 형일 것이라는 걸 보장할 수가 없다. list 가 List<Animal.Dog> 이고, list2 가 List<Animal.Cat> 일 수 있기 때문이다. 심지어 Animal t는 Animal.Sparrow t 일 수도 있다. return 역시 어떠한 형(타입)이 반환될지 알수가 없다. 