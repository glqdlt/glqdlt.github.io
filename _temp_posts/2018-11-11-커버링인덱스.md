---
layout: post
title:  "커버링인덱스"
author: "glqdlt"
comments : true
---


복합 인덱스(userID+RegDate)와 단일 인덱스(RegDate) 의 차이가 심하다
단일 인덱스는 속도가 나오는 반면에.. 복합인덱스는 느리다. 

### 단일 인덱싱에 커버링 인덱스 미적용

```sql
select * from tb_money where RegDate >= '2018-10-01 00:00:00' and RegDate <= '2018-10-02 00:00:00' limit 100
```
/* 영향 받은 행: 0  찾은 행: 100  경고: 0  지속 시간 1 쿼리: 0.125 sec. */


### 단일인덱싱에 커버링인덱스 적용 시에

```sql
select a.* from (select Seq from tb_money where RegDate >= '2018-10-01 00:00:00' and RegDate <= '2018-10-02 00:00:00' limit 100) b join tb_money a on b.Seq = a.Seq
```

/* 영향 받은 행: 0  찾은 행: 100  경고: 0  지속 시간 1 쿼리: 0.109 sec. */



### 복합인덱싱에 커버링 인덱스 미적용
```sql
select Seq from tb_coin where RegDate >= '2018-10-01 00:00:00' and RegDate <= '2018-10-02 00:00:00' limit 100
```
/* 측정불가 */

### 복합인덱싱에 커버링 인덱스 적용시에

```sql
select a.* from (select Seq from tb_coin where RegDate >= '2018-10-01 00:00:00' and RegDate <= '2018-10-02 00:00:00' limit 100) b join tb_coin a on b.Seq = a.Seq
```

/* 영향 받은 행: 0  찾은 행: 100  경고: 0  지속 시간 1 쿼리: 0.078 sec. */



### jpql 로 했을 때에.. subquery 를 어떻게 한담 --;
```java
    @Query("select a from coin a where a.seq in (select b.seq From coin b where b.regDate between :since and :until)")
    Page<coin> findAllByRegDateSubquery(@Param("since") Date since,@Param("until") Date until, Pageable page);
```
이렇게 하면 될줄알았다..
그러나 결과는 limit 이 밖에서 걸려서 ㅡㅡ; 풀스캐닝 되기 때문에 의미가없다

select coin0_.Seq as Seq1_22_, coin0_.aCompe as aCompe2_22_, coin0_.bCompe as bCompe3_22_, coin0_.Compe as Compe4_22_, coin0_.ID as ID5_22_, coin0_.MenuId as MenuId6_22_, coin0_.PlayerID as PlayerID7_22_, coin0_.RegDate as RegDate8_22_ from mpoker_datadb.tb_coin coin0_ where coin0_.Seq in (select coin1_.Seq from mpoker_datadb.tb_coin coin1_ where coin1_.RegDate between ? and ?) limit ?



subquery 안에서 limit 이 걸려야한다. 음..

현재까지는 jpa 에서 공식적으로 jpql 로 subquery 안에서 limit 이 걸리게는 지원을 안하고 있다 ㅅㅂ

거기다가 jpql 문에서 LIMIT 이라는 키워드 자체가 없다 ㅡㅡ; ㅅㅂ


jpa 로 할 때에는 queryBuilder 를 만들어야한다.
https://code.i-harness.com/ko-kr/q/4469f8

```sql
explain select count(Seq) from tb_coin where RegDate >= '2018-10-01 00:00:00' and RegDate <= '2018-10-03 00:00:00'
```
시에는 빨리 된다.

```sql
select count(Seq) from tb_coin where RegDate >= '2018-10-01 00:00:00' and RegDate <= '2018-10-03 00:00:00'
```
이때는 많이 느리다.

이유는 explain 은 결과의 정확도를 보장하지 않기 때문이다.
https://stackoverflow.com/questions/1037471/why-the-rows-returns-by-explain-is-not-equal-to-count
에서 발췌함.


+ non 커버링

```sql
select * from tb_money where tb_money.RegDate >= '2018-01-01 00:00:00' and tb_money.RegDate < '2018-01-02 00:00:00'
```
/* 영향 받은 행: 0  찾은 행: 602,958  경고: 0  지속 시간 1 쿼리: 0.016 sec. (+ 10.250 sec. network) */


+ 커버링

```sql
select a.* from (select Seq from tb_money where tb_money.RegDate >= '2018-01-01 00:00:00' and tb_money.RegDate < '2018-01-02 00:00:00') b join tb_money a where a.Seq = b.Seq
```
/* 영향 받은 행: 0  찾은 행: 602,958  경고: 0  지속 시간 1 쿼리: 0.500 sec. (+ 10.875 sec. network) */








A 테이블 복합인덱스(id,regdate)) 

B 테이블 단일인덱스(id), 단일인덱스(regdate)


1 

only id 조회

select * from A where id = '';

A의 경우

type ref possibile_keys idx_01

B의 경우
type ref possibile_keys id



2 

only regdate 조회


A의 경우
type all possible_keys null

B의 경우
type range possible_keys regdate

3 

id + regdate


A 의 경우 

type ref possible_keys id,regdate

B의 경우

type range possibile_keys idx_01



복합인덱스(id +regdate ), 단일인덱스(regdate) 로 했을 때 비용이 많이 발생하지는 않는다고 한다.