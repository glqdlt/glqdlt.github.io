자바와 같은 클래스 기반의 절차형 객체지향 언어와 함수형 언어간의 차이


절차지향 객체지향 언어
- 데이터 구조화(자료형)에 초점
- 데이터 지향적 스타일
- 상속이란 특성은, 데이터 구조의 확장 즉 전이에 초점을 둠
  - {}


함수지향 언어
- 데이터 구조화보단 연산에 초점. 즉, 수학의 함수와 같다고 보면됨
- 포인트 프리 스타일(tacit programming, point-free style)
  - 특정 인자(return, param 등)을 굳이 선언하지 않고 함수 자체의 결과가 그렇게 될 거라는 멱등성을 전제로한 스타일
  - example) const sumNumber= func3(func2(func1()))
  - 하스켈의 ((())) 의 지옥의 재림
- 연산에 초점을 두다 보니, 나 자신의 연산에 대해서만 생각함. 즉 이러한 특성에 외부와의 격리(또는 차단)을 중시함. 남에게 방해받기 싫어서, 남에게 커플링이나 의존이되면 내 멋대로 연산을 못함.
- 이런 특성에 연산을 위한 내부 지역변수의 사용이나, 불변 값의 활용 등이 생겨남
- 함수를 값으로 쓴다는 얘기는, 함수의 멱등성이란 특성땜에 나오는 이야기임. fx(x,y) => x+y; 가 되는 함수가 있다면  fx(1,2) => 3 이 무조건 나오기 때문에 이를 값으로 쓴다는 의미로 얘기함.

- 재귀적 스타일
  - admin cms 에서 naviation menu 를 구성한다고 가정하면, 절차식으로 하면 지옥을 맛본다. 그걸 계기로 재귀에 눈을 뜸
  - '수평사고 (lateral thinking)'


믹스인과 트레이트 간의 차이

아래 좋은 내용의 내용이 있더라
https://stackoverflow.com/questions/925609/mixins-vs-traits

읽고 난 뒤 매우 공감되었음

- 믹스인은 암시적으로 충돌 (implicit conflict resolution)
- 트레이트는 명시적으로 충돌 (explicit conflict resolution)

믹스인은 동적인 언어에서 가지는 특징에 기반하는 인상이었다. 나는 자바8를 통해서 트레이트를 배웠기 때문에 (SOLID 에서 ISP 인터페이스 분활원칙) default method 가 충돌이 날 경우 새로이 정의해야하는 점에 대해서 이해를 하고 있다.

이는 A.fly(), B.fly() 2개의 같은 함수(@FunctionalInterface 라고 가정하자) 를 동시에 구현 받는 C 클래스가 있을 경우, C 입장에서 A의 fly 와 B의 fly 둘 중에 뭘 사용해야할지 모르는 상황이 생긴다.

C impelments A,B  이렇게 선언이 되기 때문에 어떤게 먼저 치고 왔는 지 판단도 어렵다. 그래서 C 가 직접 fly(){..} 를 구현하게 강제화 한 것이다.

반면 자바스크립트에서 적용되는 Mixin 기법은 (기능이라기 보다는 기법, 테크니컬 이라고 불리더라. 언어 자체 스펙은 아니고, 언어 특징을 서술한 스킬인듯) 프로토타입을 선회해서 

특정 method 만 쏙 빼서 link 시키는 개념이다. 자바스크립트에서 함수는 함수 그 자체가 객체이기 때문에 기능에 해당하는 메소드도 이미 함수임으로, 필드(멤버 변수, 또는 인스턴스 변수) 선언이 가능하다.

반면 자바와 같은 클래스 기반 객체 언어는 클래스가 객체이며, 메소드는 클래스에 붙어있는 존재이기에, 메소드가 객체 최상위가 될 수 없는 특징이 있으며, 객체 자신이 클래스는 컴파일 시점에 구조화된 존재이기 때문에

트레이트를 통해 트레이트의 필드 (멤버 변수, 인스턴스 변수)를 참조할수 없다. 위 설명을 기준으로 하면 C 클래스의 인스턴스는 C 자신에게서만 정의되고, 완성(컴파일) 되기 때문이다.





레퍼런스

- 함수형 자바스크립트 _ 루이스 아덴시오

---


자바의 Optional 이 flatMap() 이 존재하고, wrapping 하며, generic 처럼 반환되는 타입을 보장한다는 점 때문에 모나딕(모나드하다) 이라고들 얘기를 하더라.

처음엔 그런가보다 싶었는데, 함수형 개념을 이해하면 할수록 괴리감이 생겼다. 이해하는 함수형 프로그래밍이란 객체 자체에 일련의 변화를 주지 않고, 즉 객체 상태를 변경시키지 않은 채로

어떠한 목적이 필요할 때에만 사용할 수 있는 로지컬한 부분만 정의를 하여서, 어떠한 목적이 필요한 시점을 제어하자 (어떠한 함수를 실행할 시점을 제어) 하는 데에 의의를 두는 걸로 이해하고 있다.

객체지향 프로그래밍은 어떠한 로직이 진행되는 데에 있어서 객체의 상태를 변화시켜가며 작업하는 일련의 실행이 되어야 넘어가는 (상태가 변화되어야 하는) 패러다임이기에 기능은 항상 즉시실현되어야한다. 즉 객체의 상태를 어떻게 처리할 것인가? 에 초점을 맞춘것이 객체지향 방법이다.  객체지향에서의 함수란 메소드라고 불리우는 것이 이해가 되는 것이다. (메소드는 객체안에 존재하는 기능이며, 일반적으로 객체 자신의 속성을 변화시키는 데 사용한다.)

반면 함수형 프로그래밍은 이름 그대로 객체가 아닌, 함수가 먼저 나오는 것을 보면 연산에 대해 집중하기 때문에 값의 상태가 어떻건 말건 연산 위주로 정의를 하는 데에 목적을 두고 이 연산이 언제, 어떻게 실행시킬것인가? 연산을 어떻게 확장시킬것인가? 에 대해 관점을 둔다. 연산 자체에 초점을 두기 떄문에, 연산은 멱등성을 증명해야기 때문에 외부의 변화에 방어가 되어야 하는 함수 내부의 고유한 CONTEXT를 가지는데에 고민을 하게 된다. 외부로 부터 고유한 CONTEXT를 가지는 탓에 캡슐화 특성도 가지게 되며 또한 이런 특성으로 함수를 값으로도 취급할 수 있다. 왜냐면 함수 안에 고유한 데이터가 캡슐화되어 잘보관되고 있기 때문이다.

모나드의 쓰임새는 파이프 연산과 유사하다. 어떠한 값이 함수 체이닝을 통해 가공될 것이며, 이 가공되는 과정이 안전하게 전달되고 가공하는 함수를 연결(바인딩) 하는데에 의의를 둔다.

함수 체이닝은 함수의 연결이라는 말인데, 메소드 체이닝과 개념이 다르다. 좀 더 정확한 의미는 함수 합성이 옳은 표현이다. 객체지향으로 치면 데코레이터 패턴과 거의 유사하다. 차이가 있다면 데코레이터 패턴은 데코레이터 할 대상의 로직의 결과에 추가 작업을 하는 개념이고, 함수 합성은 데코레이터 할 대상의 로직에 추가 로직을 넣는 개념이다. 

개념적으로는 같지만 데코레이터는 의존적인 반면 함수 합성은 자유롭다. 

그런데 입력과 출력이 다른 두 함수를 어떻게 자유롭게 합성시킬수있을까? 뜬구름 잡는 소리 같다.

함수 f(number) 는 정수를 인자로 받고 함수 f2(string) 은 문자를 입력받는다.

모나드는 이러한 2함수를 연결하기 위한 일종의 아답터인 개념이다. f(monad<number>) , f2(monad<String>) 이런식으로 서로 모나드를 인자로 받고 모나드로 반환하면 연결이 가능해진다.
    
함수 합성을 위한 래핑 타입인 샘이다.

아래에서 설명하지만 모나드는 자바의 Future 처럼 사용될수도 있다.

함수합성시에 모나드를 주고받는다면 A + B 함수가 합성이 될때, A의 연산이 끝나면 B의 연산을 호출시켜줘라고 모나드가 느슨하게 연결할수도 있다.

반대로 모나드 안의 값이 아직 존재 하지 않지만 언젠간 있을거라는 Future 의 개념도 적용해볼수있다.

나는 지금 얘기한 이 부분에서 조금 더 공부가 필요하다

-----

이런 개념으로 봐서는 자바 Optional 은 모나딕하지 않다.

이유는 Optional.get() 은 이미 연산된 값이 들어가있는 것을 반환할뿐이다. 즉시냐 나중에 실행되냐의 차이가 크다.

```
public final class Optional<T> {

    public static <T> Optional<T> of(T value) {
        return new Optional<>(value);
    }
    
        private Optional(T value) {
        this.value = Objects.requireNonNull(value);
    }

    public T get() {
        if (value == null) {
            throw new NoSuchElementException("No value present");
        }
        return value;
    }
    
    public<U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper) {
        Objects.requireNonNull(mapper);
        if (!isPresent())
            return empty();
        else {
            return Objects.requireNonNull(mapper.apply(value));
        }
    }
    
}
```
flatMap은 순수하게 일련의 Optional 로 평면화를 할 뿐이다. 

참고로 평면화란 ["a", ["b","c"], ["d",["e","f"]]]  이러한 복잡한 집합 엔트리를 단순하게 ["a","b","c","d","e","f"]  이런식으로 특정 목적의 균일한 요소로 평탄화하는 것을 의미한다.

아래는 실제로 내가 흉내내본 모나딕한 자료구조이다.

```
  public class MyMonad<T> {
        private T value;

        private Function<T, T> binder;

        public MyMonad(T value, Function<T, T> binder) {
            this.value = value;
            this.binder = binder;
        }

        public T getValue() {
            return binder.apply(value);
        }
    }
```

값의 원형에 매핑되는 바인더는 실제 getValue()를 호출하는 시점에 실행이 된다.

Optional과 사뭇 느낌이 다르다.
