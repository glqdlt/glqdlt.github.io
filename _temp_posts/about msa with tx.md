MSA가 무엇이냐

MSA 를 알려면 SOA를 알아야한다. SOA 에서 여러 이슈들을 해결하고자 나온 디자인 패턴과 개선 집합이 MSA이기 때문이다. 즉 MSA는 SOA의 확장(extend) 버전인 셈이다.

SOA나 MSA 나 모두 모놀리스와 달리 N 레이어로 나누어지는 구성은 같다.

다만 SOA는 같은 성격의 모듈을 같은 레이어에 묶어놓은 반면, MSA는 겉으로 보거나 일련의 흐름 대로 봤을 때 SOA처럼 비슷한 성격이 같은레이어 있는 것처럼 보일지도 모른다, 모듈은 레이어에도 속하지 않고 완전히 독립적으로 구성되는 데 있다.

이런 의미로 마이크로서비스는 SOA지만 모든 SOA가 MSA 인 것은 아니다.

<img src='https://blog.kakaocdn.net/dn/wWafH/btqFaUVjWLh/hjHujUUMVz4YYrLFfPJR11/img.jpg'>



MSA 를 설계하다 보면 흔히 많이 마주 치는 실수가 있는 데, MSA 로 나누는 이유에 대해서 단편적인 부분만 알고 접근하는 사례가 매우매우 많다.

흔히 실수하는 단편적인 부분으로는 기존 스케일 업을 통해 성능 업 관점을 스케일아웃을 위한 MSA로 접근을 많이 하는 모습을 심심치 않게 많이 보았는 데, 이는 매우 잘못되었다. 오히려 MSA 는 스케일아웃을 하는 데에 훨씬 신경쓸 것이 많아진다. 

MSA의 궁극적인 목표는 서비스 지속성을 보장하면서 서비스를 프로덕션 스테이지에 빠른 배포(shipping)이다. 이는 애자일과 관련 된 프로젝트 도구들이 유행을 타면서 그 근간을 이루는 익스트림 프로그래밍의 한 줄기 갈래 나온 자연스러운 현상일 뿐이다. 잦은 리팩토링(OOP와 TDD는 이를 위해 존재한다.)과 점진적인 개선(또는 확장성을 위한 준비) 그리고 신속한 배포(또는 서비스 가용성). 이것을 하기 위해 거대한 규모의 모노리스 아키텍처를 분활하여 관리하고 개선하자는 것의 목표로 나온 것이 MSA의 큰 관점이다.

현재 머물고 있는 조직도 그 중 하나인데, 크게 실수하는 부분 중 하나가 서비스 노드를 나누는 기준을 플러그인(또는 커플링이 심한 모듈) 관점으로 접근하는 경향이 있다. 이 말이 무슨 말이냐면 물리적인 공간이 분리되었을 뿐, 서비스 흐름은 모두 동기적으로 엮어 있다는 말이다. 

에를 들어 ..

MSA 가 뜨기 전에 nginx 웹서버가 큰 화두가 되고, 자바의 전통적인 서블릿에서 netty 그리고 vert.x 와 같은 (또는 nodejs) 이벤트 드리븐 방식의 웹 서버가 인기를 끌었다. 동기식 웹서버에서 오는 성능적 한계 때문에 비동기식의 웹 서버인 nginx 가 인기를 끌게 된 것이다.

마찬가지로 MSA 의 옳바른 형태는 단순히 거대한 모노리스 어플리케이션A을  A-1,A-2,A-3 으로 나누어서 하나의 세션 flow 안에서 A-1,A-2,A-3 이 같이 서로 커플링이 심하게 커뮤니케이션하면서 처리하게 되면 안된다는 의미이다. A-1,A-2,A-3 이 아닌 A(A-1,A-2),B(B-1),C(C-1) 이런 식으로 완벽하게 서로 접점이 없는 경계로 나누어야 하며, 각 A와 B, C 는 서로 내부적으로 무엇을 하는 지, 각자의 고유 책임만 거지고 직접적인 관여를 하지 않아야 한다. 이렇게 되면 어떠한 서비스 노드에서 장애가 나더라도 서비스 지속성을 보장하며, 특정 서비스 노드의 긴급 패치를 하더라도 서비스의 장애가 이루어 지지 않는다. 각 서비스 노드의 장애나 실패는 자신 스스로가 고쳐야 하며, 특정 서비스 노드의 장애나 실패로 인해 다른 서비스 노드들에게 롤백을 요구 하거나 난감한 상황을 전이시키면 안 된다.

하지만 일이란 것이 모두 매번 능사는 아니다. 나중에 후술할 TCC 에서도 설명하겠지만, A사와 B사가 있을 때, 특정 서비스 흐름에서 서로 상호호환이 되어 커플링이 심한 작업을 한다고 하자. 작업이 단순히 A사의 데이터를 얻어와서 B 사가 그 데이터를 기반으로 작업을 하던, A사와 B사가 동시에 한 트랜잭션에서 저장이 되어야 한다던 간에 A사와 B사만의 트랜잭션 코디네이터를 할 주체를 만들고 그에 따른 핸들링을 처리해야 하는 로컬 트랜잭션의 범주를 벗어난 글로벌 트랜잭션을 관리해야할 수도 있다. 만약 A사의 작업이 성공했으나, B 사의 작업에서 롤백을 해야하는 상황이 온다면 A사에게 롤백을 하든 수정을 해라고 연락을 주어야 한다. 그것이 불가능하다면 하늘에서 신이 강림하더라도 답이 없다. 

현재 조직은 gRPC를 사용하고 있는 데, 각 RPC 통신의 단위가 매우 단순하게 접근하고 있다. 예를 들면 A와 B가 서로 있고, A는 유저 관리를 B는 게임 플레이 관리를 한다고 가정하자. A와 B는 한 트랜잭션 단위에서 똑같이 갱신되어야 하고 원자성에 의거해서 그 모두 실패하든 오직 성공하든 해야한다. 이렇다면 A와 B를 관리하는 코디테이터 C가 존재할 것인데, C가 하는 역활은 트랜잭션 전체를 관리할 뿐 특별한 일을 하지 않는다. C는 A와 B에게 할 일을 해라고 말만 할 뿐이다. 이벤트 드리븐 방식이든, 동기식의 응답을 기다리는 방식이든 A와 B의 결과가 왔을 때, C는 결과를 보고 롤백을 시킬지 커밋을 시킬지를 지시만 하면 된다. 만약 A와 B에게 롤백이나 커밋을 해라는 최종 명령을 했으나 A 쪽에서 하드웨어 장애로 의도치 않게 작업을 했다면, 그건 A의 책임이고 A에서 수습을 해야한다. A가 retry 를 계속 시도하고도 안된다면 A 가 B에게 미안한데 노가다로 직접 방금 했던 (트랜잭션ID) 에 대한 행위를 롤백해주지 않을래? 라고 사정사정해야 한다. 하지만 위에서 서술했듯이, A와 B 의 책임은 분리되어야 하며, A가 B 또는 B가 A에게 직접적인 핸들링을 하면 안 된다고 서술했다. 이런 경우가 발생하면 큰 일이 발생하는 경우 A와 B는 붙어서 AB 로 존재해야 한다. 그것이 정 어렵다면 A가 B에게 부탁하는 게 아니라 이런 예외사항을 관리하는 D 라는 존재에게 A가 D를 통해 B에게 요청을 한다던지 처리 해야한다. 왜냐면 MSA 의 서비스는 모두 stateless 하며 무중단 상태를 목표로 하기 때문이다. A의 실패로 인해서 C 의 서비스 트랜잭션이 동기되어 n시간 이상 소요된다면 그 서비스는 유저의 질타를 받게 될 것이다. 이처럼 매우 단순한 것인데, 현 조직에서는 C가 A와 B의 롤백을 직접 하려고 든다. 그래서 별에 별 창의적인 상상을 하게 되는 데, 이럴 거면 C와 A,B 가 아닌 확장성을 염두해서 C와 AB 로 구성해서 작업한 후에, 추후 C와 A,B 그리고 D를 만들어서 처리를 해야 한다.


예전 방송 프로모션 서비스 프로젝트에 참가했을 때의 일화이다.
도메인 환경은 대형 방송 송출사로 쿠폰 서버, 포인트 서버, 마일리지 서버, 유저 관리 서버 등
서비스 노드들이 나누어진 msa 구조였다

이런 msa 관계에서는 각 서비스 노드들의 연관된 업무 원자성을 위해 분산 트랜잭션에 관심이 많다.

이를 위한 방법으로

saga 페턴

tcc 패턴

이벤트 드리븐 모델

xa 2pc

등이 있다.

분산 트랜잭션(XA)에는 여러가지 방법이 있지만, 가장 유행했던 이벤트 드리븐이나 Restful API 에서 사용하는 TCC(try confirm cancel) 패턴을 많이 사용한다. (https://servicecomb.apache.org/docs/distributed_saga_3/)

당시 데이터베이스는 물리적으로 같은 장비에있는 걸 공유하기도 하고 완전히 분리된 경우나 다른 서비스 인프라 공급자를 통해 처리가 필요한 부분도 있었다

데이터베이스가 같은 장비에 논리적으로만 구분된 경우에는 단순히 처리할수있겠지만
물리적으로 떨어진 데이터베이스나 다른 인터페이스(레스트풀솨같은) 를 제공하는 인프라 공급자의 경우
같은 데이터베이스 커넥션이 아니기에 분산 트랜잭션을 묶기가 힘들다.

물리적으로 떨어진 데이터베이 스의 경우 2pc를 고민해보면 된다.
여기에 물리적으로 쩔어진데다가 벤더도 다른경ㅇ 라면 자바 기준으로 jta와 같은 기능을 구현한 글로벌 트랜잭셩 코디네이팅 프레임워크(atomics)를 사용하면 쉽게 된다.

자 그러면 이제 인터페이스가 완전히 다른 경우는 어떻게 할것인가?
지금까지는 트랜잭션 코디네이팅을 제공하는 구현체들을 하용했기에 쉬웠지만
이제는 이 구현체를 우리가 구현해허 사용해야하는 시점이 됬다.

여기서 나오는 디자인 패턴들이 saga , tcc , event driven 이 있다

## 분산 트랜잭션 시나리오

마이크로서비스에서 필요하다면 로컬 트랜잭션만을 사용하고 분산 트랜잭션을 피하는 것이 이상적인 시나리오이다. 하나의 서비스를 실행하는 마지막 단계에서 다른 마이크로서비스에 메세지를 보내는 시나리오가 있을 수 있다.


## 궁극적 일관성(eventual consistency)

궁극적(최종) 일관성이란 중간에 일관성이 맞지 않는 순간이 있을 수 있지만, 최종적으로는 모두 맞게 되어야 한다라는 것을 의미한다.

이것에 대한 예시는 이러한 예시를 둘 수 있다. 

비행기 렌탈 회사 A와 숙박 회사 B사가 있다고 가정하자, 유저는 여행 패키지 상품을 구매했고 이를 관리해주는 여행사 C사가 있다. C사는 유저가 원하는 일시에 A사의 비행기와 B사의 숙박업소를 예약해주어야 한다. 여기서 C사는 여행 준비라는 트랜잭션 코디네이터가 되고, A사와 B사는 각각 서비스를 제공하는 프로바이더가 된다. C는 A와 B에게 특정일에 어떠한 일을 해줘라고 요청한다. 이 과정에서 C가 먼저 할지 A가 먼저 수행이 될지는 알수 없고, 이는 제각각 별도의 트랜잭션에서 이루어 진다. 여기서 일관성이 일시적으로 깨지는 관계가 온다. 덧붙여서 A사는 성공했으나 B사에서 자리가 없어서 취소를 해버렸다고 연락이 왔다. 이 경우 A의 트랜잭션은 성공했고, B의 트랜잭션도 큰 관점에서 볼 때 성공했으나, 우리가 원한 결과는 아니다. 그래서 C는 B에게 다른 방이 없는 지를 물어본다(retry)던지 A에게 취소를 해달라고 연락한다던지 결국에는 최종적으로 모두 하나의 결과상태로 만들어지게 될 것이다. 이게 궁극적 일관성이다.

이런 니즈를 위해서 Nosql 의 CAP(consistency avaliability) 에서는 ACID 와는 다르게 데이터의 일관성을 느슨하게 처리해서 데이터의 변경을 시간의 흐름에 따라 여러 노드에 전파하는 방식을 지원한다. 이것이 최종 일관성이라 부르는 데 이는 지금 얘기하는 궁극적일관성가 매우 흡사하다.



# 레퍼런스

- http://chanwookpark.github.io/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4/%EB%B2%88%EC%97%AD/%EB%A7%88%ED%8B%B4%ED%8C%8C%EC%9A%B8%EB%9F%AC/2016/01/29/microservice-trade-off/

- https://namu.wiki/w/NoSQL
