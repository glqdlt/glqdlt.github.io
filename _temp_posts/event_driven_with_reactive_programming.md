리액티브 프로그래밍과 이벤트 DRIVEN

리액티브 프로그래밍과 이벤트 드리븐은 절차지향 프로그래밍과 달리 비동기로 이루어진다는 점에서 같은 맥락을 가진다.

또한 무엇에 반응한다는 개념에서(리액티브) 이벤트 드리븐과 리액티브 프로그래밍은 같다.

거의 같아 보이는 이 개념의 결정적인 차이는 데이터의 수신 여부에서 차이가 있다. 

vs 절차지향 프로그래밍

가령 어떠한 콤보 박스가 있는 FORM 이 있다고 가정하자

```
- ios []

- aos []
```

유저가 해당 체크 박스를 클릭하여 어떠한 옵션 값을 설정하는 기능인데, 이 설정된 값을 서버로 보내는 개념으로 보자.

일반적인 명령형 프로그래밍에서는 submit 을 하는 시점에 대상의 속성을 체크하는 개념으로 코딩을 한다. 좀 더 자세히 말하면, submit 을 하는 시점에 상태를 체크하고 formData를 추가해라 라는 식의 상세한 명령이 서술된다.

submit 을 위한 formData 에 체크하는 시점에 formData가 추가가 되는 기능이 호출이 될것이다.

반면 선언형 프로그래밍 관점에서는 체크가 되는 상태를 외부에 알리는 식으로 publish() 하는 개념으로,

submit 을 위한 formData 는 클릭 되는 시점에 추가가 되는 기능이 호출한다, 라는 식의 선언을 할 뿐이다.

선언형과 명령형의 차이점은 선언은 ~하면 ~한다. 라는 식의 선언을 하는 기능(또는 역활, 또는 짧은 명령)을 선언할 뿐이고, 명령형은 ~할 때 ~하고 ~해라 라는 식의 깊은 명령 커맨드가 기입된다.

가끔 절차지향과 명령형 프로그래밍을 같은 관점에서 보기도 하는 데, 절차지향 프로그래밍은 탑-다운으로 절차적으로 수행한다는 의미에서 꼰대 언어나 스크립트 언어들에서 볼수 있는 프로그래밍이다.

탑다운으로 명령을 줄줄히 적는다고 해서, 명령형 프로그래밍이라고도 하는 데, 객체지향 언어에서도 명령형 프로그래밍으로 대부분 작성한다. 다만, 절차지향 프로그래밍에서는 모듈화에 대한 개념이 옅은 데, 객체지향 언어에서는 객체를 통한 캡슐화와 모듈화가 가능하기 때문에 절차지향==명령형 이라는 수식이 맞지 않아 진다. 단순히, 객체의 기능을 서술하는 메소드 부분에서 명령형으로 작성하기 때문이다.

여기까지 명령형과 선언형의 차이점에 대해 서술했다면, 리액티브 프로그래밍과 이벤트 방식의 차이점은 아래와 같이 설명할 수 있다.

일련의 리액티브 프로그래밍은 데이터를 넘기면서 파이프라인으로 연계 되는 개념이고, 이벤트 드리븐은 이벤트에 초점을 두고 해당 이벤트를 소비하는 데 관점을 두지, 데이터 그 자체에 초점이 있지는 않다.

위의 체크박스를 에시로 두면 아래와 같은 개념이다.

리액티브 프로그래밍 방식으로는 클릭 이벤트가 일어날 때, 이벤트가 일어난 대상 그 자체의 일어난 속성 데이터를 formData에 추가하는 함수에게 해당 이벤트가 일어난 속성 데이터 자체를 넘기는 개념이다.

이벤트 드리븐에서는 클릭 이벤트가 일어났다는 이벤트에 초점을 둔다. 어디에서 이벤트가 일어났다는 이벤트 객체를 발행(생성) 시키고, 해당 이벤트에 관심이 있는 반응 할 함수가 직접 데이터를 찾아가거나, 스냅샷 데이터를 전달 받는다.

관점에서 보면 return 이 무엇이냐로 접근할수 있지만, 조금 더 실무적인 차원으로 얘기를 하면 리액티브 프로그래밍은 작은 함수 단위가 일련의 연계되는 파이프라인으로 구성화 되는 함수 체이닝이 포인트라면, 이벤트 드리븐은 이벤트를 알리고 수신하는 데에 초점을 두기 때문에 fx(x -> void).fx(x -> void)가 될 수 있지만 리액티브 프로그래밍에서는 fx(x -> xy).fx(x ->x).fx(x ->)는 마지막 최종 연산에서나 가능한 개념이다.

즉 함수 체이닝을 위해 리액티브 프로그래밍은 input/output을 보장할 수 밖에 없는 순수 함수형과 같은 구조가 된다. 가장 일반적인 것은 리눅스 커맨드의 파이프 개념과 같다.

- 리액티브 프로그래밍

- 이벤트 드리븐


스프링 프레임워크의 EventPublisher 로 EDD 를 흉내내보려 했다.

어느 정도 가능은 하지만, 단일 이벤트에 대해서만 구독이 가능하기 때문에 답답한 감이 있다.

그래도 super type을 같이 구독해서, subType 별로 분기를 태운다던지로, 얼추 흉내는 가능하다.

```
  
    @Override
    public void onApplicationEvent(NumberEventResult event) {
        logger.info("number : {}", event.getCount());
        if(event instanceof ExtendNumberEventResult){
            logger.info("special consume..");
        }else{
            logger.info("default consume..");
        }
    }

```

다만 이 경우는 관심사를 위해서 전혀 상관없는 객체를 연결(상속) 해야하는 골때리는 상황이 발생하기에 비추.

같은 어그리게잇의 특정 이벤트를 처리하는 하위 컴포넌트들을 하나의 패키지(이를 바운더리 컨텍스트로 본다)에 놓고 할수도 있는데  클래스 파일이 매우 많아질 소재가 있기 때문에 이 경우 관리도 어려워진다.
