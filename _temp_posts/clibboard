https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/BaseRequest.java

BaseRequest#setScope()

에서 nullpoint입셉션이 난다


ClientDetails#isScoped() 가 false 로 해놔도

getScope() 를 호출해서 이를 복사해가면서 null로 떨어진다 개 웃기네

일단 무의미한 데이터를 넣어놨다. 그러니 통과가 된다.. isScoped() 를 호출해서 비교를 할지 말지에 대한 처리 정도인가보다.

scope 사이즈가 0이어도 동작해야하는게아닌가?


Dispatch Servlet


```
Dispatcher-Servlet이 등장함에 따라 Spring MVC의 web.xml의 역할이 축소되었다. 기존에는 모든 서블릿에 대해 URL 매핑을 활용하기 위해서 web.xml에 모두 등록해주어야만 했다. 그러나 Dispatcher-Servlet이 들어오는 모든 요청을 핸들링해주면서 작업을 상당히 편리하게 할 수 있게 되었다.
Dispatcher Servlet이 요청들을 Controller로 넘겨주는 것은 편해보이지만, 한가지 문제점이 있다. 이미지나 HTML을 불러오는 요청마저 모두 Controller로 넘겨버린다는 것이다. 심지어 JS나 CSS 파일에 대한 요청 모두 Dispatcher-Servlet이 가져가기 때문에 자원 호출이 제대로 이루어지지 않는다. Spring은 이에 대한 해결책으로 <mvc:resources/>를 이용할 수 있도록 내놓았다. 만약 Dispatcher-Servlet에서 해당 요청에 대한 컨트롤러를 찾을 수 없는 경우에, 2차적으로 설정된 경로에서 요청을 탐색하여 자원을 호출할 수 있도록 한 것이다.
```


인터셉터와 필터

<img src='https://justforchangesake.files.wordpress.com/2014/05/spring-request-lifecycle.jpg'>

필터는 서블릿에 적용할수 있는 가장 최초의 진입점이며 어플리케이션 컨텍스트 내에서의 글로벌 제약이 가능하다.

인터셉터는 책임연쇄패턴으로 필터를 지나 거쳐온 URL 이 향하는 목적지 path 에 대응가능한 컨트롤러(핸들러매핑)에 넘겨질 때, 해당 핸들러매핑으로 넘어가는 시점을 가로채는 인터셉팅이 가능하다.

이게 무슨말이냐면 인터셉터는 필터와 달리 특정 핸들러매핑에만 인터셉팅이 가능하단 얘기이기 때문에, 핸들러매핑이 여러개라면 
