https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/BaseRequest.java

BaseRequest#setScope()

에서 nullpoint입셉션이 난다


ClientDetails#isScoped() 가 false 로 해놔도

getScope() 를 호출해서 이를 복사해가면서 null로 떨어진다 개 웃기네

일단 무의미한 데이터를 넣어놨다. 그러니 통과가 된다.. isScoped() 를 호출해서 비교를 할지 말지에 대한 처리 정도인가보다.

scope 사이즈가 0이어도 동작해야하는게아닌가?


Dispatch Servlet

org.springframework.web.servlet.DispatcherServlet.class ..|> javax.servlet.Servlet

서블릿 표준스펙은 서블릿컨테이너는 web.xml (배포 서술자 라고도 한다) 에 등록된 정보에 따라 특정 REQUEST 엔드포인트에 어떠한 서블릿이 대응할수있을지를 설계하게 되어있다.
예를 들면 아래 web.xml 을 보면 ComingSoonServlet 은 Servlet 인터페이스를 구현한 서블릿이고, 해당 서블릿은 모든 요청이라는 와일드카드 /* 로 설정되어 모든 요청이 ComingSoonServlet#serviet(req,res) 메소드로 전달이 된다.

```xml
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">
    <servlet>
        <servlet-name>comingsoon</servlet-name>
        <servlet-class>mysite.server.ComingSoonServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>comingsoon</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>
</web-app>

```
 
DispatcherServlet 도 Servlet 인터페이스를 구현한 녀석으로, 스프링이 만든 서블릿컨테이너 안의 서블릿컨테이너이다.

예시를 말해보면, 건물은 톰캣과 같은 JavaEE 의 WAS 스펙을 구현한 서버이고, 건물안의 원룸은 Servlet 인터페이스 인 셈이다. 각 101호 102호 와 같은 것이 url path 인 셈이고..

여기서 DispatcherServlet 을 만든 것은 101호 안에서도 101-1호 101-2호 로, 각 방에 세를 놓겠다는 개념과 유사하다고 생각하면 좋다.

나는 101호 라는 원룸 안에서 내부적으로 이것저것 지지고 복고 할 수 있다. 각 방에 세를 두거나 하는 것은 독자적인 나만의 룰로 할수도 있고,

DispatcherServlet 이 딱 그러하다. 스프링 프레임워크 진형 입장에서 자유롭게 창의적으로 접근하려면 자신에게 할당된 서블릿 (예: 101호) 안에서 세계관을 구축할수 있기 떄문이다.

DispacerServlet 의 동작원리를 보면 WAS 
 
 

```
Dispatcher-Servlet이 등장함에 따라 Spring MVC의 web.xml의 역할이 축소되었다. 기존에는 모든 서블릿에 대해 URL 매핑을 활용하기 위해서 web.xml에 모두 등록해주어야만 했다. 그러나 Dispatcher-Servlet이 들어오는 모든 요청을 핸들링해주면서 작업을 상당히 편리하게 할 수 있게 되었다.
Dispatcher Servlet이 요청들을 Controller로 넘겨주는 것은 편해보이지만, 한가지 문제점이 있다. 이미지나 HTML을 불러오는 요청마저 모두 Controller로 넘겨버린다는 것이다. 심지어 JS나 CSS 파일에 대한 요청 모두 Dispatcher-Servlet이 가져가기 때문에 자원 호출이 제대로 이루어지지 않는다. Spring은 이에 대한 해결책으로 <mvc:resources/>를 이용할 수 있도록 내놓았다. 만약 Dispatcher-Servlet에서 해당 요청에 대한 컨트롤러를 찾을 수 없는 경우에, 2차적으로 설정된 경로에서 요청을 탐색하여 자원을 호출할 수 있도록 한 것이다.
```


인터셉터와 필터

<img src='https://justforchangesake.files.wordpress.com/2014/05/spring-request-lifecycle.jpg'>

필터는 서블릿에 적용할수 있는 가장 최초의 진입점이며 어플리케이션 컨텍스트 내에서의 글로벌 제약이 가능하다.

인터셉터는 책임연쇄패턴으로 필터를 지나 거쳐온 URL 이 향하는 목적지 path 에 대응가능한 컨트롤러(핸들러매핑)에 넘겨질 때, 해당 핸들러매핑으로 넘어가는 시점을 가로채는 인터셉팅이 가능하다.

이게 무슨말이냐면 인터셉터는 필터와 달리 특정 핸들러매핑에만 인터셉팅이 가능하단 얘기이기 때문에, 핸들러매핑이 여러개라면 
