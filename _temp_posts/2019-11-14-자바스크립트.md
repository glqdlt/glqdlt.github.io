---
layout: post
title:  "자바스크립트"
author: "glqdlt"
---

# 들어가며

이 아티클은 [객체지향 자바스크립트 3/e](http://www.yes24.com/24/goods/51335821) 를 읽으면서 작성한 요약본입니다.

## 자바스크립트의 구성

자바스크립트에는 세 가지의 핵심적인 용어가 구성되어 있다.

- ECMAScript : 언어의 핵심적인 기능으로 변수, 함수, 루프 등을 포함(ECMA-262 스펙). 브라우저와는 무관히 독립적이고 다른 여러 환경에서 사용 될 수 있음

- DOM(Document Object Model) : HTML 및 XML 문서와 동작할수 있는 방법을 제공. 문서를 조작하는 언어 독립적인 W3C의 DOM 표준이 만들어짐.

- 브라우저 객체 모델 : 브라우저 환경과 관련된 객체의 집합. HTML5에서 표준화됨.

## 브라우저 전쟁

넷스케이프(현 모질라)와 마소간의 제1차 브라우저 전쟁에 대한 이야기

## 현재

자바스크립트에서 흥미로운 것은 항상 호스트 환경에서 실행되는 점

오늘 날 자바스크립트는 서버, 데스크톱, 모바일 기기에서도 실행이 가능

## ES5 와 ES6

### ES5

2009 년 12월에 공식적으로 승인.

대부분의 브라우저 및 서버에서 구현. 흥미로운 기능은 ```strict mode``` 의 도입.
엄격 모드는 언어의 하위집합으로 사용되지 않는 기능이 동작하지 않게해줌.

> "use strict";

태그나 함수의 머릿말에 위 선언을 통해 사용이 가능

### ES6 

2009년에서 6년 만인.. 2015년 6월에 승인. 그래서 ECMA Script 2015 라고도 부름.

```promise```, ```제네레이터``` 등

ES6의 스펙을 모든 플랫폼에서 완벽히 구현하지는 못했다. 이런 이유로 ES6 원본 코드를 브라우저에서 실행시키거나 서버에서 실행시키면 몇몇 코드의 구문을 해석하지 못해서 에러를 내고 app은 멈춘다. 

이를 위해서 트랜스파일러가 등장했다. 트랜스파일러는 ES6 syntax 코드를 모든 브라우저에서 동작하는 ES5 코드로 변환하는 개념인데, 컴파일과 유사하다해서 트랜스파일이라고 부르고, 이를 처리해주는 녀석을 트랜스파일러라고 부른다.(또는 컴파일러)

현재 대표적인 트랜스파일러로는 바벨(Babel)이 있음.

### 바벨

바벨은 빌드 시스템, 프레임워크 및 언어에서부터 탬플릿 엔진까지 광범위하게 사용되고 있음.

## 객체지향 프로그래밍

객체지향의 기본적인 개념들

- 객체와 메소드, 속성

- 클래스

- 캡슐화

- 집합

- 재사용성 / 상속

- 다형성

### 객체

OOP에서 객체는 어떠한 대상을 일컫는 개념이다. 프로그래밍에서 '인스턴스(instance)' 라고 부르기도 한다. 예를 들어 네로라 불리는 검은 고양이가 있다면 네로는 고양이 객체이고, name 이 '네로', color 가 '검정' 의 속성을 가지고 있다. 또한 고양이의 특징인 '울기(야오옹~)', '뛰어내리기' , '핥퀴기' 와 같은 동작을 수행할 수 있다. 이러한 동작을 객체의 메소드라고 부른다.

> 개인적인 팁이지만, 주변 사람들을 보면 메소드와 함수를 혼동해하는 사람이 많은 걸 보아왔다. 메소드와 함수는 생긴 모양새는 같은 의미를 가진다. 하지만 두 개념이 비슷해보여도 궁극적인 차이는 메소드는 객체에 포함되어야만 존재하는 기능의 역활이고, 함수는 객체 없이도 동작할 수 있는 기능이다.

### 클래스

OOP에서 클래스는 객체의 청사진(blueprint) 또는 레시피(recipe)임. 또 어떻게 보면 공장의 틀 같은 존재나 탬플릿과 같은 것으로 봐도 무관하다. 위의 네로 고양이를 예로 들면 '네로라는 객체는 고양이 클래스' 라 말할 수 있다.

### 캡슐화

캡슐화(encapulatoion)는 객체가 데이터의 성질(객체의 속성에 값이 저장됨)을 가짐으로써 생겨난 개념이다. 캡슐화의 궁극적인 의미는 정보 숨기기(information hiding)에 의미를 가진다. 또한 접근 제한의 의미도 가진다(public, private)

### 집합

여러 객체를 하나의 객체로 결합하는 걸 집합이라고 부른다, 또는 컴포지션(composition).
고양이의 몸을 이루는 것을 세분화해서 살펴 보면, 눈 객체, 꼬리 객체, 다리 객체로 작은 단위의 요소들로 이루어진 것을 알 수 있다. 이처럼 여러 객체들이 모여서 하나의 객체로 구성되는 것을 집합이라고 보면 된다.

### 상속

상속은 상속이다. -_-;

### 다형성

다형성도 다향성이지 -_-;

## 문법

### 변수

변수 선언은 기본적인 것임으로 패스.


#### $변수

변수 이름에 있는 $ 문자는, 일반적으로 함수 이름을 표현할 때 가끔 쓰는 네이밍 표기법이라고 한다. 

```javascript
const $myFunction = function(){...}
```

#### 세미콜론

표현식의 마지막은 항상 세미콜론으로 끝낸다. 자바스크립트에는 세미콜론 자동 삽입 매커니즘이 있다. 하지만, 미표기 시에 착각이 일어나 개발 코드에 버그를 만들게 할 수도 있음으로 대부분 표기하기를 권장한다.

#### typeof 연산자

변수 나 값의 유형을 알고 싶을 때, typeof 연사를 사용할 수 있다.

typeof 로 알 수 있는 유형은 아래와 같다.

- 숫자 (number)

- 문자열 (string)

- 부울(boolean)

- 정의되지 않음 (undefined)

- 객체 (object)

```javascript
const some ='123';
typeof some 
// >> "string"
```

```javascript
const n5 = 0xff;
n5
// >> 255
typeof n5
// >> "number"
```

#### 지수 리터럴
1e1 은 숫자 1 뒤에 0이 하나 있는 걸 나타낸다. 2e+3 은 숫자 2 뒤에 3개의 0이 있음을 나타낸다.3e-3은 0.003 이다.

```javascript
1e1
// >> 10
2e+3
// >> 2000
3e-3
// >> 0.003
```

#### 무한대

```javascript
const a = 6 / 0;
a;
// >> Infinity
```

#### NaN

NaN 은 알 수 없는 숫자타입을 의미한다.

```javascript
const a = 10 * "f;
a;
// >> NaN
```

#### 문자열 반환 변태성

```javascript
let s = '1';
s++;
// >> 2
```

#### 탬플릿 리터럴

ES6 에 생긴 문법으로, 작은 따옴표 대신 백틱(back-tick) ``` console.log(`Hello : ${name}`) ``` 을 써서 사용한다. 또한 값을 주입해주는 자리표시자 (place holder) syntax는 중괄호와 달러기호를 사용해서 ```${expression}``` 로 작성한다.

```javascript
const name = 'jhun';
console.log(`Hello ${name}`);
// >> Hello jhun

const $someFunc = (a,b) => {return a+b};
console.log(`${$someFunc(1,2)}`);
// >> 3
```

#### 지연 평가

첫 번째 피연산자가 평가됬을 때 true라 판단이 된 후에, 뒤에 어떤 값이 나오더라도 의미가 없을 경우에는 지연 평가(lazy evaluation) 으로 처리 되에 후술 된 평가 로직이 동작하지(short-circuiting) 않는다.

```javascript

let val = 5;
true || (val = 10);
// >> true
val;
// >> 5;
true && (val = 11);
// >> 11;
val;
// >> 11;

```

위 특징을 응용해서 아래와 같은 것도 가능하다.

```javascript
var myNum1 = 5;
myNum1 = myNum1 || 10;
myNum1;
// >> 5;

var myNum2 = myNum2 || 10;
myNum2;
// >> 10;
```

그렇지만 ES6 에서는 이 꼼수가 막혔다.
```javascript
let myNum1 = 5;
myNum1 = myNum1 || 10;
myNum1;
// >> 5;

let myNum2 = myNum2 || 10;
myNum2;
// >> error;
```

#### undefined 와 null

```javascript
let i = 1 + undefined;
i;
// >> NaN

let ii= 1 + null;
ii;
// >> 1;

```

#### Symbol

ES6 에는 새로운 원시 타입인 Symbol 이 생겼다.

```javascript
let atom = Symbol();
atom;
// >> Symbol();
```

#### 배열

배열은 어느 언어독립적으로 비슷하다. 단, 문자열 배열 접근은 ES6 에 와서야 동작하게 되었다.
```javascript
const s= 'one';
s[0];
// >> o
s[1];
// >> n
```

- 배열은 인덱싱 된 요소가 포함되어 있다.
- 배열은 0부터 시작한다.
- 배열에 접근하려면 인덱스 count 를 호출해야한다.
- 배열은 다른 배열을 포함한 모든 유형의 데이터를 포함 시킬수 있다.

#### 루프

자바스크립트에서는 네 가지 유형의 루프가 있다.

- while 

```javascript
let i = 0;
while(i<10){
    i++;
}
```

- do-while
```javascript
let i =0;
do{
    i++;
}while(i<10);
```

- for
```javascript
let msg = '';
for (let i =0; i< 100; i++){
    msg += i;
}
```


- for-in

    for ...in 루프는 배열 또는 객체의 요소를 반복하는 데 사용된다. for 나 while 을 대체하는 수단이 아니다.

    ```javascript
    const arr = ['a','b','c'];
    for (let i in arr){
        console.log(`index = ${i}, vale = ${arr[i]}`);
    }

    const obj = {name : 'jhun', old : 14, iq : 999};

    for(let k in obj){
        console.log(`property key : ${k}, value : ${obj[k]} `);
    }

    ```

### 함수

자바스크립트의 꽃인 함수이다.

자바스크립트의 함수를 터득한다는 것은 아래 자바스크립트의 테크닉을 사용하게 되는 걸 의미한다.

- 익명 함수의 사용
- 콜백
- 즉시 실행 함수
- 내부 함수
- 함수를 반환하는 함수
- 스스로를 재정의하는 함수
- 클로저

#### 함수의 매개변수

```javascript
function sum(a,b){return a + b};

sum(1,2);
// >> 3;

<!-- 불 필요하게 많이 들어간 매개변수는 무시된다. -->
sum(1,2,3,4,5);
// >> 3;

```

자바스크립트 함수에는 자동으로 생성되는 특별한 값이 arguments 라는 내장 키워드가 있다. 

```javascript

function args(){
    return arguments;
}
args();
// >> [];
args(1,2,3,'hello');
// >> Arguments(4) [1,2,3,'hello'] ....


```
위 특징을 응용해서 아래와 같은 함수도 만들 수 있다.

```javascript

function sumOfAll(){
    let result = 0;
    for(let i in arguments){
        if(typeof arguments[i] === 'number')
        {
        result += arguments[i];
        }
    }
    return result;
}

sumOfAll(1,2,3)
// >> 6

sumOfAll(1,2,3,'HAHA')
// >> 6

```

#### default 매개변수

함수 매개변수에 디폴트 값을 지정할 수 있다. 또한 default 매개변수는 다른 매개변수를 참조할 수도 있다.

```javascript

function echo(name = 'jhun',name2 = name){
     console.log(`Yahoo~ ${name} ~ ${name2}`);
}

echo();
// Yahoo~ jhun ~ jhun
echo('haha');
// Yahoo~ haha ~ haha;

```

좋아보이지만 주의할 점이 아래와 같다. 내부 변수에서 재정의를 하여 매개변수를 덮으려고 해도, default 매개 변수가 외부의 변수에 의해 가려지게 되면(shadowed) 의도 되로 동작하지 않는다.

```javascript
var val = 'out';

function print(arg = val){
    var val = 'in';
    console.log(arg);
}
print();
// >> out
print(123);
// >> 123;

<!-- ES6.. -->

let val = 'out';

function print(arg = val){
	let val = 'in';
	console.log(arg);
}
print();
// >> out
print(123);
// >> 123

```
#### 나머지 연산자

```javascript
function echo(...arg){
	for(let i in arg){
		console.log(arg[i]);
    }
}


echo("haha","hoho")
// >> haha
// >> hoho
```

재밌는 것은 나머지 매개변수로 받는 녀석은 배열로 들어온다는 점이 재밌다. 또한 나머지 매개변수는 꼭 마지막 매개변수로 선언이 되어야만 한다.

```javascript
function echo(a1, ...arg){
	console.log(a1);
	console.log(arg);
}
echo('h1','h2','h3','h4');
// >> h1
// >> (3) ["h2", "h3", "h4"]
```

#### 스프레드 연산자

나머지 연산자와 생긴 것은 같지만 기능이 다르다. 스프레드 연산자는 배열이나 객체의 값으로 넣어질 때 배열 안의 item 들을 하나하나 split 해서 뽑아주는 녀석이다. 코드를 직접 보자

```javascript

const arg1 = ['wed','thu'];
const arg2 = ['sat','sun'];
const week = ['mon','tue', ...arg1,'fri',...arg2];
week;
// >> (7) ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]
```

#### 사전 정의 된 함수

자바스크립트 엔진에는 사전 정의되어 있는 내장 함수가 몇 가지 있다.

- parseInt()
- parseFloat()
- isNaN()
- isFinite()
- encodeURI()
- encodeURIComponent()

    ```javascript
    const url = 'http://www.github.com?param1=value and value';
    encodeURI(url);
    // >> "http://www.github.com?param1=value%20and%20value"
    encodeURIComponent(url)
    // >> "http%3A%2F%2Fwww.github.com%3Fparam1%3Dvalue%20and%20value"
    ```
- decodeURI()
- decodeURIComponent()
- eval()

    eval 은 자바스크립트 syntax 를 가진 문자열을 실행시켜준다.

    ```javascript
    const code = 'var ii = 2;';
    ii;
    // >> ii is not defined
    
    eval(code);

    // >> 2;

    eval('var i2 = 3;');
    i2;
    // >> 3;
    ```

    eval()은 악마다 라는 말이 있듯이, 문제를 야기하는 단점이 몇 있다.

    - 보안 : eval()에 전달되는 입력 소스를 신뢰할 수가 없다.
    - 성능 : 코드를 eval()로 실시간 평가(실행)하는 것은 소스 코드 보다 성능적인 퍼포먼스가 매우 느리다.

#### 변수 호이스팅

```javascript
var a = 123;
function f(){
    console.log(a);
    // >> undefined
    var a= 1;
    console.log(a);
    // >> 1;
}
f();
```
이 함수를 실행할 경우 기대하는 바는, 첫번째 alert 에서 123이 두번째 alert에서는 1 이 나올 것이라 기대 한다. 하지만 정작 결과는 undefined 이다. 이것은 호이스팅이라는 자바스크립트의 특징 중 하나를 보여주는 사례이다. 

호이스팅은 자바스크립트의 함수는 함수가 실행될 때 함수 내부의 모든 지역변수들을 최상단 으로 끌어올려 선언하는 특징을 가지고 있다. 위 f() 함수를 호이스팅 관점으로 보면 아래와 같다.


```javascript
var a = 123;
function f(){
    var a;
    console.log(a);
    // >> undefined
    a= 1;
    console.log(a);
    // >> 1;
}
f();
```

```var a=1``` 으로 아래에서 선언 되던 a 라는 지역 변수가 가장 최상단으로 끌어올려졌다. 끌어 올려지면서 a가 명시 되면서, 값이 선언되지 않은 undefined 가 출력 된다.

#### 블록 스코프

위의 호이스팅 문제 때문에 ES6 에서는 블록 범위(scope) 라는 기능을 추가 했다. 블록 스코프를 사용하기 위해서는 var 키워드 대신 let , const 키워드로 변수를 선언해야 한다. let, const 로 선언 하게 되면 블록 단위로 호이스팅 된다.

```javascript
let a = 123;
function f(){
    console.log(a);
    // >> a is not defiend
    let a= 1;
    console.log(a);
    // >> 1;
}
f();
```

블록 스코프는 자바나 C++ 과 같이 ```{``` ```}``` 블록 구문의 동작과 똑같이 동작하게 된다. 자바스크립트 만의 특징인 호이스팅도 일어나지 않는다. 또한 let 키워드로 선언 된 변수 명이 이미 있을 경우 재 선언할 수 없다. 

### 함수는 데이터다.

자바스크립트에서의 함수는 데이터이다. 책에서는 이 개념을 아주 중요하게 설명하고 있다.

#### 함수 리터럴

함수를 정의하는 방식 중에 함수 리터럴 표기법(function literal notation) 이라는 것이 있다.

```javascript
var f = function () {
    return 1;
    }
```

위의 코드에서 ``` function () {...} ``` 에 해당하는 것은 함수 표현식(function expression)이다. 함수 표현식은 선택사항으로 이름을 줄 수 있다, 예를 들면 ```function hello() {...}``` 이런 식으로 말이다. 이 경우에는 NPE(named function expression)이라 해서 이름을 가지는 함수 표현식이 된다. 

함수 표현식과 리터럴 표기법의 차이점은 호출법에서 차이가 있다. 함수 표현식은 변수 호이스팅처럼 전역으로 자동으로 끌어올려져 어디서든 호출할 수 있지만, 리터럴 표기법은 선언 되기 이전에는 호출할 수 없다.

```javascript

some();
// >> hi
f();
// f is not difined;

function some(){
    console.log('hi');
}

var f = function(){
    console.log('hi');
}

```

#### 익명 함수

함수 표현식에서 선택사항인 이름을 주지 않고 선언한 함수를 익명 함수(anoymous) 라고 부른다.

익명 함수는 아래의 특징을 가진다.

- 익명 함수를 매개변수로 다른 함수에 전달할 수 있다.
- 익명 함수를 정의하고 바로 실행할 수 있다.

```javascript

function somePlus(a,b){
    return a + b;
}

function sum1(){
    return 1+2;
}

function sum2(){
    return 3;
}

somePlus(sum1(),sum2());
// >> 6

<!-- 익명즉시함수로 그 자리에서 바로 함수를 작성해서 실행 -->
somePlus((function() {return 7)()}, sum2();
// >> 10;

<!-- 애로우함수(람다)로도 작성이 가능  -->
somePlus((() => {return 8})(), sum2();
// >> 11;

```
위를 응용해서 콜백함수로 사용하면 아래와 같다.

```javascript


function multiplyWithSum(a,b,callback){

    return callback(a) + callback(b);

}

multiplyWithSum(2,3,(x) => {return x*2} )
// >> 10
```

#### 즉시 실행 함수

즉시 실행 함수는 함수가 정의 된 자리에서 바로 실행되어 result 값을 가지고 있게 되는 경우이다.

#### 내부 비공개 함수

비공개 함수는 특정 함수 내부에서만 사용되는 함수를 말한다. 비공개 함수를 사용하면 얻는 이점은 아래와 같다.

- 전역 네임스페이스를 깨끗하게 유지할 수 있어 충돌 발생이 없어진다.

- 캡슐화 : 필요한 함수만 외부에 노출시키고, 나머지 함수는 의도에 따라 감출 수 있어 진다.

```javascript

function outer(param){
    function inner(innerParam){
        return innerParam * 2;
    }
    return inner(param);
}
outer(7);
// >> 14;

// 함수 리터럴로 작성하면 아래와 같다

const outer = function(param) {
    const inner = function (innerParam){
        return innerParam * 2;
    }
    return inner(param);
}
outer(7);
// >> 14;

// 람다로 작성하면 아래와 같다

const outer = (param) => 
{ 
    const inner = (innerParam) => { return innerParam * 2;};
    return inner(param);
}
outer(7);
// >> 14;

```

#### 사용자 재정의 함수

함수는 함수를 반환할 수 있다.

```javascript
const functionMom = () => {return () => {return 1;}};

functionMom();
// >> () => {return 1;}

const child = functionMom();
child();
// >> 1;

// 만약 함수를 반환하지 않고 값을 바로 리턴받고 싶다면 '즉시실행 함수'로 호출하면 된다. child 는 함수를 호출하는 반면, executeChild 는 변수를 호출하는 것을 유의.

const executeChild = (functionMoM())();
executeChild;
// >> 1;
executeChild();
// >> executeChild is not a function

```

함수는 스스로 내부에서 자신을 재작성할 수도 있다.

```javascript
function a(){
	console.log('a');
	a = function() {	
		console.log('b');
    }
}
a();
// >> a;
a();
// >> b;
```


함수의 반환과 함수의 재작성을 응용하면 이런 식으로 운용이 가능해진다.


```javascript
function a(f){
 
    if(typeof f === 'function'){
        worker = f;
    }

    function worker(){
        console.log('hello');
    }

    return worker;
}

const t1 = a();
t1();
// >> hello;
const t2 = a(() => {console.log('yaho')});
t2();
// >> yaho;

```

### 클로저

클로저는 자바스크립트의 scope 를 응용한 개념이다.

#### 범위 체인

자바스크립트에는 함수 범위가 있다. 함수에 정의 된 변수는 함수 밖에서는 볼 수 없지만, 함수 코드 블록에 정의 된 변수는 블록 외부에서도 볼 수 있다.


```javascript

let a= 1;
function f(){
    let b = 1;
    return a;
}
f();
// >> 1
b;
// >> b is not defined

```
이 특징은 아래와 같다.

- f() 안에서는 블록 밖 외부 변수 a 와 내부 변수 b가 모두 보인다.
- f() 밖에서는 블록 밖 외부 변수 a는 볼수 있지만, f 함수의 내부 변수 b는 볼 수 없다. 

함수 안에서 블록 밖 외부 변수에 접근할 수 있는 것을 scope chain(범위 체인) 이라고 일컫는다.

scope chain 의 극적인 걸 보여주기 위한 변태스런 코드는 아래와 같다.

```javascript

const global_val = 1;
function outer(){
    let outer_var = 2;
    function inner(){
        let inner_var = 3;
        return inner_var + outer_var + global_val;
    }
    return inner();
}
outer();
// >> 6;
```

클로저는 이러한 scope 의 특징을 활용해, scope 문제로 접근하지 못하는 것을 '곁다리 함수' 를 통해 접근하는 것을 말한다. 여기서 곁다리란 이놈 저놈 다리를 걸치고 있다는 의미로 말한다.

#### 클로저 1

```javascript
let a = 'global var';

const f = function(){
    let b = 'local var';
    a = () => {return b;} ;
}
b;
// b is not defined
(f())();
// local var;

```

#### 클로저 2

위의 예제가 직관적이었다면, 이번에는 조금 복잡하다.

```javascript

let cc; // 자리표시자
const $f = function(){
    let b = 'local var';
    let inner = function(){
        return b;
    }
    cc = inner;
};

b;
// b is not defined

$f();
// 여기서 중요한건 $f() 함수를 실행한 후에야 cc 에 inner 가 할당 된다.
cc();
// >> local var

```

#### 정의와 클로저 3