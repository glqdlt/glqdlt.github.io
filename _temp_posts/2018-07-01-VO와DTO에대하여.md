---
layout: post
title:  "도메인 오브젝트의 정리"
author: "glqdlt"
---
## MODEL (VO와 DTO)

OOP(객체 지향 프로그래밍)에서 빼놓을 수 없는 것이 클래스입니다. 
OOP 에서 클래스는 1등 시민이고, 곧 클래스가 객체가 됩니다. (FP(함수형 프로그래밍) 언어나 자바스크립트의 경우에는 함수가 1등 시민이 됩니다. 객체가 함수가 되는 셈이죠.)
객체와 객체는 각자의 업무와 책임을 가지고 목적에 부여 된 일을 합니다.
여기서 서로에게 자신의 상태를 알리거나 일의 결과를 전달하며 '메세지' 를 주거나 받으면서 협동을 하기도 합니다. 이를 객체 간의 커뮤니케이션이라고 합니다.
이 메세지는 boolean, 값이 될 수도 있고 String 이 될 수도 있으며 Integer 일 수도 있습니다. 심지어는 자바에서는 throw exception을 통해 커뮤니케이션 할 수도 있습니다.
이러한 전달 메세지가 한계에 있을 때, 우리는 List 형이나, Map과 같은 data structure(데이터구조)를 던지기도 합니다.

모델이란 이 커뮤니케이션만을 위한 객체라고 생각하면 됩니다.
위에서 언급한 메세지라고 불리우는 다양한 데이터들을 클래스의 속성으로 담아서 사용하는 '커뮤니케이션만을 위한 객체' 라고 생각하면 쉽습니다.
(사실 위의 메세지나 List, Map도 모델의 범주에 포함됩니다, 서로 다른 것이 아닙니다. 모델은 추상적인 상위 개념입니다.)

민수와 철수가 택배 상하차 아르바이트를 한다고 가정해봅시다.
민수는 1번째 레일에서 작업하고 철수는 3번쨰 레일에서 작업을 합니다. 2번째는 이름 모를 누군가가 하고 있겠죠.
민수의 역할은 추레라(트럭)에서 기사님이 전달해주는 택배 박스를 레일에 올리는 일입니다.
두번째 사람은 레일에서 오는 택배를 서울로 갈지 부산으로 갈지 바코드를 확인해 분류해주는 일을 합니다.
철수는 분류 된 물건을 택배 트럭에 실어주는 일을 하구요.

여기서 택배 박스에 해당하는 것이 모델입니다.
민수와 철수 그리고 이름 모를 두번째 사람은 각자의 고유한 일이 있고, 책임이 있습니다.
민수는 트럭에서 레일로 안전하게 모델을 전달하는 역활.
두번째 사람은 모델을 구분해서 서울/부산으로 보낼지 식별하는 역활.
철수는 식별된 모델을 트럭으로 실는 역활.

좀 더 디테일하게 가보죠.

민수는 트럭의 기사분이 전달해주는 모델을 인자(아규먼트)로 받고, 레일에 모델을 던집니다.
여기서 레일이 민수와 철수 같은 객체가 될 수도 있고, 외부의 통신 프로토콜이 될 수도 있습니다. 메세지 솔루션과 같은 메세지 파이프라인일 수도 있구요.
두번째 사람은 민수처럼 모델을 인자(아규먼트)로 받아서, 내부 메세지를 통해 식별작업을 진행합니다.
택배상자.getTitle(), 택배상자.getAddress() 이런식의 모델의 속성을 확인해서 식별하고 레일에 다시 실습니다.
철수는 식별된 모델을 토대로 트럭에 실어주는 역할을 해내면서 이 택배는 무사히 도착지로 향하게 됩니다.

다른 예를 들어볼게요.

어떤 IT 회사에 김부장과 박대리가 있다고 가정하겠습니다.

김부장이 박대리에게 어떠한 일을 시키는 메일을 보냈습니다.
이 일은 고객에 납품해야할 간단한 Restful API 서버를 구현해야하는 업무입니다.
이 메일에는 고객의 요구사항이 적힌 메일 스레드를 포함하고, 첨부파일로 Interface spec 이 적힌 문서가 포함되어 있습니다.
박대리는 이 메일을 통해 고객의 요구사항을 확인하고, 첨부파일을 보면서 어떤 약속으로 API의 endpoint를 설계 해야할지 확인합니다.
몇 일의 시간이 걸려 박대리는 API 서버를 개발해냈고, 개발한 소스코드와 아티팩트(jar 또는 war) 를 포함한 압축파일을 고객사에게 회신했습니다.

여기서 재밌는 점은 메일이라는 모델을 통해 고객과 김부장 박대리는 커뮤니케이션을 했습니다.
위의 택배상하차에서는 택배물건이라는 목적 자체가 모델이 되었지만, 지금 예시에서는 커뮤니케이션의 수단으로 메일이라는 모델이 사용되었을 뿐
결국 그들이 원하는 만들어야 할 것에 해당하는 것은 박대리가 만든 압축파일 입니다.
박대리는 부장이 보낸 메일에서 메일.getYesterdayMailThread(), 메일.getAttachFile() 속성을 통해 API 설계를 위한 정보를 얻어내고
public 압축파일 buildUpApiServer(){ ... }; 라는 메소드를 통해 (또는 박대리의 부하직원인 막내 사원을 통해서라던지) API 를 만들었겠죠. 

결국 쉽게 말해 모델은 객체와 객체 간의 협동하기 위한 매개체입니다. 일의 목적이 될 수도 있고, 대화를 위한 부자재일 수도 있습니다.
더 쉽게 말하면 커뮤니케이션을 위한 매개체 입니다. 바디랭기지가 될 수도 있고, 말이 될수도 있으며, 문자가 적힌 종이일 수도 있는 셈이죠.





## POJO

POJO 는 객체의 속성만 가지고 있는 DTO 입니다.


## DTO

DTO는 Read / Write 의 성격을 가지는 모델입니다.
이 모델은 객체가 만들어진 이후에 변경을 하거나 추가를 할 수 있습니다.
getter(),setter() 가 모두 다 있는 셈입니다.
DTO의 장점은 쓰기 편하다 입니다.
단점으로는 언제 어디서나 변경이 가능하기 때문에 '신뢰성'을 보장 받지 못합니다.
예를 들면 이런 것이죠.
위의 상하차 예제에서 민수와 철수 그리고 두번째 사람들 중 누군가가 택배 상자를 개봉해서 안의 내용물을 도둑질할 수도 있습니다.
이런 여지를 두는 것이 DTO 입니다. 그래서 저는 별로 좋아하지 않습니다. 이 이야기에 대한 자세한 이야기는 아래 VO에서 더 풀겠습니다.

## VO

VO는 Read-Only 의 성격을 가지는 모델 입니다. 
최초 이후에 변경이 가능한 DTO와는 달리 VO는 setter() 가 없습니다. 오직 getter() 만 있을 뿐 입니다. 
쉽게 말하면 불변의 성질을 가지고 있는 객체 모델 입니다. (자세한 것은 에릭에반스의 'DDD' 를 봐주세요.)

단점으로는 손이 많이 갑니다.
DTO의 경우 getter(), setter()를 만들어주기만 하면 되는 단순하고 손쉬운 코딩이 가능하지만,(롬복을 쓴다면 @Data 어노테이션 한방이면 깔끔하게 만들 수 있습니다.)
VO는 여러 벌의 construct를 만들거나, builder 디자인 패턴을 통해 생성해야 하기 때문에 코드의 라인이 더 많아집니다.
또한 필드(객체 속성)에 접근하기 위한 getter()만 있기 때문에 코딩을 하다보면 construct를 더 만든다던지, private method를 추가로 만든다던지.. 등의 VO 객체 설계를 다시 하기도 합니다.

저는 이 VO를 참 좋아합니다. 손이 많이가지만 '불변성' 으로 얻게되는 '신뢰성' 이 참 매력적이기 때문이죠.
위의 DTO에서도 설명했지만, 상하차 아르바이트에서 택배 상자를 절대 개봉할 수 없다고 전제를 두는 것이 VO입니다.
택배 상자의 내부 물건에 대해 보장이 되는 것이죠. 이런 점으로 택배를 받는 고객은 택배를 신뢰할 수 있게 됩니다. 이래도 택바 상자 안이 벽돌로 있다거나, 잘못된 상품이 왔다던가 하는 것은 판매자가 실수를 하거나 사기를 친 것인거구요.
다시 정리하면 택배 직원들에 대해서는 신뢰를 보장 받는 상태가 됩니다.

VO의 코드라인이 길어진다고 해서 불편할 수도 있지만, 대형 프로젝트나 많은 객체들이 얽히는 복잡한 로직에서 모델링을 해야할 경우에는 DTO보다는 VO를 통해 신뢰성을 보장 받는 것이 오히려 코드 수가 더 적게 만들어지고, 머리도 덜 피곤해집니다.



## BEAN

POJO와 거의 흡사하지만, 직렬화 기능이 내장되어 있다. 

## 그래서 뭘 써야 하는 데?

사실 DTO VS VO에 대한 논쟁은 조금 오래 전부터 있어 왔습니다. 개념적으로 나뉘게 된 것도 ~~~ 때문인데요.
구글링을 해보면 많은 분들이 VO와 DTO에 대해 헷갈려하는 모습을 쉽게 볼 수 있습니다. 가장 큰 특징이 VO에 Setter() 가 있다는 식의 글도 있더군요.. (홈모나 세상에나)


# entity

엔티티는 [Oracle Refrence](https://docs.oracle.com/javaee/6/tutorial/doc/bnbqa.html) 에서 아래와 같이 설명하고 있다.

> An entity is a lightweight persistence domain object. Typically, an entity represents a table in a relational database, and each entity instance corresponds to a row in that table. The primary programming artifact of an entity is the entity class, although entities can use helper classes.

해석을 하면 '경량 지속성 도메인 객체' 라는 말이고, 클래스는 테이블에 클래스의 필드(멤버 변수)는 컬럼에 매핑되는 객체(자바에서는 클래스)를 뜻한다.

# DAO vs Repository

DAO 와 REPOSITORY는 나의 짧은 지식 선에서는 둘 다 영속성 객체이다. 테이블을 핸들링 하기 위한 책임을 지는 객체로 사용되었었다.

DAO 는 Mybatis 에서 Repository는 JPA에서 많이 보였다.

문제는 레거시 프로젝트의 패키지를 정리(사람마다 주구난방인 코드와 패키지를)하면서 어떠한 용어가 옳고 어떨 때 써야하는 지에 대해 궁금해졌다.

아래 레퍼런스들을 읽으며 어느 정도 정리를 해보았다.

[좋은 글](http://egloos.zum.com/aeternum/v/1160846)
[좋은 댓글](https://www.slipp.net/questions/319)
[좋은 글2](https://thinkinginobjects.com/2012/08/26/dont-use-dao-use-repository/)
[좋은 글3](http://toby.epril.com/?p=99)

DAO 는 xml mapper 기반에서 많이 보여진다, 즉 mybatis 같은 프레임워크들에서..

mybatis 는 Database 를 facade 해주는 프레임워크이다. sql 문 같은 것을 좀 더 사용하기 쉽게 해준다. 이 mybatis 를 보면서 DAO 의 정체에 대해 힌트를 얻을 수 있는 데, DAO 는 데이터베이스에 한정 되는 영속성 계층(persistence tier) 에 속한다.

반면, repository 는 영속성 계층이 아니라 한 단계 더 위의 포괄적인 도메인 계층(domain tier)에 포함 된다. 이게 무슨 말이냐면 Repository 가 DAO 위(포함)에 놓여진다는 말이다. 

JPA를 쓰면서 단순히 REPOSITORY 를 DAO 처럼 영속성(DB에 엑세스 하기 위한) 계층으로만 생각했는 데, 이상하게도 아래의

```java
@Repository 
```
라는 어노테이션이 스프링 프레임워크 안에 있던 것에서 느꼈던 위화감이 조금씩 있었는 데, 이게 어느정도 해소되었다.

결론적으로 말하면, Repository 는 영속성 계층이 DB 일지, File 일지, memory 일지, 또는 외부의 RestfulApi 인지를 신경쓰지 않고, 다 포함하는 추상적인 오브젝트이다. 실제 데이터에 해당하는 자바 객체를 저장하기 위한 가장 첫관문이다. 이렇다 보니 DB 를 관리하는 DAO 클래스가 Repository 안에 속하게(포함) 된다는 말이 성사하게 된다.

