---
layout: post
title:  "spring rest template"
author: "glqdlt"
---

JDBC는 connection pool 이 있으면서, http 라는 tcp 연결을 하는 rest template은 막 써왔는 데, 이 녀석도 connection pool 이 있지 않을까? 하는 생각에 시작이었다.

역시나 다를까 [잘정리된 블로그](http://sjh836.tistory.com/141)가 있었다.

2019년 04월

위 블로그에서는 TIEM_WAIT 에 대한 문제를 극복하자고 얘기를 한다. 그런 의미로 connection pool 을 설정에서 처리하자고 이야기를 하는 데, 이 때 발생하는 문제점은 [여기 블로그에서](http://docs.likejazz.com/time-wait/) 확인할 수 있다.

위 블로그에서는 [RFC793](https://tools.ietf.org/html/rfc793)TIME_WAIT 이 왜 MSL(Maximum Segment Lifetime) 정의가 기본값 2분 동안 대기하라고 정의하는 지, centos 에서는 왜 1분간 TIME_WAIT 대기를 하는 지에 대해 이야기 하고 있다.

간략히 말하면 예상치 못한 환경에서의 대응을 위한 여지로 남겨두는 것이 TIME_WAIT 이라는 것인데, 만약 이 TIME_WAIT 을 회피하고자 하는 목적에서 Connection Pool 을 생성해서 TCP 소켓을 계속 재사용한다면 문제의 소지가 있다. 

예상되는 특수한 시나리오는 지연패킷이 발생한 경우를 둘 수 있다. TCP 에서 세그먼트 들 중 동시에 들어온 특수한 세그먼트가 통신 실패한 경우이다. 이 경우 다른 세그먼트에 보내는 리턴 값에 의해 서버입장에서 해당 세그먼트가 성공적으로 통신이되었다고 이해해버릴 수 있다. 클라이언트는 실패한 세그먼트의 ACK 가 오질 않으니, 다시 요청을 시도할 텐데 이 순간이 마지막 세그먼트였다면 서버에서는 소켓을 닫아버리게 되어 더 이상 특성 1개의 세그먼트가 교환되지 않아 무결성이 깨지게 될 것이다. 

이런 이유로 TIME_WAIT 상태로 최종 CLOSE 전에 미처 도달하지 못한 세그먼트들에 대한 처리를 위한 유휴 상태로 남겨두는 것이다.

그렇다면 이런 중요한 문제가 있기 때문에 커넥션 풀을 사용을 꺼리게 하더라도, Maximum 소켓 사용에 의한 병목 현상이 일어나게 되는 걸 막을 수 있을까? 이에 대한 고민이 많다. TIME_WAIT 단계의 가장 오래된 녀석을 재활용한다던지 처리를 하면 어떨까? 하는 생각이 있다. 또한 이 녀석이 가장 오래된 녀석이지만 TIME_WAIT 생명주기를 1분 기준으로 봤을 시 30초 이상을 사용된 녀석만 재활용한다는 식의 제약을 두는 것이다.