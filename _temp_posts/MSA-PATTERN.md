# MSA 디자인패턴


이 포스트의 모든 패턴은 [microservices.io](https://microservices.io/index.html) 에서 가져온 내용이다.


- ASIS

    - [패턴 : 공유 데이터베이스](https://microservices.io/patterns/data/shared-database.html)

        - 이 패턴은 서로 상이한 도메인 컨텍스트를 가진 컴포넌트(서버 인스턴스 등)가 스키마는 나누고 물리적인 같은 DB를 사용하는 걸 말한다. 같은 DB 를사용하지만 스키마 경계가 나누어져 있고, 컴포넌트는 독립적이기에 독립적인 배포가 가능하다. 또한 RDB 인 경우 DB 내에서 로컬트랜잭션이 가능하기 때문에 글로벌 트랜잭션이나 사가, 이벤트 드리븐과 같은 복잡도가 높은 패턴 없이 쉽게 트랜잭션 오스케스트레이션이 가능하다.
        - 단점은 로컬트랜잭션으로 인해 쉽게 트랜잭션 오케스트레이션이 되지만 그만큼 커플링이 강해서 병목이슈(공유 락킹)가 생길수 있다. 또한 같은 물리적인 호스트를 사용하기에 IO 공유로 인한 병목, 장애의 전이, 메인터넌스(점검) 시 영향을 같이 받음 등이 있을 수 있다.

- TOBE
    
    - [패턴 : 서비스 당 데이터베이스](https://microservices.io/patterns/data/database-per-service.html)
    
        - 공유 데이터베이스의 커플링 문제를 해결하기 위한 근본적인 해결책이다. 즉, DB를 물리적으로 나누는 것이다.
        
        - 단점은 당연하겠지만, 로컬트랜잭션이 불가능하다. 즉 이 경우 공유 데이터베이스의 장점이었던 부분이 없어져서 복잡도가 높은 트랜잭션 오케스트레이션을 직접 구성해야한다.
        
            - 조회의 경우 [API COMPOSE 패턴](https://microservices.io/patterns/data/api-composition.html)이나 [CQRS 패턴](https://microservices.io/patterns/data/cqrs.html)을 통해 합성된 임시 뷰 테이블을 구성해서 조회를 하도록 접근해볼수 있다.
            
            - 트랜잭션의 경우 [SAGE 패턴](https://microservices.io/patterns/data/saga.html)으로 한다. 이 경우 이벤트 드리븐을 적용하기 위해 메세지 브로커가 필요해지며, [이벤트소싱](https://microservices.io/patterns/data/event-sourcing.html) 방안으로 구성되어야 하기 때문에 기존의 DB CRUD와 개념이 다르다. 모든 것은 로그(사실 로그는 아니지만) 데이터를 통해 멱등성을 지킬수 있게 유지해야하는 데, 이 부분이 매우 낯설수 있다. 
            



[패턴 : 이벤트 소싱](https://microservices.io/patterns/data/event-sourcing.html)

이벤트 소싱은 이벤트 드리븐에서 원자성을 지키는 방안에 대한 내용이다. 2PC 가 필요하지 않는 이벤트 드리븐에서 어떻게 원자성을 지킬것인가? (원자성이란 무조건 성공하거나, 그게 아니면 무조건 롤백되어야한다.) 에 대한 고민으로 모든 데이터를 기억하는 것으로 원자성을 지키도록 한다. 이벤트 소싱이란 뜻은 이벤트를 소스로 사용한다는 것이다. 즉 이벤트에 이벤트가 발생할 당시의 모든 데이터를 기록(스냅샷)하는 것을 의미한다. 이벤트가 발생당시의 상황을 기록하니 실패에 따른 롤백은 무조건 회귀할수 있게 된다. 다만 조심해야할 것은 회귀가 가능하도록 이벤트를 기록하는 방안을 고민해야 한다. 예를 들어 캐시 지급의 경우 유저 총 보유 재화를 스냅샷 하는 방향보다는 얼마를 누적시켰는지에 대한 스냅샷을 남기는 것이 회귀하는 데에 용이하다. 

총보유량 스냅샷의 경우

- {seq : 3, userId: jhun, cash : 30000}
- {seq : 2, userId: jhun, cash : 20000}
- {seq : 1, userId: jhun, cash : 10000}

누적에 대한 스냅샷

- {seq : 3,userId: jhun, updateCash: +10000}
- {seq : 2,userId: jhun, updateCash: +10000}
- {seq : 1,userId: jhun, updateCash: +10000}
 
누적에 대한 스냅샷은 현재 돈이 얼마가 있던지 간에 지급(+) 했던 캐시를 그대로 차감(-) 해버리면 된다. 만약 차감이 어떠한 사유 등에 의해 불가능하다면 1년이 지나서라도 차감시켜버리면 된다. 반면 총부유량의 스냅샷은 이전 로그와 현재 로그를 비교해야하는 문제가 생기기 때문에 롤백시키는 데에 복잡도와 어려움이 따른다.



### 메세지 브로커에 대한 의존성?

메세지 드리븐 방법론으로 접근하면 메세지를 전달하는 방법인 메세지 브로커(또는 exchanger) 에 대한 의존도가 매우 높아진다. 즉, 메세지 브로커 플랫폼에 장애가 발생하면 모두가 망하는 커플링이 강하게 생길수 있다는 걸 의미한다. 이럴 경우에 대한 해결책에 대해 고민해보았다.

만약 각 서비스 노드에서 메세지브로커로 이벤트를 알리지 못한다면, 이벤트를 발송하는 것에 대한 실패를 다시 회귀하는 방안을 고민하면 된다고 생각한다. 즉, 메세지 브로커에 대한 네트워크 접근을 못하는 상황(TIMEOUT 이 떨어진 상황)이 발생한다면 내부적으로 이를 캐시해두고, 또는 별도의 데몬이나 배치 모듈에 위임해서 어떻게든 전송할수 있게 한다. 메세지가 너무 늦게 발송이 되었다면 메세지를 수신하는 측에서 이 메세지의 유효기간을 알수있는 방법도 있다면 너무 오래되어서 무시할지를 판단할수 있다.  이 경우 아래의 시나리오를 생각해볼수 있다.

예를 들어서 4개의 서비스 (프론트(UI), 주문, 상품, 결제, 배송) 가 있다고 가정하자.

1. 프론트에서 유저의 주문 신청 이벤트를 주문 서비스에 요청한다. 참고로 유저는 이미 결제 요청을 한 상태이다.

2. 주문 서비스는 주문이 들어왔음을 상품과 결제에 이벤트를 알린다.

3. 상품은 상품의 재고를 하나 없애고, 결제는 상품에 대한 결제를 진행한다.

4. 그런데 여기서 결제는 성공했으나, 상품의 재고가 여러 유저가 동시에 구매한 탓에 재고가 0이어서 -1 이 불가능해졌다.

5. 그런데 엎친데 덮친 격으로 상품 서비스에서 메세지 브로커로 통신이 안된다. 

6. 어떻게 알리지??

위의 시나리오에서 상품 서비스가 자신의 서비스에 문제가 있음을 외부에 알려야하는 그 수단이 없어서 문제가 발생한다.

이 경우는 어떻게 해야할지를 고민했었다, 조금 고민해보니 매우 쉽게 해결할수 있겠더라. 바로 최초의 이벤트 발행 때, 이 이벤트의 최종 처리되어야할 마감시간을 같이 알려주는 것이다.

이를 적용해서 다시 시나리오를 돌이켜보자

1. 프론트에서 유저의 주문 신청 이벤트를 주문 서비스에 요청한다. 참고로 유저는 이미 결제 요청을 한 상태이다. 

2. 주문 서비스는 주문이 들어왔음을 상품과 결제에 이벤트를 알린다. 이벤트 발생시간 : 오후1시00분, 이벤트 최종 완료시간 : ~10분 

3. 상품은 상품의 재고를 하나 없애고, 결제는 상품에 대한 결제를 진행한다.

4. 그런데 여기서 결제는 성공했으나, 상품의 재고가 여러 유저가 동시에 구매한 탓에 재고가 0이어서 -1 이 불가능해졌다.

5. 그런데 엎친데 덮친 격으로 상품 서비스에서 메세지 브로커로 통신이 안된다. 

6. 주문 서비스와 결제 서비스는 ~10분이 지났는데도 최종 완료 처리가 되지 않자, 모두 각기 롤백한다.

7. 상품 서비스는 네트워크가 단절되었지만 ~10분이 이미 지났기에 아마 취소됬을거라고 알수있다. 따라서 이에 대한 로깅만하고 취소해버린다.



### 도메인 컨텍스트 해석기(번역기)

게임회사에 있을 때, 각 게임에서 자신들의 게임을 가르키는 code와 name 이라는 속성을 제각각 사용했다. 예를 들어서

모바일 게임 X라는 게임이 있다면, 게임부서는 {code :1001, name : mgame_x} 라고 표기하는 반면, 웹서포트부서는 {code : 1, name : mob_game_x} 라고 표기 했다.

이런 상황은 많은 에러를 낳았다. 당시에 리더들은 포맷을 통일화 하자고 했고, 공유 DB를 두어서 관리하도록 했다. 무리 없이 진행되는 듯 했지만, 또 다른 문제를 낳았다. DB에 대한 메인터넌스 작업 시에 (위에 공유 DB 패턴 참고) 모든 서비스가 중단되었고, 게임이 하나라도 추가되면 누가 이를 관리해야할지를 부서 간 폭탄돌리기를 하며 항상 매끄럽게 흘러가지 않았다. 

DDD 에서 이에 대한 얘기가 나오는 데, 각자 개별적으로 관리해야 하나 절대 변하지 않는 아이덴티티를 부여해서 서로 약속하기로 한다 (예를 들어 code 값은 모두 맞춘다. 관리는 따로따로 한다.) 이게 불가능하다면 어느 한쪽이 해석기를 제공해야 한다. 즉, 게임부서에서 mog_game_x 라고 얘기하는 게임을 웹서포트 부서에서는 mob_game_x 라고 해석해서 사용해야 한다 등의 이야기이다, 당연한 이야기이다. 이 경우 웹서포트 부서에서 부하를 가지게 된다. 이를 에릭에반스의 DDD에서는 오염이 되었다 등의 내용으로 설명한다.

