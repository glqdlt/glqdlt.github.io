---
layout: post
title:  "AWS SEOUL 2018 후기"
author: "glqdlt"
---

# AWS-SEOUL-2018

## 들어가며


<img src="/images/aws-seoul/2.jpg"/>

### 첫인상

첫 인상은 작년에 참관 했던 AWS 행사에 비해 규모가 꽤 작아졌다는 인상이었습니다. 그러나 작년에는  'AWSOMEDAY-2018' 를 갔었던 것이기에 다를 수 있다는 것을 감안하면 작은 규모에 비해 행사 자체는 나쁘지 않았습니다.

### 스케쥴

<img src="/images/aws-seoul/1.jpg"/>

행사는 총 5개의 트랙으로 진행되었습니다. [공식 행사 일정표](https://aws.amazon.com/ko/events/devday/)

1. 엔터프라이즈

2. 클라우드 네이티브

3. 인공지능

4. 핸즈온랩

5. 커뮤니티

각 트랙은 행사 이름만 보아도 유추가 되듯, 그에 걸맞는 주제 별 세션이 구성되어 있었습니다. 엔터프라이즈 쪽에 관심 가는 내용이 많았는 데, 참관 선정으로는 커뮤니티 트랙 위주로 스케쥴을 잡았습니다.

이유로는 Non Cloud 환경에서 Cloud 기반으로 마이그레이션 하는 현재 회사 상황을 고려해서 최대한 도움 될 만한 주제로 잡기로 했습니다. 이렇다 보니, AWS 자체의 심도있는 기능적인 부분에 대한 부분보다는 Cloud 기반에서 공통적으로 일어날 법한 주제들 위주로 선정하게 되면서, 자연스레 커뮤니티 트랙으로 가게 되었네요.

그래서 결정한 스케쥴은 아래와 같습니다.

1. 서버리스 엡 배포 자동화 

2. 스타트업 관점에서 본 AWS 선택과 집중

3. 데이터센터 1도 모르는 개발자가 AWS를 만났을 때

스케쥴은 그럭저럭 원하는 내용 위주로 스케쥴이 잡혀졌는 데, 후기에도 다시 말하겠지만 행사장 안에서 아무리 찾아봐도 커뮤니티 트랙이 보이질 않았습니다. 이리저리 찾아 보다가 안내 요원에게 물어보니 커뮤니티 트랙은 2층에 있었다는 걸 알게 되어서 부랴부랴 간 기억이 있었네요.  주변에 안내판이라도 있었다면 좋았을 텐데..


## 세션

전과 마찬가지로 세션의 내용 요약은 편하게 음슴체로 하겠습니다.

### 1. 서버리스 앱 베포 자동화

발표자 : 김필중 AWS 솔루션즈 아키텍트

#### 세션을 시작하기에 앞서, 서버리스가 무엇인지를 간략히 짚고 넘어가야함.

#### 서버리스 

서버리스란, 비지니스 서비스를 구축하는 데에 있어 서버(하드웨어)를 고려하지 않고 서비스를 구축하고 실행할 수 있게 하는 솔루션. 

사전에 정의 된 코드만 작성해서 AWS에 서버 서비스 로직을 구동시킬 수 있게 하여 클라이언트 입장에서는 물리적 서버 구성 없이도 해당 기능을 이용할 수 있는 클라우드 서비스 모델을 말함. 
 
AWS 에서 가장 쉽게 접하는 형태이고, 가장 유명한 것이 람다가 대표적임. (Azure 에서는 Azure Function 라 불리움) 이는 클라우드를 가장 잘 활용할 수 있는 모델이기 때문.  (기존 벡엔드 기반의 서버 어플리케이션 설계와 구현이, AWS의 람다 서버리스에 코딩하는 걸로 바뀐 정도. 플랫폼에 AWS 위에서 동작하는 백엔드 로직이라고 생각하면 편함.)


#### 서버리스로 인해 얻는 이점

1. 관리할 서버가 필요 없음 : 이는 엔지니어 관점에서의 이야기인데, 부가적인 운영 관련 잡다구리한 걸 잊고 코드에만 집중할 수 있음

2. 유연한 확장 : 오토 스케일링의 지원

3. 높은 가용성 : High Avalilty 에 관한 이야기

4. 유후 자원 없음 : 이는 사용한 만큼만 비용이 발생하기 때문. EC2 는 서버가 떠있는 시간에 비해 서버리스는 기능 요청 시작과 종료에만 비용 발생


#### 서버리스 APP 을 위한 최소한의 할일.

1. 함수 작성 (코드 준비) : python, javascript, java, c#...

2. 람다에 함수(코딩)를 업로드

3. 이벤트 소스 연결 : 이 연결이라는 것은 작성한 함수가 AWS 에서 실제 함수의 기능이 수행 되는 인프라에 작동하게 적용하는 거로 생각하면 됨.



#### 람다의 실행 모델

> 동기, 비동기, 스트림 기반 

- 동기 : API Gateway

- 비동기 : S3 과 대표적인 모델

- 스트림 : 실시간 데이터 생성, 메세지 솔루션을 통해 전달

    - 웹 앱을 위한 엔드포인트 : API Gateway

    - 서버리스 활용

#### 배포 파이프라인

기본적으로 웹 서비스의 어플리케이션 배포 파이프라인은 아래의 형태를 띔

> 소스 > 빌드 > 테스트 > 프로덕션

- 지속적 통합 : Continuous Intergration. 

    이 통합에서는 소스 > 빌드 > 테스트 까지의 과정만 담당함. 보편적인 모습. 

- 지속적 전달 : Continuous delivery

    소스 > 빌드 > 테스트 > 프로덕션 까지 모든 파이프라인 포함이지만, 최종승인자나 어떠한 장치가 최종 승인을 해주어야 Production 에 반영하는 구조.

- 지속적 배포 : continuous deployment

    지속적 전달과 똑같이 소스 > 빌드 > 테스트 > 프로덕션 까지 모든 파이프라인 포함하는 구조. 단, 결정적인 차이는 최종승인자가 필요하지 않고 Automatic 으로 Production 에 반영이 됨. 가장 이상적인 형태.

#### CodeStar (AWS 솔루션)

자바로 치면 [스트링 이니셜라이저](https://start.spring.io/)랑 유사항 형태의 Project Code Generator. AWS 포탈에서 청사진(소스 템플릿을 AWS 에서는 청사진이라 표현함)을 선택하고 조합해서 원하는 프로젝트를 쉽게 프로비저닝 하는 솔루션

#### 새 버전의 코드 배포에 대한 고려사항

서비스 운영에서 A,B 테스트와 같이, 신규 버전과 과거 버전 간을 전개할 수 있는 경우가 있음. 이에 따른 고려 사항은 아래와 같음.

1. 사용자에게 미치는 영향 최소화

2. 롤백 기술

3. 실행 모델 요소

4. 배포 속도

#### 서버리스의 배포 패턴

1. ALL-At-Once

    단순하게 모든 인스턴스를 통째로 변경하는 것을 말함.

2. B/G Deploy

    특정 인스턴스를 변경 대상으로 선택하고, 이 인스턴스의 트래픽만 원격 차단되면서 신규 버전으로 배포를 준비함. 내부적으로 유효성 검사 이후 안전하다고 판단되면 배포를 시작, 배포가 완료 되면 차단 된 트래픽을 복구시키고 다른 과거 버전에 대해 이를 반복.

3. [Conary/Linear](https://docs.aws.amazon.com/ko_kr/codedeploy/latest/userguide/welcome.html)

- Conary 
    
    B/G 와 거의 유사하지만, 트래픽 조작을 정밀 하는 형태. B/G 가 전체 인스턴스 중에 1개씩 진행하는 것에 비해 Conary 는 설정에 따라서 전체 인스턴스의 과거 버전과 신규 버전의 운영 비율을 조절해가면서 배포하는 형태임.

    예를 들면 전체 100개 중에서, 최초 B/G 로 100% 중의 1%인 1개의 인스턴스에만 배포를 시작하고, 그 후 몇 분 뒤인 10% 인 10개의 인스턴스에 배포, 다음으로는 50%인 50개의 인스턴스에 배포.. 이런 식으로 선형적으로 배포하는 걸 말함.

- Linear 

    Conary 와 비슷하지만, 일정한 시간에 동일한 증분으로 동일한 비율로 배포를 하는 형태.


#### 서버리스 배포를 위한 도구

1. AWS CloudFormation 

2. AWS Serveless APp Model (SAM)

    CloudFormation 이 다루기 어려워서 좀 더 쉬운 형태의 솔루션을 만듬.

#### API 명세를 위한 Swagger 활용

늘어 나는 API 엔드포인트 사양을 다 기재하려면 엄청난 노가다임, AWS 에서는 Swagger 와 연동해서 쉽게 API 엔드포인트를 쉽게 정리할 수가 있음.

#### AWS Servlerless App REpository

github 처럼 sam 템플릿을 저장하는 repository를 커뮤니티처럼 운영해서 쉽고 빠르게 타인의 안정적으로 운영했던 청사진(탬플릿)을 사용가능

#### 람다 함수 버전 및 별칭

- 버전 
    
    변하지 않는 함수의 고유 버전

- 별칭 

    버전을 가리키는 변하는 라벨

#### 람다 버저닝 모범 사례 

```$LATEST``` 버전을 기반으로 개발

#### 단계 변수와 람다 별칭

람다 함수 와 실제 함수에서 운영 스테이지마다 호출 되는 API를 별칭으로 두고 처리

    예시) Prod : Production, Stg : Staging, Dev : Develop

#### 람다 별칭 트래픽 이동 및 안전한 배포

routing-config 파라미터를 추가해서 람다 함수에서 다른 두 버전을 가르키게 하고, 각 버전 별로 수신 트래픽의 비율을 지정시켜 할 수 있음.

예를 들면, 안정버전과 신규버전이 있다면, 안정버전에 80%, 신규버전에 20% 의 트래픽을 분산시켜서 장애에 대한 최소한의 피해를 처리할 수 있도록 할 수 있음.

#### 람다 별칭 트래픽 이동 및 AWS SAM

엔드포인트 접근이 실패할 경우 '알람' 설정이나 '특정 함수' 를 실행하도록 처리가 가능

#### 람다 작성 온라인 ide 

웹 IDE에서 코드 어시스턴스, 브레이크포인트, 디버깅도 지원함. (발표자 왈, 꼭 보여주고 싶었다며 직접 시현도 함.)


#### 서버리스를 마이그레이션 했을 떄의 이점

API 백엔드에서 새로운 기술을 쉽게 적용

1. 새로운 언어

2. 새로운 프레임워크

3. 람다 함수로 특정 기능 구현 후 연결

#### 람다와 API 게이트웨이의 차이점

- 람다 

    단일 함수 수준에서 제어, 서비스 호출 시에 투명성을 제공

- API 게이트 웨이 

    URL 엔드포인트 수준에서의 제어, 클라이언트에서 호출 시에 투명성을 제공(DNS 서버 랑 비슷하다고 보면 됨)


#### 모범 사례

canary 와 b/g 는 사실 요즘에 와서는 default 한 선택이라고 생각함.

개발, 테스트, 스테이징, 프로덕션 환경을 위해 가능한 항상 분리된 스택을 유지

#### Local 개발

로컬에서 함수 테스트 및 디버깅이 필요함. AWS SAM CLI(기존에는 SAM LOCAL) 툴이 생기면서 여러가지를 할 수 있어짐

> npm install -g aws-sam-local

(시연에 사용 된 람다 펑션 syntax 도 그렇고, 대부분의 툴은 Javascript 를 default 로 사용하는 걸로 보여짐)

#### codebuild : 높은 수준의 람다 테스트

람다의 경우 온 클라우드상에서 실행하다 보니, 로컬 테스트 하기가 조금 까다로웠음. 그러나 CodeBuild 가 탄생하면서 AWS 람다 환경과 비슷한 도커 컨테이너에서 테스트가 가능해짐. 실제 람다 클라우드 환경과 달리 커넥션 타임아웃을 없앨수도 있음.

#### 서버리스 어플리케이션 로깅 : CLoud Watch


#### 서버리스 앱 문제 해결의 접근

기본적으로 적절한 로그를 기록하는 것 부터 시작하는 것이 중요.

#### 조금 어려운 문제들

Q. 복잡한 MSA 에서는 어떻게 로깅을 처리함?

Q. 이걸 다 어떻게 관리 & 트랙킹 함?

A. central log repository 를 구축한다던지 해야는 데.. 현실적으로 쉬운 게 아님.

### AWS X-RAY

위의 '조금 어려운 문제'들을 해결해주기 위한 AWS 솔루션

각각의 인스턴스나 컨테이너마다 일종의 가상맵을 그리며 각 레이턴시 데이터와 에러 빈도를 보여줌.

#### 콜드 스타트

자바와 같은 JVM 기반 언어는 람다 실행시에 JVM이 플랫폼에 올라와야해서, n 초의 준비시간이 필요함 이를 콜드 스타트라고함.

X_Ray 에서는 이러한 콜드 스타트도 체크가 가능.

문제발생한 포인트에는 stacktrace 도 찎혀있기 떄문에 쉽게 파악이 가능해짐.

#### 생태계

1. CI

젠킨스 클라우드, tracis CI, CODESHIP

2. 로깅 및 모니터링

IO/pipe 가 요즘 인기


#### 정리

다양한 기능들을 활용하여 안전하고 제어된 방식으로 람다 함수 배포

자동 롤백은 배포 관련 문제 복구를 위한 가장 빠른 방법

이벤트 모델과 워크로드 크기에 따라 적절한 배포 패턴을 선택

서버리스 어플리케이션을 다양한 배포방식 으로 배포 가능

서버리스 앱은 로깅과 모니터링 기능이 빌트인 포함되야함

강력한 도구인 X-Ray를 활용하여 문제점을 시각화 하여 해결 (없다면 Central logging repository를 만들어야함)




### 2. 스타트업 관점에서 본 AWS 선택과 집중

(ㅅㅂ 커뮤니티 트랙이 본 행사장인 1층이 아니고 2층에 숨어 있어서 찾지어려웠음. 그래서인가 참관 사람도 많이 없네)

커뮤니티 트랙.

한승호, 에텐탈 CTO

- 스타트업에서 AWS 도입하기

AWS 서비스 블록이 너무 많아짐 ㅠㅠ

인프라 고민은 줄어들고 블록을 고민하는 시대

- 스타트업 with aws

스타트업이 아닌 사내 신규 서비스에도 적용되는 내용

1. 시작 단계 AWS 서비스 찾기

2. 성장 단계에서의 AWS 서비스

- 에멘탈 서비스 특징 소개

'비즈넵' 서비스 특징

경영 데이터 세무 회계 SAAS

- 스타트

AWS 를 아는 사람 1~2명

데이터도 없고, 개발자도 없고, 사람도 없음.

- 스타트업 초기 목표

비용을 절약해서 적은 인력으로 빠르게 MVP 개발 (투자를 위해 구현에 집중)

- 학습

MVP 단계에서는 최소 단계로 학습

(사내 내부 팀에서 할 경우에는>)

- 초기 단계 아키텍처의 함정

초기단계에서는 MSA 서버리스는 개발속도를 높여주지 않을 수 있따.

MSA 보다는 모놀로틱

개발 할 내용 자체가 크지 않은 경우가 많아서 모놀로틱이 편할 수 있음

서버리스 보다는 서버

창업전부터 서버리스를 알고있었다면 서버리스가 좋을수있지만, 익숙치 않다면 비추천

- DB 선택하기

목적에 맞는 데이터베이스 선택

데이터 크기, 용량, 아이템 크기, 건수, 내구성

그런데 스타트업에서는 춥고 따뜻함이 없음 자신에게 가장 익숙한 DB 로 우선 개발 하는 것이 중요함.

마켓핏 이후에 충분히 마이그레이션 가능

- 추천하는 AWS 서비스

1. EC2, 서버리스보다는 AWS beanstalk

2. 다이나모DB 보다는 RDB

- 서비스 소개사이트 MVP

클라우드프론트 + certicatemanager + s3

- 프로덕션 마켓핏 전략

최소 요구사항에 맞춰 익숙한 개발환경을 구축하여 MVP 개발에 집중

- MVP 이후 성장하는 팀

사용자 증가, 개발자 증가, 팀 개수 증가, AWS 리소스 증가, 고정비용 증가 효율적인 확장을 위한 준비가 필요해짐.

- 스타트업의 성장

'에멘탈' 기준으로 스타트업 성장 3단계

마켓핏 > 전환 > 성장


- 성장 단계에서 선택한 AWS 서비스

API 서버, DB, 내부관리

- API를 구축하는 n 가지 방법

자신이 파악하기에는 7가지까지 할 수 있음

- 서버리스, EC2, 컨테이너

서버리스 : 자유도가 한정된 유일한 단점, native 모듈 사용이 어려움. 로그 분산됨

EC2 : 

EC2 & 컨테이너 : 

자신이 생각하는 가장 중요한 포인트가 독립성에 대해서 생각한다고 함

- 성장단계에서 활용한 컴퓨팅 서비스

aws 람다는 어느 시점이던 활용도가 높음

초기에 펑션 관리의 어려움이 있을 수 있음

중요한 비지니스 로직 보다는 보조적으로 활용함

- 데이터의 성장

데이터가 쌓이기 시작하고, 느려지기 시작하고 그러니깐 캐싱이필요해짐

그리고 데이터를 클랜징하고 분석하고 싶은 욕구가 생김

- 다이나모 DB

프로비저닝 용량을 구입하면 초기에도 저렴하게 활용 가능함

주 보다는 보조적인 성격으로 사용하고 있음

전환단계에서느 RDS > 오로라로 변경

- 내부 관리의 필요성

AWS 리소스 증가

이벤트 증가

IAM(권한 정책) 증가

개발자 증가

- 내부관리 정책과 IAM

초기에는 스테이지 분리 (QA 나 PROD 말함)

전환 단계에서 VFC와 Network 분리. IAM 관리 할 때.

성장 

로깅이나 이벤트가 많아지다 보니, 알림 같은 것이 필요해짐

화이트리스트 방식의 IAM 관리

- 성장하는 조직에 적합한 아키텍처

성장하는 팀과 서비스를 위한
확장하기 편한 아키텍처 설계

- 서비스 아키텍처

- AWS 서비스 선택

- 개발 문화


- AWS  + @ 3년동안 노하우, 팁 공유

AWS Console 에서 지원하지 않는 기능이 SDK에 있는 경우가 있음.

- Wrap CLI 활용하기

- Wrap SDK 만들기

자주 쓰는 기능에 대해 관리를 위해 Wrap SDK 를 만들었음

- AWS Fully Managed Service

1. saas

2. servless

3. EC2 를 내부적으로 사용하지 않는 것

- :)

AWS 서비스 선택 전략

익숙한 인프라 AWS, AWS + @

- Best Practice 를 위한 지속적인 개선



- 모놀로틱 에서 MSA로 전환할 떄 헤프닝이나 조언해줄 만한 것이 없는가?

가장 고민 되었던 것이 RDB 와의 커넥션인데, 처음부터 분리를 염두해두고 했기 때문에 TCP 커넥션이 아니라 HTTP 프로토콜 형태로 구성을 했었음.

서비스 규모가 작기 떄문에 서비스 레이어 별로 인스턴스를 크게 분리하거나 많이 만들 필요가 없기 떄문에, 어플리케이션 서비스 내에서 모듈을 분리할 수 있는 형태로 개발하고 있음.

요점은 쌩 모놀리스가 아니라, 추후에 확장할 수 있는 여지는 생각해보아야 한다고 조언해줌.




### 3. 데이터센터 1도 모르는 개발자가 MSA를 만났을 떄

안주은 / MyMusicTaste devops 엔지니어

1. who am i

처음 만난 장고 앱을 클라우드에 올림. 

문제를 효율적으로 풀기, 쉽게 풀기.

효율적으로 하면 충분한 개발 시간과 숙련된 사람들이 필요함.

이상 =/ 현실

희망을 갖지 않기로 했따.

꼭 필요할 떄만 우리가 만들자

꼭 필요할 때만 운영하자



2. the main problems we've solved

- msa

MSA 는 혼돈의 제왕. 

곁가지를 쳐내자. 관리 포인트를 줄이자.

사내 프레임워크 개발, 공통적으로 해야하는 기능들을 모듈로 뽑음

스타트업에서는 폴리그랏이 이상적일 때가 많음.

컨테이너 오케스트레이션을 어떻게 할 것인가?

도커 스웜을 갈까? 쿠버네티스를 갈까? 처음에는 스웜을 선택했는 데, VM 도 관리해야하고 복잡했음

AWS Fargate 를 선택함

Fargate 로 오니 task degination 만 적용하니 쉬웠음

VM 도 스케일아웃을 어떻게 해야할지 고민해야는 데 Fargate 가 다 처리해줌

그런데 제한 사항이 몇개 있음

네트워크 관련, 로깅 관련

비용 측면에서는 Fargate 는 비쌀 수 있음. 기존 ECS 기반에 비해 30% 정도의 비용 증가가 생길 수 있음. 그런데 개인적으로는 비용을 투자하고 편해져서 진짜 문제에 집중하는 게 좋지 않을까 생각함.

로깅 관련

fargate 에서 스트림으로 el 에 쏴버리고 KIBANA로 뷰잉

CI/CD

젠킨스 > 테라폼(TerraForm) > AWS Fargate

테라폼으로 간단하게 B/G 처리하게 함.

시크릿 매니지먼트 

개발자가 왜 Key 를 관리해야하지? 오픈 소스 Vault 를 도입함.

그런데 테라폼에서도 Vault 의 아키텍처를 미리 준비해놓은게 있음




- spa



장고 탬플릿 기반에서 react 로 넘어갈 때의 문제 공유

CORS(같은 도메인으로 보게 어케 할 것인가), OG, SEO(서버 사이드 랜더링을 해야하나)

람다edge 를 통해서 처리함

람다에 도착하기 전에 프록시처럼 http 헤더를 후킹할 수 있음.

이를 통해 CORS를 처리함



3. 솔루션

devops 관점 vs devloper 로서의 관점

소수 devops vs 다수 devops 에서 아키텍처가 달라져야하나

대부분 스타트업에서는 긴밀하게 빠르게 구현하게 하다 보니, devops 에 초첨을 보게 됨


누구나 쉽게 운영 변경할 수 있는 인프라 설계

누구나 쉽게 운용 변경할 수 있는 오토메이션 설계

My Music Taste

- 보너스

RDS 에서 다이나모 DB 로 옮길 떄, 전체적으로 테이블 디자인을 보고 옮겨야함.

key value 가 맞는지 안맞는지도 봐야함. 우리도 고생중임






## 후기

평소에도 그랬지만 이것저것 궁금한 사항은 세션 마다 질문을 하는 편임. 그런데 유독 이번 컨퍼런스에서는 다른 사람들의 질문은 실전적인 운영적인 측면에서의 질문이 많았음. 더군다나 그 질문에 포함 된 단어들도 생소한 부분이 많아서 단순 학습과 관심만으로는 쫓아가는 데 한계가 있다는 걸 느낌. 

앞으로 닥쳐 올 Azure 기반의 서비스 구축에서, 보다 심도 있는 운영 경험을 겪어서 다음에는 저들과 함께 대화를 해보고 싶다는 생각이 듬.