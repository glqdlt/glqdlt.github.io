---
layout: post
title:  "객체지향설계노하우"
author: "glqdlt"
---

나름 프로그래머로서 객체지향 프로그램을 설계 했던 그간의 경험을 정리해보는 시간을 가집니다.

## 상속(확장(extends)과 구현(implements),inhernce) 그리고 구성(composition)

### 개념

#### 상속_확장(extends)

확장은 말 그대로 어떠한 타입에서 더 추가로 확장하겠다는 개념입니다.
기본적으로 어떠한 대상 타입을 더 추가로 확장하는 것이기 때문에, 어떠한 대상의 모든 속성(필드)과 기능(메소드)을 사용할 수 있습니다.

대상 타입과 확장 타입이 서로 is kind of (is a) 에 관계가 놓여지기 때문에, 상속(inhernce) 관계라고도 설명할 수 있습니다.

```
BIRD <|-- PENGUIN

> PENGUIN is kind of BIRD 
```



#### 상속_구현(implements)

구현은 어떠한 설계도면을 펼쳐두고, 해당 설계도에 따라 구현을 한다는 걸로 이해하면 쉽습니다. 프로그래밍적으로 보면 인터페이스(설계도면)을 두고, 해당 인터페이스의 바디(로직 또는 알고리즘)를 채운다(구현)고 합니다.

인터페이스와 구현체가 is kind of (is a) 에 관계에 놓여지기 때문에, 상속(inhernce) 관계라고도 설명할 수 있습니다.

```
TurboEngineAble <|.. BENTZ

> BENTZ is turboEngineAble
```

인터페이스의 경우 자바 API들을 보면 ~able로 끝나는 것을 볼 수 있습니다. 자바의 기본 내장된 인터페이스들을 보면 ~able 이라고 네이밍 된 것을 볼 수 있습니다. able의 의미는 ~무엇할 수 있어야 한다로, 대상의 기능적 정의를 나타내는 특질이라 합니다. 조직 또는 사람에 따라서 ~Can 이라고 하는 경우도 있습니다. 자바의 인터페이스는 다중 상속을 지원하며 특질(trait)의 성질을 지니기 때문입니다. 

```

CAR <|-- BENTZ (extneds)

> BENTZ is kind of car 

TurboEngineAble <|.. BENTZ (implements)

> Bentz is turboEngineAble 벤츠는 터보 엔진 기능이 됩니다. (콩글리쉬)

ComestibleAble <|.. BENTZ (implements)

> Bentz is comestibleAble 벤츠는 편안한 기능이 됩니다. (콩글리쉬)

> 즉, 결론적으로 벤츠는 자동차이며, 터보 엔진과 편안한 기능이 됩니다.

```

#### 연관, 의존(Association,Dependency)

연관은 상속(확장과 구현)과 다르게 has a 의 관계를 가집니다. 즉 자신에게 어떠한 속성이나 기능이 존재 하지 않고, 타인의 속성이나 기능을 가지는 형태를 말합니다.

기존에는 집합(Associtation) 이라 표현했으나, UML2.0 부터 연관(Dependency) 이라고 얘기합니다. 아마 대부분 연관이 더 자연스럽고 친숙하게 들릴 것 입니다.

```
TIRE <-- BENTZ
```

벤츠는 타이어가 필요합니다.


#### 연관_구성,합성(Composistion)

```
KOREA_TIRE *-- BENTZ
```

벤츠는 한국 타이어를 외부 공장에서 공급받아 사용합니다.

#### 연관_집합(Aggregation)

```
HANDLE o-- BENTZ
```

벤츠는 핸들을 벤츠 공장에서 생성해서 사용합니다.

#### 합성과 집합의 차이

집합은 내가 객체를 직접 생성하여 사용하는 것이고, 합성은 외부에서 객체 생성을 주입 받는 형태입니다. 순수하게 객체 활동 시간에서 차이납니다. 집합은 내가 직접 만들었으니, 내가 소멸할 때 같이 소멸하지만, 합성의 경우에는 내가 소멸할 때 소멸하지 않을 수 있고, 내가 살아있음에도 외부에서 없애버릴 수 있습니다. 이 차이가 가장 큽니다.


### 차이점

흔히 국내에 가장 잘못 번역 된 개념이 상속(inhernce) 이라 생각합니다. OOP 를 배우면 상속의 개념을 배우는 데, 사실 재산 상속과 같은 의미보다는 확장에 가까운 개념이다. 

자바의 상속 키워드가 extends 인 것을 봐도 내가 무슨 말을 하고 싶은 지를 알것이다.

> 이펙티브 자바, 규칙 16 계승하는 대신 구성하라

에서는 구성을 써야하는 이유에 대해 설명한다.

- A와 AA는 is-a 의 관계에 있는가?

    - A와 AA는 같은 패키지에 놓여지는가?

- A의 문제를 AA에도 전파해도 괜찮은가?

    - A가 버전업이 되면 AA에도 영향을 받아도 되는가?


면접을 위해서 읽었던 시절과 달리, 최근에 몇 달간 고민했던 것을 속 시원하게 긁어주는 대목이었다. 가장 공감되는 것은 A의 문제를 AA에도 전파해도 괜찮은가? 이다. 예를 들면 A와 AA가 상속 관계에 있다면 A의 내부 AA와 전혀 상관없는 내부 메소드나 속성이 바뀌었을 경우, 상황에 따라서 AA에도 영향이 갈 수 있다. 반면 A와 AA가 의존 관계에 있다면 외부로 노출되는 API를 제외하고는 A의 변화로 인해 AA에 문제가 생길 일은 전혀 없다.

개인적으로는 보통 A의 메소드를 재사용하는 관점으로 확장(extends) 를 하는 걸 많이 보아 왔다. 아마 당신이 구데기 같은 한국식 SI에 다니고 있다면, CommonDto, CommonController 란 이름의 클래스를 많이 보았을 것이다. (어떠한 곳은 Common이 아니라 Core 라고도 얘기한다)




## 객체의 구성요소(필드) 를 모델링할 때

아래와 같은 자료형이 있다고 생각해보자

```
Person
- name : String
- id : String
- password : String
- gender : Gender
```

이 상태에서 우린 엉뚱한 상상을 해보자, id 와 password, name  이 같은 String 형이니깐 아래와 같이 다이나믹한 필드 구성을 해볼수 없을까?


```
Person
- attribute : String[]  //  attribute[0] = "name", attribute[1] = "id" ...
- gender : Gender
```


이렇게 되면 일어날 일이 어떠할까? Person 객체의 id에 대한 확인을 하는 로직이 있다고 가정하면, 로직의 구현도가 매우 복잡도가 높아진다.


static 한 필드의 경우 required =true 형태인 필드일 때에는 무조건 강요된다. 

배열 형태의 dynamic 한 attribute 를 구성하고 싶을 때에는 typesafe 언어에서는 아래의 전제가 필요하다.

- 같은 super type 의 하위 구현체들의 집합이며, 각 구현체들이 super type 을 확장시켜야 할 때  : 예를 들면 getAuthorities() 와 같다

- getAuthorities[0].getAuthority() 를 호출해서 문제가 없어야 한다. 즉 리스코프 치환 원칙을 지킬 수 있어야 한다.

