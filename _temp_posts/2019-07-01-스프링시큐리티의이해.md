
모든 것은 아래 공식 레퍼런스를 읽어 보면 공부가 된다.

- https://spring.io/guides/topicals/spring-security-architecture


spring-Oauth2 는 인가(인증을 시켜도 되는지 이유에 대해서만)만 담당할 뿐 실제 인증을 책임지지 않는다. 실제 인증은 스프링 시큐리티에서 처리한다. 

스프링 시큐리티가 이미 구현이 되어있어서? 란 생각을 할 수도 있는 데, OAuth2 프로토콜의 정의 자체가 인증 프로토콜이 아니라 인가 프로토콜이기 때문이다.(스프링 시큐리티 모듈 개발자는 덩실덩실)

스프링 시큐리티는 기본적으로

이것만 기억하면 된다.


1. 필터체인

    

2. 유저 조회

    - UserDetail

    - UserDetailService

3. 유저 검증

    - AuthenticationManager

        - AuthricationProvider



필터체인은 공부를 더해야하니.. 다음에 정리하도록 하고,

유저 조회와 유저 검증에 대해서 얘기해보려한다.

스프링 시큐리티는 기본적으로 유저라는 개념을 미리 추상화해놓았다. 그것이 바로 UserDetail 이라는 인터페이스 이다.

org.springframework.security.core.userdetails.UserDetails

```java

public interface UserDetails extends Serializable {
	// ~ Methods
	// ========================================================================================================

	/**
	 * Returns the authorities granted to the user. Cannot return <code>null</code>.
	 *
	 * @return the authorities, sorted by natural key (never <code>null</code>)
	 */
	Collection<? extends GrantedAuthority> getAuthorities();

	/**
	 * Returns the password used to authenticate the user.
	 *
	 * @return the password
	 */
	String getPassword();

	/**
	 * Returns the username used to authenticate the user. Cannot return <code>null</code>
	 * .
	 *
	 * @return the username (never <code>null</code>)
	 */
	String getUsername();

	/**
	 * Indicates whether the user's account has expired. An expired account cannot be
	 * authenticated.
	 *
	 * @return <code>true</code> if the user's account is valid (ie non-expired),
	 * <code>false</code> if no longer valid (ie expired)
	 */
	boolean isAccountNonExpired();

	/**
	 * Indicates whether the user is locked or unlocked. A locked user cannot be
	 * authenticated.
	 *
	 * @return <code>true</code> if the user is not locked, <code>false</code> otherwise
	 */
	boolean isAccountNonLocked();

	/**
	 * Indicates whether the user's credentials (password) has expired. Expired
	 * credentials prevent authentication.
	 *
	 * @return <code>true</code> if the user's credentials are valid (ie non-expired),
	 * <code>false</code> if no longer valid (ie expired)
	 */
	boolean isCredentialsNonExpired();

	/**
	 * Indicates whether the user is enabled or disabled. A disabled user cannot be
	 * authenticated.
	 *
	 * @return <code>true</code> if the user is enabled, <code>false</code> otherwise
	 */
	boolean isEnabled();
}

```

스프링시큐리티에는 이 UserDetail 을 우리가 흔히 말하는 유저, 또는 사용자로 인지를 하기 때문에 이 녀석을 구현한 구현체를 만들어서 사용하면 된다.

(기본적으로 org.springframework.security.core.userdetails.User 라는 기본 구현체 유저도 있기는 하다.  이거를 써도 무관하다.

org.springframework.security.provisioning.MutableUser 도 있긴 한데 이 녀석은 뭔지 모르곘다.)



AnoymousAythticationProvider --> DaoAuthpri

daoAuthprovider --> abstractUserDetailprovider

ProviderManager.authenticate(AUthenication authentication)


UsernamePasswordAuthenticationFilter.attemptAuthentication


WebSecurityConfigurerAdapter 에서 아래를 상속해서 해주니


    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return new ProviderManager(Arrays.asList(fouronesAuthenticationProvider));
    }


기존 AnoymousAythticationProvider --> DaoAuthpri 으로 타던게

바뀐 후 AnoymousAythticationProvider --> FouronesAuthProvider 로 등록됨



   public boolean supports(Class<?> authentication) {

는 authrication 의 원형 타입이 내가 체크할 authentication 인지 체크하는 용도이다.




    @Override
    public Authentication authenticate(Authentication authen) throws AuthenticationException {
        String requestPassword = (String) authen.getCredentials();
        User user = (User) userDetailsService.loadUserByUsername(authen.getName());
        String originPassword = user.getPassword();
        boolean ee = passwordEncoder.matches(requestPassword, originPassword);
        if (!ee) {
            throw new BadCredentialsException("password match fail");
        }
        if (user.getNeedChangePassword()) {
            throw new NeedPasswordChanged("Email Change need");
        }
        if (!user.isEnabled()) {
            throw new DisabledException("User is Lock");
        }
        authen.setAuthenticated(true);
        return authen;
    }


에서 authen.setAuteicated(true) 로 설정 했더니 토큰이 변질됬다는 에러메세지가 나왔다.



java.lang.IllegalArgumentException: Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead







https://docs.spring.io/spring-security/site/docs/4.2.12.RELEASE/apidocs/org/springframework/security/authentication/UsernamePasswordAuthenticationToken.html

문서를 보면..

.setAuthenticated() 메소드는 토큰을 무효시킬지에 대한 여부의 메소드이다 ㅡㅡ;

이 토큰이 신뢰가능하다는 것은 UsernamePasswordAuthenticationToken 생성자를 통해서만 가능하다.

DaoAuthenticationProvider에서는 어떻게 처리했는지 살펴봤다.

	protected final UserDetails retrieveUser(String username,
			UsernamePasswordAuthenticationToken authentication)
			throws AuthenticationException {
		UserDetails loadedUser;

		try {
			loadedUser = this.getUserDetailsService().loadUserByUsername(username);
		}
		catch (UsernameNotFoundException notFound) {
			if (authentication.getCredentials() != null) {
				String presentedPassword = authentication.getCredentials().toString();
				passwordEncoder.isPasswordValid(userNotFoundEncodedPassword,
						presentedPassword, null);
			}
			throw notFound;
		}
		catch (Exception repositoryProblem) {
			throw new InternalAuthenticationServiceException(
					repositoryProblem.getMessage(), repositoryProblem);
		}

		if (loadedUser == null) {
			throw new InternalAuthenticationServiceException(
					"UserDetailsService returned null, which is an interface contract violation");
		}
		return loadedUser;
	}




이 던저진 user는  부모인 AbstractuserDetailsAuthenticationProvider 에 처리된다.	public Authentication authenticate(Authentication authentication)
			throws AuthenticationException {


위 메소드의 마지막 줄 에서 만들어진다.createSuccessAuthentication(principalToReturn, authentication, user);


	protected Authentication createSuccessAuthentication(Object principal,
			Authentication authentication, UserDetails user) {
		// Ensure we return the original credentials the user supplied,
		// so subsequent attempts are successful even with encoded passwords.
		// Also ensure we return the original getDetails(), so that future
		// authentication events after cache expiry contain the details
		UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(
				principal, authentication.getCredentials(),
				authoritiesMapper.mapAuthorities(user.getAuthorities()));
		result.setDetails(authentication.getDetails());

		return result;
	}



 
이런 이유떔에 그냥 나는 DaoAuthenticationProvider 를 흉내낼거니깐 그 슈퍼클래스 AbstractUserDetailsAuthenticationProvider  구현해서 쓰기로 했다.

결국은

AuthenticationProvider --> 를 한번 랩핑한 AbstractUserDetailsAuthenticationProvider   으로 바꿔서 구현처리했다.


Abst.. 에는

retrieveUser() 와

additionalAuthenticationChecks() 를 구현해주어야 한다.

```java

    @Override
    protected UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
        String requestPassword = (String) authentication.getCredentials();
        User user = (User) userDetailsService.loadUserByUsername(username);
        String originPassword = user.getPassword();
        boolean ee = passwordEncoder.matches(requestPassword, originPassword);
        if (!ee) {
            throw new BadCredentialsException("password match fail");
        }
        return user;
    }

    @Override
    protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
        User user = (User) userDetails;
        if (user.getNeedChangePassword()) {
            throw new NeedPasswordChanged("password Change need");
        }
        if (!user.isEnabled()) {
            throw new DisabledException("User is Lock");
        }
    }



```

나는 구현을 이렇게 했는 데, 내용이 뭐냐면 유저 검증을 하고 유저를 retrieveUser에서 return 해준다.

이 return 된 것은 addionalAtchecks 에서 검증을 한다. 내가 구현한 User에는 bit 타입의 need_change_password 라는 필드(컬럼)가 있다. 이게 true 냐 false 냐에 따라 또 인증 실패를 시킬지를 판단하는 것이 있다. isEnabled 는 기본 USerDetails 에 있는 그 true false 이냐 그것이다.


메소드 이름과 파라미터에서 알 수 있지만, retrieveUser 은 유저를 가져오는 것이고 additionalAuthenticationChecks는 인증 시킬지 체크이다.

이것만 해도 잘동작한다.. 이런 거 보면 

예전 SI 선배 개발자들이 스프링 다 그거 븅신같에 직접 만들면 되~ 이딴소리 많이들 하던데, .. 천재들은 니들이 이런거 꼭 필요할 거 같아서 abstract 로 해놨어라고 수년전 부터 해놓았다. ㅅㅂ


principal 은 사용자 본인을 의미한다

credentials 은 사용자의 자격증명 값을 의미한다.

사용자 본인을 의미하는 게 어떠한 형태일지 모르니 pricipal 이라는 개념을 쓴다.

마찬가지로 비밀번호 인증인지, 다른 LDAP 인증인지를 모르니 credentails 라는 개념을 쓴다.

https://brunch.co.kr/@sbcoba/12


