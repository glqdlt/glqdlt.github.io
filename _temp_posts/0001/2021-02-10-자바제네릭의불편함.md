

## 현재 트랜드에서 정적 언어에서 오는 한계

```java


/**
 * @author glqdlt
 */
public interface AttributeKey<V> {
    String getKeyName();

}

/**
 * @author glqdlt
 */
public interface AttributeValue<T> {

    T getValue();

}

/**
 * @author glqdlt
 */
public interface Attribute<V> {

    AttributeValue<V> getAttributeValue();

    AttributeKey<V> getAttributeKey();

    default Boolean validValue() {
        return getAttributeValue().getValue() != null;
    }

    default Integer getOrder() {
        return 10;
    }

}

```

nosql 의 컬럼-패밀리와 유사한 형태의 자료모델을 만들려고 했다.


Key와 Value 를 같은 타입으로 강제화 하고 싶은 경우이다. 단순하게 Long 과 String 의 경우에는 문제가 없어 보인다.

다만 rdb 와 같은 경우는 다형성을 지원하지 않기 때문에 각 key 와 value 의 제네릭 타입에 맞추어서 모든 인터페이스를 선언해야한다. STring, Long 만 사용한다 해도 4개의 클래스(인터페이스) 를 만들어야 한다.

그래서 생각한 게 아래와 같은 형태이다. 그런데 아래의 경우는 아래와 같은 문제가 생긴다.

- Type 과 Value 의 실제 값이 다를수 있다. Type 이 StringType 이지만, value는 Long 이 될수도 있다는 이야기이다. Type 에 적용된 제네릭이 value 까지 연결되는 것이 아니기 떄문이다. 이것이 연결되려면 Type의 제네릭과 Value의 제네릭을 엮어야 한다.

- Key는 1개만 만들어도 된다. 다만 value 는 여전히 rdb 에서는 다형성을 지원하지 않기 때문에 각 타입마다 다른 컬럼을 참조할수 있도록 타입에 맞는 클래스들을 만들어야 한다.


```java


/**
 * @author glqdlt
 */

public interface Type<V>{
    
}

public interface StringType extends Type<String>{
    
}

public interface AttributeKey<V extends Type> {
    String getKeyName();

}

/**
 * @author glqdlt
 */
public interface AttributeValue<T extends Type> {

    Object getValue();

}

/**
 * @author glqdlt
 */
public interface Attribute<T extends Type> {

    AttributeValue<T> getAttributeValue();

    AttributeKey<T> getAttributeKey();

    default Boolean validValue() {
        return getAttributeValue().getValue() != null;
    }

    default Integer getOrder() {
        return 10;
    }

}

```

최종적으로는 아래의 모델이 나왔다.

```java

/**
 * @author glqdlt
 */
public interface AttributeKey<TYPE extends AttributeType> {
    String getKeyName();

    TYPE getType();

}

/**
 * @author glqdlt
 */
public interface AttributeValue<VALUE, TYPE extends AttributeType<VALUE>> {

    VALUE getValue();

    TYPE getType();

}

/**
 * @author glqdlt
 */
public interface Attribute<TYPE extends AttributeType<VALUE>, VALUE> {

    AttributeValue<VALUE, TYPE> getAttributeValue();

    AttributeKey<TYPE> getAttributeKey();

    TYPE getType();

    default Boolean validValue() {
        return getType().validation(getAttributeValue().getValue());
    }

    default Integer getOrder() {
        return 10;
    }

}

public interface AttributeType<V> {
    Boolean validation(V v);
}

```

불편하다고 말하고 싶은 부분은 아래와 같다. 

> public interface Attribute<TYPE extends AttributeType<VALUE>, VALUE> 

Key와 value 를 연결하는 브릿지인 attribute 에 StringType 하나만 선언하면 StringType이 이미 VALUE 의 타입에 대해서 추론할수 있는데, 자바 제네릭은 이를 지원하지 않는다.

이름을 붙인다면 연쇄 추론이라고 붙이고 싶다, 즉 연쇄 추론을 할수가 없다. 항상 기준은 자기 자신 클래스를 기준으로 적용이 되기 때문에, 내가 String 을 getValue() 에 쓸거고, String 을 쓰는 AttributeType 도 같이 쓸래로 접근이 되는 개념이다.

이게 무슨 말이냐면 아래와 같은 선언이 과연 자연스러운가에 대한 이야기이다.

```java

public interface StringType extends AttributeType<String>{}

public interface StringAttributeValue extends AttributeValue<String, StringType>{}

```

오히려 AttributeType이 생기면서 key와 value 각각 제네릭 타입 형마다 x3 개가 생긴다. String, Long 이 추가된다면 6개의 클래스가 생겨야 한다.


