---
layout: post
title:  "tdd 입문"
author: "glqdlt"
---

## Mockito.When vs BDDMockito.Given


When 은 전통적인 스타일이고, Given 은 BDD 스타일이라고 한다.
그런데 given when then 으로 하나 묶어서 많이 표현하는 데, 이게 뭐지?


> 다음으로 // Given, // When, // Then이라는 주석이 눈에 띄는데 이런 코딩 습관은 굳이 BDD라는 이론적 배경을 들지 않더라도 테스트 코드를 조금 더 이해하기 쉽게 구분해 주는 좋은 습관이라고 생각한다. 먼저 // Given 주석에서는 테스트에 필요한 객체와 준비를 갖추고 // When에서는 일을 벌인다. 주로 테스트하려는 코드를 실행한다. 그리고 마지막으로 // Then 주석 아래에서는 주로 // When에서 발생한 일의 결과 어떤 일이 벌어졌는지 확인하는 코드가 주를 이룬다. 때에 따라서는 코드를 이렇게 세 구역으로 나누기 모호하기 때문에 종종 // Given과 // When Then 둘로만 나누는 경우도 있다.

출처 : https://d2.naver.com/helloworld/568425


https://github.com/glqdlt/tdd-spring-web-app.git


## Junit 의 동작 메커니즘

1. 테스트 클래스에서 ```@Test```가 붙은 public,void,파라미터가 없는 메소드들을 찾는다.

2. 테스트 클래스의 오브젝트를 하나 만든다.

3. ```@Before``` 가 붙은 메소드가 있으면 실행한다.

4. ```@Test``` 가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.

5. ```@After``` 가 붙은 메소드가 있으면 실행한다.

6. 나머지 테스트 메소드들에도 2~5를 반복한다.

7. 저장된 결과를 출력한다.




## @Before 

```@Before``` 은 테스트 메소드가 실행 되기 전에 사전에 실행시키는 녀석이다. 이 녀석은 대부분 settup 형태의 환경 메소드로 많이들 구현하게 된다. 테스트 필드에 메소드마다 공통적으로 사용할 전역 변수를 선언해놓고 이 ```@Before```를 통해 해당 필드를 initialize 해준다. 

문제는 이 녀석은 각 메소드마다 무조건 1번 실행된다. 예를 들어 각 테스트 메소드들이 필드에서 read only로만 데이터를 가져가서 작업만 한다면 필드의 초기화는 한번만 일어나면 될 것이라는 생각이 들 것이고, 매 메소드마다 호출이 되는 것은 비효율적이라고 생각이 들어왔었다.

이 의구증에 대한 해답은 [토비의 스프링 3-1 Vol.1](#)에서 아래 구절에서 힌트를 얻게 되었다.

 > Junit의 모든 테스트는 실행 순서에 상관없디 독립적으로 항상 동일한 결과를 낼 수 있도록 해야 한다. ... Junit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 테스트 오브젝트를 만들게 했다. 덕분에 인스턴스 변수도 부담 없이 사용할 수 있다. 어차피 다음 테스트 메소드가 실행될 때는 새로운 오브젝트가 만들어져서 다 초기화될 것이다.

 즉, 비효율적으로 보이던 행동은 각 메소드들이 독립적이고 개별적이어야 한다는 프레임워크 철학 때문이었던 것이다. 


## @BeforeClass

위에서 ```@Before```의 특성에 대해 설명했다. 매번 호출되는 것이 테스트 메소드들이 개별적으로 동작하기 위함이라는 의미에 대해서는 납득이 된다. 다만 조금 생각을 해보면 조심히 걱정해야할 부분이 있다. 멀티 스레드 환경일 경우에 대해서이다. 전역에서 사용되고 매 테스트 메소드가 실행될 때마다 생성 되는 픽스처(아래에서 설명)의 경우 문제의 소지가 생길 수 있다. 여러 테스트 메소드에서 공통으로 사용되는 픽스처의 숨겨진 스레드가 새로운 테스트 오브젝트에 사용될 때 정리가 되지 않으면 문제가 발생할 수 있다.
이래서 나온 것이 ```@BeforeClass``` 이다. 

이 녀석은 클래스 전체에 걸쳐 딱 한 번만 실행되는 녀석이다. 예를 들어 스프링 기반의 테스트일 경우 이 녀석을 통해 어플리케이션 컨텍스트를 한번만 만들어두고 내부의 Bean을 호출만 하면 깔끔하게 테스트를 구성할 수 있다.

하지만 이런 경우에는 스프링 테스트에서 제공하는 ```@ContextConfiguration```어노테이션을 클래스에 선언함으로써 더 깔끔하게 해결할 수 있다.

```java

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "/applicationContext.xml")
public class SomeTest{

    @Autowired
    private ApplicationContext context;

    @Before
    public void setUp(){
        ...
    }

}

```

```@Runwith```는 JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 애노테이션이다. SpringJUnit4ClassRunner 라는 JUnit 용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit 이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.

```@ContextConfiguration```은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정한 것이다.

여기서 재밌는 것은 ApplicationContext를 ```@Autowired``` 했을 때 주입이 된다는 점이다. 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 Bean으로 등록하기 때문이다.



## 픽스처

테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처(fixture)라고 한다. 위의 ```@Before``` 에서 사용하는 전역 변수들이 픽스처에 해당한다.

 

Given When Then

http://www.baeldung.com/bdd-mockito

http://www.chidoo.me/index.php/2017/01/04/integration-test-in-springboot-1-4/

https://stackoverflow.com/questions/14736219/difference-between-stub-and-when-in-mockito

https://github.com/mockito/mockito/wiki/Mockito-features-in-Korean

http://lng1982.tistory.com/152


## 내 PC에서는 잘 되는 데..

> 개발자가 테스트를 직접 만들 때 자주 하는 실수가 있다. 성공하는 테스트만 골라서 만드는 것이다. 개발자는 머릿속으로 코드가 잘 돌아가는 상상을 하면서 코드를 만드는 경우가 일반적이다. 그래서 테스트를 작성할 때도 문제가 될 만한 상황은 교묘히 피해서 코드를 만드는 습성이 있다.
'내 PC에서는 잘 되는 데..' 에 대한 이야기는 이러한 예외적인 상황은 모두 피하고 정상적인 케이스만 테스트한 경우가 대부분이다. -토비의 스프링 3-1 vol.1

## 우리 모두 이미 TDD를 하고 있다.

개발자가 요구사항을 확인하고 개발에 들어갈 때, 이런이런 flow를 가지는 코드가 되겠다고 어느 정도의 윤곽을 잡고 개발에 들어간다. 시간이 흐르면서 코드를 하나,둘 씩 손보면서 '이렇게 하면 될듯' 시뮬레이션 하면서 개발에 진행 된다. 정작 코딩을 끝내고 나서도, '뭔가 놓친 것 같다', '이렇게 하면 유연하지 못하다' 등의 생각을 하며 또 수정을 한다.

이걸 생각해보면 TDD의 흐름과 유사한 것을 알 수 있다. 문제는 이렇게 머릿속에서 진행되는 테스트는 제약이 심하고, 인지의 오류가 많고, 나중에 다시 재활용할 수 없다. 그래서 이를 실제 코드로 끄집어 내놓는 것이 TDD이다.

> TDD는 처음에는 이상하게 보일지 모르겠지만 사실은 매우 자연스러우며, 한번 익숙해지고 나면 TDD가 아니고는 개발을 못하겠다고 할지도 모를 만큼 매력적인 방법이다. -토비의 스프링 3-1 vol.1

> 개발자의 낭만이라고도 생각하는  '눈물 젖은 커피와 함께 밤새며 오류를 찾았더니, 생각지도 못한 곳에서 찾은 단순한 작은 버그 하나의 추억' 이라는 건, 사실 '테스트를 충분히 하지 않고 미루고 미루던 어리석은 기억' 일 뿐이다. -토비의 스프링 3-1 vol.1




## TDD 의 쾌락 그리고 조심해야할 것

아래는 YONA 오픈소스 툴을 만드신 채수원님의 [테스트 주고 개발과 실천도구](#) 책에서 TDD 전문가에 대한 인터뷰 내용 중에 일부를 발췌한 내용이다.

> Q . TDD를 적용하는 데 있어 중요하다고 생각하는 부분 혹은 유의점은 무엇이라고 생각합니까 ?
  

> A. TDD에서 가장 중요한 사항은 무엇인가를 해결하는 데만 집중하는 것이 아니라 내가 하고자 하는 게 무엇인지에 정신이 머무르게 하는 것 ... 테스트 하려던 것이 무엇인지에 대한 방향성과 정체성에 대한 집중이 흐트러지면 테스트 PASS가 주는 문제 해결의 쾌락에 빠져 팀원에게 자랑을 위한 불필요한 테스트 케이스를 만들어 나가게 되는 위험한 상황에 빠질 수도 있다. 나는 이것을 '초록 막대 증후군' 이라 이름을 붙여보았다.  -변신철 (주)비앤디(BnD) 책임연구원

  


  ## BDD 와 TDD

  BDD 는 행동 기반 개발이라는 것이다. 조금 설명이 적절하지 않지만, 내가 이해했던 개념은 TDD 가 Bottom Up 상향식이라면 BDD TOP Down 하향식과 유사하다라고 접근한 후에 이해가 쉬웠다.

  BDD는 자연어에 가까운 User Story 유저의 액션을 기반으로 테스트를 접근하게 된다. 

  



  https://www.popit.kr/bdd-behaviour-driven-development에-대한-간략한-정리/
  

  ## 상태 기반 테스트와 흐름 기반 테스트

  흔히 정적 테스트빠돌이, 동적 테스트 빠돌이라고 얘기하는 데

  이는 상태 기반 테스트(state base)와 흐름 기반 테스트(behiver base)를 두고 나뉘는 것이다.

  상태 기반 테스트는 테스트라고 하면 대다수가 아는 A(expected)와 B(target result)를 비교하는 형태이다. 매우 직관적이다. Bottom Up 상향식처럼 작은 세밀세밀한 단위 테스트로 접한다. 상태 기반 테스트에서의 단점은 내부 메서드에 대한 상태를 확인할 수가 없다. 물론 Bottom Up 상향식으로 잘게 나눈 테스트가 결국은 모여서 호출이 된다고를 가정하면 이는 고려를 안 해도 되지만, 특정 메소드와 메소드가 결합된 서비스 메소드같은 형태는 테스트하기가 어렵다. 이 때문에 나온 것이 흐름 기반 테스트이다.

  흐름 기반 테스트는 이름 그대로 흐름에 대해 접근한다. 예상하는 흐름 데로 제대로 호출이 되었고, 정상적으로 마무리 된다로 접근한다. 위의 상태 기반 테스트의 단점인 메소드 안의 메소드가 제대로 수행되었는 지를 체크할 수가 있다. 그러기 위해서는 호출되는 메소드를 Proxy 메소드 로 한번 더 감싸서 호출 여부를 체크하는 스파이 로직을 삽입하던지, 목업 객체를 심던지 해야 한다. 

  위에서 정적 테스트 빠돌이와 동적 테스트 빠돌이라고 나뉘는 것은 과거 목킹 프레임워크가 막 출시되었을 때의 이야기이다. 정적 테스트 진영은 상태 기반 테스트는 이미 모든 펑션 단위로 세밀하게 테스트가 진행되는 것을 가정하기 때문에 function in function 에도 문제가 없다고 얘기를 한다. 동적 기반에서는 아무리 세밀하게 테스트를 하더라도, 실제 Function 들이 엮인 경우에는 흐름 제어가 Function 의 주 역활임으로 이를 테스트하는 것이 옳다고 이야기 한다.  이는 좀 더 확장되어서 TDD vs BDD 라는 개념의 충돌까지 이어진다. TDD 는 매우 세밀한 작은 Function 단위에서 전체 로직까지로 접근하는 데, BDD 는 이는 매우 복잡하고 사람 직관적이지 않기 때문에, 사용자 Action 에 근거한 유저 스토리 기반의 테스트를 하면 어차피 모든 것이 충족된다는 의견으로 귀결이 되었다. 즉 TDD 가 작은 세밀한 기능들이 모여서 진행 되는 Bottom Up 상향식 테스트인 반면, BDD 는 작은 세밀한 기능이 모인 유저 스토리 기반이라는 전체에서 작은 기능으로 내려가는 Top Down 하향식 테스트라는 의견 해석이 생기게 된다. 