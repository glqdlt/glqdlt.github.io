---
layout: post
title:  "토비의 스프링 3-1"
author: "glqdlt"
---




## 스프링의 성공 이유

+ 단순함 

    복잡한 EJB 기술을 비판하면서 등장, 단순한 개발 모델인 POJO 프로그래밍을 주장

+ 유연성

    스프링은 프레임워크를 위한 프레임워크라 해서 접착 프레임워크라고 함(왠지 VueJs 가 떠오름)

## 스프링 활용에 대한 이야기

+ 스프링의 기술에 대한 핵심 가치와 원리 그리고 기술 선택 기준

    스프링은 매우 범용적인 프레임워크이고, 애플리케이션의 모든 레이어를 폭 넓게 다루고 있음. 스프링과 연동하는 프레임워크는 어떤 것을 선택하고 어떤 스타일로 구현할 지를 고민해야함 또한 이 고민은 기술영역별로 효과적으로 다루는 법이 있음으로 그에 대한 고민도 해야함

## 저자의 좋은 충고

    스프링은 배우기 쉬운 기술이 아님, 충분한 시간을 들여서 공부하고 끝없이 공부해야함. 이는 스프링을 학습한다는 것은 스프링이 지지하는 프로그래밍 모델, 개발과 설계 원리 개념 즉, 자바와 엔터프라이즈 개발의 다양한 영역을 배운다는 것을 의미하기 때문이다.

    그리고 스프링을 성공적으로 학습했는지를 확인하려면, 스프링을 공부하고 적용한 이후에 자신의 코드가 좀 더 깔끔하고 객체지향적이 되었는지를 보면 잘 공부하고 있다는 걸 확인할 수 있다고 한다. 이전보다 더 많은 테스트 코드를 작성하고 있고, 유연하고 확장이 쉬운 어플리케이션이 되었는지 확인해보자.



# 의존관계

## 오브젝트 설계

스프링은 자바 엔터프라이즈 기술로 인해(아마 EJB 말하는 듯) 잃어가고 있던 객체지향의 진정한 가치를 회복시키고자 하기 때문에 스프링이 가장 관심을 두는 것은 객체지향이고, 객체지향은 즉 오브젝트를 뜻한다. 고로 스프링을 이해하려면 오브젝트에 관심을 가져야한다.

+ DAO(Data Access Object)

    DB의 데이터를 조회하거나 조작하는 기능의 수행과 책임을 전담하는 오브젝트

+ 자바빈(Java Ean)

    자바빈은 비주얼 툴에서 조작 가능한 컴포넌트를 뜻했음. 자바의 주력 플랫폼이 웹으로 이동하면서 비주얼 컴포넌트로서의 자바빈은 인기를 잃어갔지만, 몇 가지 코딩관례는 JSP 빈, EJB와 같은 표준 기술과 자바빈 스타일의 오브젝트를 사용하는 오픈소스 기술을 통해 계속 이어져옴.
    지금에 와서는 간단히 빈이라고 불리우며, 아래 2가지 관례를 따른다.

        + 디폴트 생성자 : 자바빈은 NoArgsConstructor 를 하나 무조건 가져야한다. 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문이다.

        + 프로퍼티 : 객체의 속성을 노출하는 것을 프로퍼티(뜻이 속성임)라고 함. 프로퍼티는 getter 와 setter로 메소드를 통해 접근이 이루어진다.

### 관심사의 분리

객체지향의 세게에서는 모든 것이 변할 수 있음. 오브젝트의 설계와 구현 코드가 바뀔 수 있음. 사용자의 요구사항은 끊임없이 바뀌고 발전함으로, 운영되는 환경이나 기반 기술도 시간에 따라 바뀜.
고로 유연한 설계가 필요해짐.

+ 리팩토링 

리팩토링은 기존의 코드를 외부의 동작방식에 변화 없이 내부 구조의 변경만으로 재구성하는 것을 뜻함. 리팩토링의 목적은 생산성을 올리고, 코드의 품질이 높아지고, 유지보수에 용이하며 견고하고 유연한 제품을 구현해 나갈 수 있게 됨.


+ 탬플릿 메소드 패턴

슈퍼클래스에 기본적인 로직의 흐름(커넥션 생성, 실행 반환) 등을 만들어놓고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 후 서브클래스에서 이 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 템플릿 메소드 패턴(template method pattern) 이라고 함. 스프링에서 가장 애용되는 디자인 패턴.
슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드 할 수 있도록 만들어둔 메소드를 훅(hook) 메소드라고 함.

```java

public abstract class Coffee {
	
	void make(){
        // 기본적인 setting은 무조건 실행한다.
		setting();
        mixxing();
        // 
        if(isAnotherMake){
            anotherMixing();
        }
        done();
	}
	
	private void setting(){

        ...
    
		
	}

// 무조건 실행되어야 하는 메소드 임으로, final로 overriding을 방지
    final void done(){
        ...
    };
	

// mixing 의 구현은 이 클래스를 사용하는 서브클래스에 위임한다.
	abstract void mixing();
	

	boolean isAnotherMake(){
		return false;
	}

// Hook 메소드
// 만약에 누군가 커피의 맛을 더 내기 위해 추가적인 비법을 추가하고 싶다면 아래를 오버라이딩 한다.
// abstract 키워드가 붙으면 강제적으로 구현해야지만, anotherMiging()은 선택을 위해 hook method 형태로 구현.

	void anotherMixing(){};
}


```


+ 팩토리 메소드 패턴

서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 팩토리 메소드 패턴(factory method pattern) 이라고 함.

```java
Car avantte = CarFactory.createCar("avantte");
Car sonata = CarFactory.createCar("sonata");

System.out.println(avantte.getName());  // 아반떼
System.out.println(sonata.getName()); // 소나타
```


+ 디자인 패턴

디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위한 솔루션을 말함. 대부분이 개발자가 편해지자는 의도이고, 유연하고 재활용가능하게 하는 형태가 많음.
다양한 패턴이 있지만, 결국 각 패턴은 어떠한 특정 상황에 최적화되어서 만들어진 것을 잊으면 안된다. 즉, 패턴의 목적을 인지해서 환경에 따라 적절한 패턴을 사용하고자 노력해야 한다. 가장 유명한 책으로는 'GoF의 디자인 패턴', 'Head First Design Patterns' 가 있다.

## 인상 깊은 점

스프링 3-1 의 책의 목차를 보면, 목차의 가장 최우선으로 테스트 관련 된 내용이 나온다. 또한, 스프링을 학습할 때에 관한 충고에서도 좋은 개발자가 되었다고 판단할 때 더 유연한 어플리케이션 구조와 테스트 작성이 쉬워졌다고 말하고 있다. 역시 테스트 짱짱맨인가?

