---
layout: post
title:  "토비의 스프링 3-1"
author: "glqdlt"
---




## 스프링의 성공 이유

+ 단순함 

    복잡한 EJB 기술을 비판하면서 등장, 단순한 개발 모델인 POJO 프로그래밍을 주장

+ 유연성

    스프링은 프레임워크를 위한 프레임워크라 해서 접착 프레임워크라고 함(왠지 VueJs 가 떠오름)

## 스프링 활용에 대한 이야기

+ 스프링의 기술에 대한 핵심 가치와 원리 그리고 기술 선택 기준

    스프링은 매우 범용적인 프레임워크이고, 애플리케이션의 모든 레이어를 폭 넓게 다루고 있음. 스프링과 연동하는 프레임워크는 어떤 것을 선택하고 어떤 스타일로 구현할 지를 고민해야함 또한 이 고민은 기술영역별로 효과적으로 다루는 법이 있음으로 그에 대한 고민도 해야함

## 저자의 좋은 충고

    스프링은 배우기 쉬운 기술이 아님, 충분한 시간을 들여서 공부하고 끝없이 공부해야함. 이는 스프링을 학습한다는 것은 스프링이 지지하는 프로그래밍 모델, 개발과 설계 원리 개념 즉, 자바와 엔터프라이즈 개발의 다양한 영역을 배운다는 것을 의미하기 때문이다.

    그리고 스프링을 성공적으로 학습했는지를 확인하려면, 스프링을 공부하고 적용한 이후에 자신의 코드가 좀 더 깔끔하고 객체지향적이 되었는지를 보면 잘 공부하고 있다는 걸 확인할 수 있다고 한다. 이전보다 더 많은 테스트 코드를 작성하고 있고, 유연하고 확장이 쉬운 어플리케이션이 되었는지 확인해보자.



# 의존관계

## 오브젝트 설계

스프링은 자바 엔터프라이즈 기술로 인해(아마 EJB 말하는 듯) 잃어가고 있던 객체지향의 진정한 가치를 회복시키고자 하기 때문에 스프링이 가장 관심을 두는 것은 객체지향이고, 객체지향은 즉 오브젝트를 뜻한다. 고로 스프링을 이해하려면 오브젝트에 관심을 가져야한다.

+ DAO(Data Access Object)

    DB의 데이터를 조회하거나 조작하는 기능의 수행과 책임을 전담하는 오브젝트

+ 자바빈(Java Ean)

    자바빈은 비주얼 툴에서 조작 가능한 컴포넌트를 뜻했음. 자바의 주력 플랫폼이 웹으로 이동하면서 비주얼 컴포넌트로서의 자바빈은 인기를 잃어갔지만, 몇 가지 코딩관례는 JSP 빈, EJB와 같은 표준 기술과 자바빈 스타일의 오브젝트를 사용하는 오픈소스 기술을 통해 계속 이어져옴.
    지금에 와서는 간단히 빈이라고 불리우며, 아래 2가지 관례를 따른다.

        + 디폴트 생성자 : 자바빈은 NoArgsConstructor 를 하나 무조건 가져야한다. 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문이다.

        + 프로퍼티 : 객체의 속성을 노출하는 것을 프로퍼티(뜻이 속성임)라고 함. 프로퍼티는 getter 와 setter로 메소드를 통해 접근이 이루어진다.

### 관심사의 분리

객체지향의 세게에서는 모든 것이 변할 수 있음. 오브젝트의 설계와 구현 코드가 바뀔 수 있음. 사용자의 요구사항은 끊임없이 바뀌고 발전함으로, 운영되는 환경이나 기반 기술도 시간에 따라 바뀜.
고로 유연한 설계가 필요해짐.

+ 리팩토링 

리팩토링은 기존의 코드를 외부의 동작방식에 변화 없이 내부 구조의 변경만으로 재구성하는 것을 뜻함. 리팩토링의 목적은 생산성을 올리고, 코드의 품질이 높아지고, 유지보수에 용이하며 견고하고 유연한 제품을 구현해 나갈 수 있게 됨.


+ 탬플릿 메소드 패턴

슈퍼클래스에 기본적인 로직의 흐름(커넥션 생성, 실행 반환) 등을 만들어놓고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 후 서브클래스에서 이 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 템플릿 메소드 패턴(template method pattern) 이라고 함. 스프링에서 가장 애용되는 디자인 패턴.
슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드 할 수 있도록 만들어둔 메소드를 훅(hook) 메소드라고 함.

```java

public abstract class Coffee {
	
	void make(){
        // 기본적인 setting은 무조건 실행한다.
		setting();
        mixxing();
        // 
        if(isAnotherMake){
            anotherMixing();
        }
        done();
	}
	
	private void setting(){

        ...
    
		
	}

// 무조건 실행되어야 하는 메소드 임으로, final로 overriding을 방지
    final void done(){
        ...
    };
	

// mixing 의 구현은 이 클래스를 사용하는 서브클래스에 위임한다.
	abstract void mixing();
	

	boolean isAnotherMake(){
		return false;
	}

// Hook 메소드
// 만약에 누군가 커피의 맛을 더 내기 위해 추가적인 비법을 추가하고 싶다면 아래를 오버라이딩 한다.
// abstract 키워드가 붙으면 강제적으로 구현해야지만, anotherMiging()은 선택을 위해 hook method 형태로 구현.

	void anotherMixing(){};
}


```


+ 팩토리 메소드 패턴

서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 팩토리 메소드 패턴(factory method pattern) 이라고 함.

```java
Car avantte = CarFactory.createCar("avantte");
Car sonata = CarFactory.createCar("sonata");

System.out.println(avantte.getName());  // 아반떼
System.out.println(sonata.getName()); // 소나타
```


+ 디자인 패턴

디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위한 솔루션을 말함. 대부분이 개발자가 편해지자는 의도이고, 유연하고 재활용가능하게 하는 형태가 많음.
다양한 패턴이 있지만, 결국 각 패턴은 어떠한 특정 상황에 최적화되어서 만들어진 것을 잊으면 안된다. 즉, 패턴의 목적을 인지해서 환경에 따라 적절한 패턴을 사용하고자 노력해야 한다. 가장 유명한 책으로는 'GoF의 디자인 패턴', 'Head First Design Patterns' 가 있다.


+ 객체지향 설계 원칙 (SOLID)

로버트 마틴이 정리한 객체지향의 설계원칙이다. SOLID는 아래 5가지 원칙의 첫 글자를 따서 만든 단어이다.
1. SRP(The Single Responsibility Principle) : 단일 책임 원칙

2. OCP(The Open Closed Principle) : 개방 폐쇄 원칙

3. LSP(The Liskov Substitution Principle) : 리스코프 치환 원칙

4. ISP(The Interface Segregation Principle) : 인터페이스 분리 원칙

5. DIP(The Dependency Inversion Principle) : 의존관계 역전 원칙

 SOLID를 잘 설명한 책으로는 'UML 실전에서는 이것만 쓴다' 라는 책이 있다. 


+ 전략 패턴(Strategy Pattern)

자신의 기능 맥락(context)에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

### IOC

제어의 역전이라는 개념으로, 프로그램의 제어 흐름 구조가 바뀌는 것이라고 설명한다. IOC에서는 기능을 제공하는 측이 아닌 사용하는 쪽에서 제어하는 구조이다. IOC에서는 기능 제공자가 자신이 사용할 오브젝트를 선택하지 않는다. 생성도 하지 못한다. 애초에 자기 자신이 어떻게 탄생하는지도 없다, 관심도 없다. 모든 제어 권을 사용하는 측에 위임하게 되기 때문에, 커플링과 응집도가 낮아진다.
깔끔한 오브젝트 설계와 유연성을 위해서는 IOC 스타일의 설계를 적용해야 할 필요성이 생긴다.


### 스프링의 빈(bean)

스프링에서 애플리케이션 컴포넌트를 뜻 한다. 자바 빈과 엔터프라이즈 자바빈(EJB) 하고 비슷한 오브젝트 단위이고, 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트이다.

스프링 빈의 생성과 관계를 제어하는 걸 IOC 오브젝트가 한다. 이 놈은 다른 말로 빈 팩토리(Bean Factory)라고도 말하며, 대부분 애플리케이션 컨텍스트(Application Context)라는 이름으로 사용한다. 
일반적으로 빈 팩토리라고 말할 때는 빈을 생성하고 관계를 설정하는 IOC의 기본 기능에 초점을 맞추고, 애플리케이션 컨텍스트라고 말할 때에는 애플리케이션 전체 구성요소의 제어에 초점을 맞출 때(IoC엔진 또는 IoC 컨테이너라고도 한다)를 말한다.

#### @Configuration

스프링에게 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식시켜주는 어노테이션이다.

#### @Bean
오브젝트를 만드는 메소드에는 @Bean 애노테이션을 붙여준다. 일반적으로 bean의 이름은 해당 메소드의 이름이 된다. 메소드 이름으로 사용하는 것은 해당 오브젝트를 생성하는 방식이나 구성을 메소드 별로 추가적으로 관리할 수 하고자 그렇다고 한다.

### 오브젝트와 의존 관계

+ 오브젝트의 동일성과 동등성

두 오브젝트 간의 래퍼런스가 동일하면 두 레퍼런스는 동일(identical)하다고 표현한다. 만약 래퍼런스가 다르지만 동일한 정보를 가지고 있는 경우에는 동등(equality)하다라고 한다. 
예를 들면 아래와 같다.

```java

User jhun = new User.Builder.name("iw").build();
User glqdlt =  new User.Builder.name("iw").build();


log.info(jhun == glqdlt ?) // false
log.info(jhun.getName() == glqdlt.getName() ?) // true
log.info(jhun.getName().eqauls(glqdlt.getName())) // true

```

jhun 과 glqdlt는 서로 다른 객체로 생성되었음으로 동일하지 않다. 다만, 객체의 name 속성(프로퍼티)이 같음으로 동등하다고 표현할 수 있다.

#### 스프링 빈의 싱글톤 레지스트리

스프링 컨테이너는 기본적으로 별다른 설정이 없을 시 스프링 빈을 싱글톤으로 만든다. 이는 스프링이 개발 된 배경인 대규모 엔터프라이즈 서버 환경에서 많은 사용이 되었기 때문에 기본 사양이 싱글톤 생성으로 확인된다.

### 싱글톤은 안티 패턴이다?

+ private 생성자를 갖고 있기 때문에 상속할 수 없음.

> 싱글톤 패턴은 자신의 생성자를 private으로 제한한다. 문제는 이러한 private 생성자 클래스는 다른 생성자가 없으면 상속이 불가능하다. 객체지향의 장점인 상속과 다형성을 적용할 수 없다.

+ 싱글톤은 테스트하기가  힘들다

> 싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 목 오브젝트 등으로 대체하기가 힘들다.

+ 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못함

> 클래스 로더의 구성에 따라 싱글톤 패턴임에도 하나 이상의 오브젝트가 만들어 질 수 있다고 한다(음?), 또한 여러 개의 JVM에 분산돼어 설치 되는 경우에도 각각의 인스턴스 마다 해당 오브젝트가 생기기 때문에 진정한 싱글톤인가에 대한 딜레마에 온다.

+ 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못함.

> 싱글톤은 아무 객체나 자유롭게 접근하고 수정할 수 있기 때문에 객체지향 프로그래밍에서 권장되지 않는 모델이다.


### 싱글톤과 오브젝트의 상태

멀티스레드 환경에서 상태정보를 갖는 오브젝트는 절대 싱글톤으로 구현하면 안된다. 다중 사용자의 요청을 처리하는 경우 전역에서 싱글톤 오브젝트에 상태정보를 저장하고 호출한다면 데이터 오염의 문제가 생긴다. 이래서 싱글톤은 기본적으로 필드의 값을 변경하고 유지하는 상태유지(stateful) 방식으로 만들지 않는다. 다른 말로 하면 무상태(stateless) 방식으로 만들어야 한다.

## 1.7 의존관계 주입(DI)

### 제어의 역전과 의존관계의 주입

IoC는 소프트웨어 개발에서 자주 발견되는 일반적인 개념이다. 스프링의 IoC컨테이너도 이와 같이 객체를 생성하고 관계를 맺어주는 등의 작업을 담당한다. 한 가지 짚을 것은 IoC라는 용어가 포괄적으로 사용되는 용어이기 때문에 스프링의 컨테이너를 단순히 IoC컨테이너라고 불러서는 스프링의 아이덴티티를 설명할 수 없다고 한다. 단순히 서블릿 컨테이너처럼 서버에서만 동작하는 서비스 컨테이너를 뜻 하는 지, IoC 개념이 적용된 템플릿 메소드 패턴을 이용한 프레임워크인지, 또 다른 IoC 특징을 가지고 있는지 파악하기 힘들다.

그래서 나온 개념이 의존관계 주입(DI : Dependency Injection) 이라는 고급진 표현을 쓰기로 시작했다.
DI는 의존관계 주입? 의존성 주입? 의존 오브젝트 주입? 등으로 여러 의미로 해석될 수 있는 데, 스프링에서 가장 명확하게 설명하는 것은 오브젝트의 레퍼런스를 외부로부터 주입받아 다른 오브젝트와 관계로 연결 되는 것이 핵심임으로, 의존관계 주입이라는 해석이 가장 적절하다고 저자는 말한다.


### 런타임 의존관계

일반적으로 static한 1:1 단계에서의 의존관계는 파악 하기가 쉽다. 다만 런타임 환경에서 1:N 단계에서의 의존관계는 의존이 바뀌기도 하고, 어느 것이 사용될지 유추 할 수 없다. 고로 스프링에서는 아래 규칙을 정의해서 런타임의 의존관계를 설명한다.

+ 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.

+ 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정하게 한다.

+ 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다.

여기서 말하는 제3의 존재는 결국 스프링의 컨테이너 즉, DI를 뜻 한다. 

### 의존관계 검색과 주입

스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 것이 아니다. 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하기 때문에 의존관계 검색(dependency lookup) 이라고 불린다.


### 스프링 컨테이너의 빈 등록

||자바|XML|
|:----|:----|:----|
|빈 설정 파일|```@Configuration```|```<beans>```|
|빈의 이름|```@Bean methodName()```|```<bean id="methodName"```|
|빈의 클래스|```return new BeanClass();```|```class="a.b.c... BeanClass"/>```|

스프링 빈을 등록 시, 개인적으로 java 설정에 익숙함으로 이를 xml로 할 때 어떻게 되는 지 알아보자.

Java to XML
```java

@Configuration // --> <beans>
public SomeBeanFactory

    @Bean // --> <bean
    MyBean generateSomeBean(){ // --> id="generateSomeBean"
        Mybean myBean = new MyBean();
        myBean.setName("someBeanName"); // --> <property name="name" value="someBeanName"/>
        ...
        return myBean; // --> class="com.glqdlt...MyBean" />
    }

    @Bean // --> <bean
    SomeBeanUtil someBeanUtil(){ // --> id="someBeanUtil"
        SomeBeanUtil someBeanUtil = new SomeBeanUtil();
        someBeanUtil.setSomeBean(generateSomeBean()); // --> <property name="someBean" ref="generateSomeBean"/>
        return someBeanUtil; // --> class="com.glqdlt..SomeBeanUtil"/>
    }
    }
// --> </beans>

```

### DTD와 스키마

XML 문서는 구조를 정의하는 방법에 DTD와 스키마(schema)가 있다. 스프링은 이 두 가지 모두를 지원한다.
DTD는 에를 들어 아래와 같이 선언해서 사용할 수 있다.

```xml

<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
    "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
```

DTD를 사용할 경우에는 ```<beans>```, ```<bean>``` 외의 태그는 사용할 수 없다. 이럴 경우에는 사용할 각 태그들의 개별적인 스키마 파일을 네임스페이스에 선언해서 사용해야 한다. 이런 경우 때문에 DTD 대신 스키마를 사용하는 것을 추천한다.

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    ....
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

```

### 어플리케이션컨텍스트

어플리켄이션 컨텍스트(스프링 컨테이너)를 생성하는 방법은 여러가지가 있다.

```java

// 아래는 클래스로더의 경로에서 직접 xml을 가져오는 방법
ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");


// 아래는 SomeContextHolder.class 의 패키지에 물리적으로 같이 있는 some-context.xml 을 생성하게 하는 방법이다.
... = new ClassPathXmlApplicationContext("some-context.xml",SomeContextHolder.class);



```

## 인상 깊은 점

스프링 3-1 의 책의 목차를 보면, 목차의 가장 최우선으로 테스트 관련 된 내용이 나온다. 또한, 스프링을 학습할 때에 관한 충고에서도 좋은 개발자가 되었다고 판단할 때 더 유연한 어플리케이션 구조와 테스트 작성이 쉬워졌다고 말하고 있다. 역시 테스트 짱짱맨인가?

138쪽