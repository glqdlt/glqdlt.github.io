---
layout: post
title:  "자바8"
author: "glqdlt"
---

# 스트림

아래코드는 테스트에 사용할 픽스처를 만드는 셋업 메소드이다.
클래스 명을 보면 알겠지만, 게임머니 관련 된 로그인데, 집계하는 로직을 위한 픽스처이다.

1을 시작으로 총 10000000번의 리스트를 생성하는 로직인데, 기본 스트림으로 할 경우 이는 ```16s 353ms``` 결과가 나온다, 어림잡아 말하면 17초쯤이라 보면 될듯. 
```java
 @Before
    public void setUp() throws Exception {

        final Integer i1 = 10;
        final Integer i2 = 2000;
        this.fixture =
                IntStream.rangeClosed(1, 10000000)
                        .boxed()
                        .map(x -> {
                            Log log = new LogGameMoney();
                            log.setSeq((long) x);
                            log.setFrom((x % 2 == 0 ? null : "B_CN"));
                            log.setTo((x % 3 == 0 ? "PID1" : "PID2"));
                            log.setChangeAmount((x % 3 == 0 ? 1000L : 200L));

                            Long current = log.getChangeAmount();
                            log.setFeeMinusChangeAmount(current - ((long) (current * 0.03)));
                            log.setBeforeChangeAmount(0L);
                            log.setCurrentAmount(log.getFeeMinusChangeAmount() + log.getBeforeChangeAmount());
                            log.setRemoteIp("127.0.0.1");
                            log.setRoute(ExchangeRoute.PC_TO_MOB);
                            log.setWorkStatus(((x % 7 != 0)));
                            log.setRegDate(DateUtils.asDate(LocalDateTime.of(2011, 1, 1, 1, 1).plusMinutes(x * 2)));

                            return log;
                        }).collect(Collectors.toList());

        this.queryResponse = this.fixture.stream()
                .filter(ExchangeLog::getWorkStatus)
                .filter(x -> {
                    Long a = x.getChangeAmount();
                    return (a >= i1 && a <= i2);
                })
                .collect(Collectors.toList());

    }
```

반면 아래처럼 ```.parallel()``` 메소드를 호출해서 병렬 스트림으로 전환시키고 난 이후의 결과는.. 놀랍게도 ```10s 685ms``` 걸린다. 기존 17초에서 11초로 대략 30% 정도의 좋은 퍼포먼스가 나왔다.


```java
 @Before
    public void setUp() throws Exception {

        final Integer i1 = 10;
        final Integer i2 = 2000;
        this.fixture =
                IntStream.rangeClosed(1, 10000000)
// 병렬 스트림으로 전환
                        .parallel()

                        .boxed()
                        .map(x -> {
                            Log log = new LogGameMoney();
                            log.setSeq((long) x);
                            log.setFrom((x % 2 == 0 ? null : "B_CN"));
                            log.setTo((x % 3 == 0 ? "PID1" : "PID2"));
                            log.setChangeAmount((x % 3 == 0 ? 1000L : 200L));

                            Long current = log.getChangeAmount();
                            log.setFeeMinusChangeAmount(current - ((long) (current * 0.03)));
                            log.setBeforeChangeAmount(0L);
                            log.setCurrentAmount(log.getFeeMinusChangeAmount() + log.getBeforeChangeAmount());
                            log.setRemoteIp("127.0.0.1");
                            log.setRoute(ExchangeRoute.PC_TO_MOB);
                            log.setWorkStatus(((x % 7 != 0)));
                            log.setRegDate(DateUtils.asDate(LocalDateTime.of(2011, 1, 1, 1, 1).plusMinutes(x * 2)));

                            return log;
                        }).collect(Collectors.toList());

        this.queryResponse = this.fixture.stream()
                .filter(ExchangeLog::getWorkStatus)
                .filter(x -> {
                    Long a = x.getChangeAmount();
                    return (a >= i1 && a <= i2);
                })
                .collect(Collectors.toList());

    }
```

parallel 시의 스레드 수는 방법이 2개가 있다. 

1. 시스템 프로퍼티 값 수정

```java
System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism","6");
```

2. 직접 ForkJoinPool 을 생성해서 사용

위 처럼 ```ForkJoinPool``` 기본 구현체의 프로퍼티를 변경해서 사용하지 않고, 아래처럼 ForkJoinPool 인스턴스를 직접 만들어서 설정할수도 있다.

```java
ForkJoinPool forkjoinPool = new ForkJoinPool(5);
forkjoinPool.submit(() -> {
	someArr.parallelStream().forEach(System.out::println);
}).get();
```


## 레퍼런스

- [티몬 블로그](http://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220945933678)

- [baeldung](https://www.baeldung.com/java-groupingby-collector)



# 새로운 날싸 API

자바1.0에 생긴 Date 클래스는 날짜라는 이름과는 달리 밀리초 단위의 시간을 표현한다. 또한 1900년을 기준으로 오프셋이 설정되어있고, 날은 1부터 시작하지만 달은 0부터 시작한다.

위의 문제 때문에 자바1.1에 Calendar 클래스를 설계했다. Calendar는 오프셋이 1900년이었던 문제는 해결됬으나, 여전히 달은 0부터 시작했다. 거기다가 날짜 API가 2개나 생겨버린 탓에 개발자들이 혼동되어 고생을 많이하게 되었다.

DateFormat은 동시성 문제가 있었다. 같은 DateFormat 인스턴스를 참조하는 여러 스레드가 있다면, 특정 동시시점에 이 인스턴스를 날짜를 파싱하면 서로 엉뚱한 날짜가 파싱되어버린다.

이러한 문제들을 해결하고자 Joda-Time 이라는 써드파이 라이브러리가 탄생했다. 많은 이들이 Joda-Time 을사용했다. 특히, 자바를 완성시킨다고 불리는 스프링프레임워크 조차 core 패키지에서 이 joda-time 을 사용했다. 4.x 대를 보면 springframework.format.datetime.joda 패키지가 있는 것을 볼 수 있다.

스프링 4.x 에는 자바8을 최소요구사항으로 하지 않는 데도, LocalDate 타입을 받아들이는 걸 볼 수 있다. 사실 이 LocalDate는 Joda-time 의 Localdate 이다. import 구문을 잘 살펴보라.

```java
import java.text.ParseException;
import java.util.Locale;
import org.joda.time.LocalDate;
import org.joda.time.format.DateTimeFormatter;
import org.springframework.format.Parser;

public final class LocalDateParser implements Parser<LocalDate> {
    private final DateTimeFormatter formatter;

    public LocalDateParser(DateTimeFormatter formatter) {
        this.formatter = formatter;
    }

    public LocalDate parse(String text, Locale locale) throws ParseException {
        return JodaTimeContextHolder.getFormatter(this.formatter, locale).parseLocalDate(text);
    }
}

```

오라클은 이 Joda-Time 을 공식적으로 JAVA8 API에 탑재하기로 결정한다. Joda-Time 의 대부분의 기능은 java.time 패키지에 안착되었다.