---
layout: post
title:  "DDD"
author: "glqdlt"
---
옳바른 패키지 구성에 대한 고민이 많았다.

정답은 없는 듯

domain 별로 controller와 service 를 합치는 사람도 있고,
나처럼 service controller 를 tier 별로 엄격하게 구분하는 사람도 있다.
정답은 없는 것 같다.

오픈소스 프로젝트를 분석해도 제 각각이며, 관련 된 유명 고전책을 읽어도 정답은 없다고 한다. 패키지에 관해서는 자유롭게 구성해라는 것이 중론.

개인적으로는 tier 별로 구분을 하되, domain 한정적으로만 쓰는 service 같은 경우는 domain 안에만 꽁 박아둬도 된다고 생각이 든다.

그렇다고 그 domain에서만 쓸 거라고는 어떻게 알까?

다른 건 모르겠는데 명확한 것은 있다.

application tier 와

persistence tier 는 확실히 분리가 가능하다는 것이다.

persistence tier 는 cms 든 app 이든 server 든 어디서든 공유할 수 있게끔 분리가 되어야한다.

application 안에서 메뉴나 기획 별로 controller service 를 묶든 말든은 모르겠지만

persistence 만은 꼭 분리해야한다.

그래야 코드가 재활용이 되기 때문이다.

mybatis 같은 것들은 resultType 을 화면에서 쓸 DTO로 바로 선언하는 경우가 있는 데, 이렇다면 DTO또 persistence tier 로 가야한다. 왜냐면 mybatis 의 resultType 에 종속되기 때문이다.


자 이제 그러면 아래의 경우에는 어떻께될까?

com.glqdlt.cms.mobilepoker

com.glqdlt.mobilepoker.cms

두 개의 패키지 명에 대해서 고민을 했다.

뭐가 맞을까?

고민 끝에 도다른 결론은

com.glqdlt.cms.mobilepoker 로 했다.

이유는 com.glqdlt.mobilepoker.cms 인 경우에는 모바일포커 라는 도메인 그룹 안의 여러 시스템들이 같은 공유 기능이 있다고 가정하는 것인데.. 이런 경우가 과연 있을까이다.

하지만, com.glqdlt.cms.mobilepoker 로 간다면, cms 라는 그룹 안에서 각각의 도메인 별 cms 들은 공통된 기능을 가질 수 있기 때문.

com.glqdlt.cms.mobilepoker
com.glqdlt.cms.pcpoker
com.glqdlt.cms.motgo

이렇게 되어있다면 여기에 공통된 sso 로그인 모듈이 추가된다면

com.glqdlt.mobilepoker.sso 또는 com.glqdlt.sso.mobilepoker 이런 경우 보다

com.glqdlt.sso.cms , com.glqdlt.sso.cms.mobilepoker 이런식으로 푸는것이 자연스럽기 때문이다.

https://stackoverflow.com/questions/42946220/package-structure-in-spring-entity-vs-model-vs-controller

http://mkuthan.github.io/blog/2013/11/04/ddd-architecture-summary/


## 바운디드 컨텍스트

경계에 대한 이야기인데, 특정 API 에 의존도를 의미하는 것이 아니다.

이 API를 다듬어나가야할 주체들에 대한 경계를 의미한다.

이 말이 무엇이냐면 특정 API 의 상태 갱신이나 명확함에 대해 책임져야할 곳은 어디이며, 이를 단순히 소비만 하는 곳은 어디인지에 대한 이야기이다.

현재 조직에는 사람1명에겐 N개의 계정을 가진다고 하여, 이 사람을 가르키는 생체 식별 개념이 있다(CI, DI 등)

사람1명은 결제 한도라는 게임등급위원휘에서 적용한 정책이 부여가 된다. 즉, 특정 사람 A가 가진 계정 A1,A2 ... 등은 같은 한도내에서만 게임을할 수가 있다.

결제라는 것은 게임에서 매우 중요한 개념임으로, 이 한도를 어떻게 관리를 할 것인가가? 주요 관심사였다.

재밌는게, 우리가 서브도메인으로 표현하는 부서들 (예: game1... game2... web1.. cms1 ) 에서 이 특정 사람을 가르키는 개념이 조금씩 차이가 있었다.

어떤이는 식별값을 String 으로 보는 경우가 있었고, 개인정보보호법 때문에 어떤이는 Number 형태로 인지를 하고 있었다.

이래서 한번은 연동작업을 하는데 대난리가 났었다. String 이 와야하는 데 Number 가 오고, 어떠한 format 의 String 일것이라 했는데 A는 10글자를 B는 5글자를 주고 그랬다.

바운디드 컨텍스트는 이러한 모호함을 바로 잡자는 의미이고, 하위 도메인의 그룹이라고 볼수도 있다. 

예를 들어서 A바운디드컨텍스트{game1, game2} 에서는 Number로 쓴다. B바운디드컨텍스트{web1,cms1} 은 String 5글자로 쓴다. 이렇게 될수가 있다. 

A컨텍스트에서는 Number이고 B와 서로 다른 인코딩을 사용함으로 (나는 이렇게 주변에 설명하고 있다) 디코딩해서 원본을 획득해야하는 변환 과정 (DDD에서는 번역기 또는 convert 라고 한다)이 필요하다.

A에서 B로 변환을 하려면 B가 어떠한 API를 제공할것인가? 아니면 A에서 B 변환을 직접할 수 있도록 할것인가? 등에 따라 DDD의 클린 점수? 가 부여된다. (B에서 제공받냐? A가 직접하냐에 따른 분류가 DDD 책에 다 정의되어 있다)

다른 사례를 얘기하면, PC게임과 모바일게임에서의 계정이라는 모델에 대해서 이야기할 수 있다.

PC게임에서는 5글자의 String을 ID라고 얘기하고 있고, 모바일게임에서는 String 20글자를 ID라고 얘기하고 있었다.

재밌는 것은 모바일게임을 하려면 PC 게임의 계정에 연동이 되어야 한다는 (1:1 관계) 도메인 제약사항이 있었다.

이렇게 되면, PC게임의 ID를 모바일게임에서 가질지, 모바일게임에서 PC게임을 가질지, 양쪽다 가져야할 지에 대한 모호함이 생긴다.

특히 cms 를 만들다보면 이런 얘기가 비일비재했다. 예를 들어서 회의 때 특정 ID를 입력하여 외부와 연동되는 어떠한 기능 수행을 하는 웹 페이지 기획을 할 때의 사례이다.

화면 form 에서 input 으로 들어오는 id 는 pc game의 id 이지만, 연동되는 외부 인프라에서 id 를 의미하는 것은 외부 인프라의 id를 의미한다.

회의 떄에는 모두 input id 가 pc game 의 id 를 받을 것이고, 외부 인프라에 이 input 으로 받은 id 를 그냥 넘겨주면 된다고 얘기가 되었었다.

그런데 막상 실무를 접하면서 그 id가 이 id가 아니더라!! 라는 문제가 생기게 되었던 사례가 있다.

여기서 cms 에서는 외부 인프라에 id를 아답팅(디자인 패턴 관점에서는 아답터, 실생활 얘기로는 컨버터)해야하는 문제가 생기게 되는 데, 이 떄 누가? 어디에서? 아답팅 기능을 제공해줄 것인가 하는 문제에 봉착하게 된다.

이러한 부분을 정의하는 과정이 바운디드 컨텍스트 이다.

- https://wikibook.co.kr/article/bounded-context/

- https://qastack.kr/software/237513/what-in-reference-to-ddd-is-a-bounded-context


## 이벤트 스트리밍

카프카를 할까, 래빗MQ를 할까에 대한 고민

레빗 MQ는  아래 블로그에서 영감을 얻었다.

- https://nesoy.github.io/articles/2019-02/RabbitMQ

- https://www.rabbitmq.com/tutorials/tutorial-five-java.html

목적은 백오피스에서 캐시를 업데이트 해라는 명령에 웹서비스 서버들이 메모리에 있는 캐시를 DB에서 읽어와서 동기화해야한다.

웹 서비스 서버들은 스케일아웃되어있는데, 현재는 고정이지만 추후에 오토스케일아웃 으로 확장될 예정이었다.

가장 쉽게 하는 방법은 DB에 특성 이벤트 로그를 쌓고 이를 폴링하는 식으로 동기화 하게끔 하는 것도 생각했는데,

DB에 부하도 많고, 목적에 맞지도 않아서 소규모 서비스에서나 가능하다보니, 이 방법은 버리기로 했다 (다른 작은 서비스에서는 이렇게 했다, 이게 틀린건 아니다)

대안으로 메세징큐를 통한 구독형 아키텍처로 진행하려 했다. DDD 책에서도 소개되어서 관심이 있던터라 공부좀 많이 했는데,

결론적으로 카프카는 배보다 배꼽이 큰 형태였고, 래빗MQ가 적당했다. 관련해서는 카프카 vs 래빗MQ라는 내용을 검색해보면 좋을것이다.

단순히 동기화 해라는 이벤트를 알리기 위해 메세지 없이 토픽을 생성해서 이벤트를 알릴 용도 이기에 래빗MQ가 적당해보였다.

계획을 짠 것 까지는 좋은 데, 인프라를 구축하는 과정(VM 인스턴스 생성, 방화벽 오픈)에서 플랫폼 조직과 입씨름하기가 싫었다.

우리는 친MS여서 Azure 클라우드를 쓰고 있기에, 이미 구축된 인프라를 사용해보자 라는 아이디어가 떠올랐다.

Azure에는 서비스 버스 라는 녀석과 이벤트 허브라는 녀석 2가지가 있다.

서비스 버스가 래빗MQ라면, 이벤트 허브는 kafka와 같다.

래빗MQ와 kafka 간의 차이점에 대해 생각해보면 잘 알것이라 생각한다.

아래 링크에 서비스의 비교를 보면 잘 설명되어있다.

즉 내가 원하는 것은 서비스 버스 이다.

https://docs.microsoft.com/ko-kr/azure/event-grid/compare-messaging-services 


## 적용기

이벤트 구독을 하는 개념은 너무나 쉽다. 별도의 스레드를 만들어서 이벤트를 수신하게 하면 된다.

수신이 되면 실행될 메소드를 정의해서 리슨하고 대기하고 있으면 된다. 쉽다.

문제는 웹앱 안으로 수신이 된 순간 어떻게 컴포넌트(스프링 빈)에게 매끄럽게 알리느냐(전파)가 문제였다.

후보 군은 아래와 같다, 재미난 생각도 많이했었다.

- AOP 처리? AOP는 이미 호출이 된 상태를 후킹하는 프록시 개념이라 이 경우와는 성격이 다르다.

- localhost 루프백으로 restful api 를 호출해보자. (ㅋㅋㅋ)

  - 괜찮은 아이디어지만 이게 뭔 뻘짓인가 싶다.

- 이벤트를 처리해야할 애들을 관리하는 store(List<EventLisner>.add(SSComponentBean)를 만들어서 등록하자

  - 애초에 같은 개념으로 스프링이 해주고 있잖아


- 스프링 빈 팩토리를 얻어와서, 특정 타입을 구현한 친구를 직접 호출하자

   - 어 가만? 이게 스프링 이벤트 리스너의 역활 아닌가?
   

결론적으로 [스프링 이벤트 리스너](https://www.baeldung.com/spring-events)를 사용하기로 했다. 향후 몇년간 스프링 프레임워크를 벗어날 꺼 같지도 않고..
   
구성은 간단하다

이벤트를 알리는 친구는, 별도의 스레드에서 DB 폴링을 하던 Azure EventBus 에서 리슨을 하던 이벤트를 체크하도록하고, 

```
    private final ApplicationEventPublisher applicationEventPublisher;
```
publisher 에 이벤트를 수신했다는 걸 스프링에 위임시키도록 했다.

이제 포인트인 ApplicationListener 인터페이스를 이벤트를 처리해야할 컴포넌트에 구현하도록 하게 했다, 애초에 이미 스프링 빈으로 등록되는 애들이기 때문에 매우 간결해진다.

실제 로직은 아래와 같다. 아 참고로 ```@PostConstruct``` 는 다 알겠지만, 빈이 최초로 등록 되고 준비가 됬을 때 최초 캐시를 삽입하기 위해서 달아둔 것이다.

```
@Component
public class SimpleGameChaseStoreImpl implements GameCacheStore<GameVO> , ApplicationListener<GameListCacheReloadEvent> {
    
    ...
    
    @PostConstruct
    public void sync() {
        this.gameChache = gameRepo.findAll().stream().map(GameVO::new).collect(Collectors.toList());
    }
    
    @Override
    public void onApplicationEvent(GameListCacheReloadEvent gameListCacheReloadEvent) {
        sync();
    }
}
```





