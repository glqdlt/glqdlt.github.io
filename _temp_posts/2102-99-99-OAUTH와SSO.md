---
layout: post
title:  "릴리즈 프로세스"
author: "glqdlt"
---



# OAUTH

사내의 다양한 게임 관리 서버(CMS)들을 통합할 일이 생겨서, 통합 인증 (SSO) 관련 공부를 하다 마주하게 된 녀석이 OAUTH 였다.
Spring boot 의 최근 예제들을 보면 온 클라우드 기반의 예제들이 많이 나오는 데, 거기에 주축이 되는 MSA에 사용 되는 인증 체계가 대부분 OAUTH 관련 예제가 많이 나온다. 그렇다보니 OAUTH를 실무에서 마주했을 때 거부감은 없었지만 테크니컬 리더로서의 입장에서 막상 이 놈을 가이드 하려고 보니, 깊이감이 없다는 걸 느끼게 되서 진득하게 공부해보기로 했다.


OAUTH를 공부하다 보면 버전이 OAuth 1.0 이 있고 OAuth 1.0a 가 있는 데, 어떤 사람은 1.0과 1.0a 를 같은 느낌으로 부르는 사람이 있는 반면, 두 개는 완전히 다른 버전이라고 말하는 사람이 있다. 여기에 최근에는 2.0 버전을 많이 사용 하는 데, 이 OAuth 2.0은 초안(Draft) 버전이라고 한다. 이렇다 보니 구글링해서 나오는 국내 블로그의 글들을 보면 혼란 그 자체이다. 이렇다 보니 뭣 모르고 공부하다가는 잘못된 지식으로 인해서 실무에서 욕먹기 좋은 케이스가 되기 마련이다.

역시 공부에 가장 좋은 것은 공식 [레퍼런스](https://www.oauth.com/)를 참고하는 것이 최고지만, 영어의 압박으로 공부하기가 여간 쉽지 않은 것도 사실 -_-;

## What is OAuth

OAUTH는 {OAUTH 뜻} 이라는 의미의 인증 프로토콜이다.

주구난방인 이유는 OAuth 의 탄생 배경부터 거슬러 올라가보면 입밖으로 나와야 할 욕이 목구녕에서 삼킬 수 있을 만한 납득이 생긴다. 

{OAuth를 트위치에서 만든 이유에 대해 설명}


### OAUTH 1.0a

### OAUTH 2.0

## Architecture

### Authorization Server

### Resource Server

[공식레퍼런스](https://www.oauth.com/oauth2-servers/the-resource-server/) 를 보면 리소스서버를 아래와 같이 설명하고 있다.

> The resource server is the OAuth 2.0 term for your API server. The resource server handles authenticated requests after the application has obtained an access token.

해석하면 브라우저(유저겠죠?)가 호출하는 어플리케이션의 API를 뜻(OAuth 2.0에서 이렇게 부름) 한다.

리소스 서버가 하는 일은 명확하게 한가지이다. Authorzization Server가 토큰을 발급하는 주체라면 리소스 서버는 발행 된 토큰이 어떠한 효력이 있는지를 검사한다.


### JWT

JWT 는 OAuth 의 다양한 인증 방법들 중에서 대표적인 stateless 하고 무결성을 보장하는 인증 방법 중 하나이다. 

JWT 의 데이터 구조는 개미의 몸통을 연상하는 구조를 가지고 있다. 정확한 표현은 아니지만 기본적으로 JWT는 3등신 구조이고, 이를 개인적으로는 쉽게 설명하려고 header, body, tail 이라고 부르고 있다. 각 영역에는 base64로 인코딩 된 데이터로 채워져있고 영역의 구분자는 , 로 되어 있다.

header 에는 이 JWT 토큰의 인크립트 방식에 대한 메타 데이터가 서술되어 있다. 어떠한 암호 알고리즘을 썼는지에 관한 이야기이다. 

body 에는 이 토큰의 사용자에 대한 User Data 가 포함되어 있다. 대부분 User의 권한에 대한 데이터를 필수적으로 담고, 추가적으로 닉네임이나 이메일 주소 같은 것을 담는다.

tail 에는 JWT의 꽃이라 불리우는 무결성 보장에 관한 영역이다. tail에 인코딩 된 데이터를 디코딩 해보면 header와 body에 비해 알 수 없는 난수값으로 떡칠 되어 있는 것을 볼 수 있다. 이거는 JWT를 발급해준 녀석이 이 JWT 토큰이 더럽혀졌는가, 위조됬는가를 알기 위해 담은 서명 데이터이다. 기본적으로 이 tail에는 아래의 메카니즘으로 데이터가 삽입된다.

> header data + body data + {private key}  ==> 쓰까쓰까 = tail 의 난수값

구성을 보면 바로 알겠지만 header와 body 어느 한 곳에 점 하나 찍던, 공백을 추가하던지 데이터가 바뀌면 이 tail 의 난수값이 달라지게 된다. 

### 보안 

OAuth 관련 Configuration을 구현하다보면 옵션 중에, SSL Only 라는 옵션을 찾을 수 있다. 왜 이런 옵션이 있는 걸까? 이유는 간단하다. OAuth도 그렇고 기본적으로 웹 프로토콜은 stateless 하기 때문에 서버 입장에서 이 클라이언트가 누구냐? 를 명확하게 알지 못 한다. 그져 특별한 난수 (session id)를 클라이언트의 손에 쥐어주고 (그게 cookie 가 되었든, localstorage가 되었든) 나중에 다시 찾아올 때, 이걸 나에게 다시 보여줘라고 말할 뿐이다. 처음에 손에 쥐어줄 때 2m의 장신에게 손에 쥐어줬는지, 1m 의 단신에 줬던지는 관심없다. 서버가 기억하는 특별한 난수 값만 동일한 걸 보여주기만 하면 'ㅇㅋ 너 그 때 그놈이구나' 하고 허가 해버릴 뿐이다.

이와 같은 맥락으로 OAuth도 역시 Access Token이 유출 되면 난리나게 된다. 대부분의 사람들이 오해하기로, 최근에 토큰 기반의 인증체계로 바뀐 것은 Id Password를 쌩으로 입력하는 것보다 안전해서가 아니다. User의 ID나 Password가 노출이 되면 다른 웹 서비스에서 같은 ID Password를 썼을 시에 2차 피해가 크기 떄문에 Token 기반으로 하는 것이지 (디바이스의 다양성 등도 있긴 하지만) token 이 유출되도 안전해서가 아니다. token을 해커가 man in man 공격 등과 같은 기법으로 가로채서 서버에 인증을 했을 때, 서버 입장에서는 이게 해커인지 정상 유저인지 알 방법이 없다.

# SSO
