---
layout: post
title:  "예외처리에 관해"
author: "glqdlt"
---


https://stackoverflow.com/questions/51959160/java-extends-runtimeexception-filed-value-is-thread-safe


컨트롤러에서 들어오는 많은 요청들을 사용하는 서비스에서

어떠한 값을 DB에 읽고 return하는 단순한 로직인데,

DB의 값이 없을 경우 인위적인 runtime exception 을 만들어서

자기를 호출한 컨트롤러에 상태를 알리는 형태로 자주 사용했다.

여기에 더 나가서 runtime exception 을 상속받은 MyException을 만들고 해당 클래스의 field에 에러코드를 담아서 공유 하려고 했다.

```java

public class MyException extends RuntimeException {

private MyErrors error;

public MyException() {
}

public MyException(String message) {
    super(message);
}


public MyException(MyErrors error) {
    super(error.getMessage());
    this.error = error;
}


```

문제는 나는 이 MyException이 다른 서블릿에서도 호출이 되기 때문에 에러코드를 담은 error 필드가  thread-safe 않지 않을까 하는 생각을 했는 데,

stackoverflow 에서 괜찮은 정보를 얻을 수 있었다.

정확한 의미로는 error 필드를 thread-safe 하게 하려면 final 키워드를 써야하는게 맞지만, 

throw 받는 thread만이 발생 한 예외에 접근할 수 있기 때문에, 필드 값의 thread-safe 를 고려하지 않아도 된다는 것이다.


> As the commenter mentioned, you can make your exception thread-safe by using the final keyword, assuming that MyErrors is thread-safe as well.
However, you should note that your concern that
the value of the 'error' field in MyException might change if MyService is used in a multithreaded environment and many MyException occur.
Is not valid here. There is no need for your exception to be thread safe because even when the exception is thrown, it will only ever be available to the throwing thread. Since MyException appears to be a runtime exception, you don't appear to be propagating the exception, so it doesn't look like you will be sharing the state of the exception anywhere once it has been thrown.
I recommend that you keep the exception non-thread-safe if that is the case.

https://stackoverflow.com/questions/51959160/java-extends-runtimeexception-filed-value-is-thread-safe

