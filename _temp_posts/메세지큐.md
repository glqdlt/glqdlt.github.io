메세지 큐를 도입할 이유가 있어서, RABBITMQ 를 통해서 AMQP 를 이해하고 있다.

도입 이유는 특정 관리 툴에서 이벤트를 발생시키면, 이 이벤트에 관심있는 벡엔드 서비스 풀의 서버(3대 정도)들이 모드 이벤트에 반응해야하는 미션이다. 캐시 갱신 관련된 내용으로 개발이 필요해졌다.

AMQP의 구성요소

- Exchange 

교환소 또는 중개소로 이해하면 쉽다. 메세지 생성자 (producer) 로 부터 메세지를 전달받으면, 메세지를 큐에 발송(실제로는 레퍼런스 연결이다)시켜준다.

- Queue

큐는 메세지 소비자 (consumer) 를 위한 메세지 저장 공간이다. 말 그대로 자료구조의 큐이다. 들어간 순서대로 소비자에 의해서 소비 된다.

참고로 아래에서 설명하겠지만, 큐에는 여러명의 소비자가 연결될수 있다. 기본적으로 큐는 소비자가 메세지를 읽어가면 메세지를 삭제한다. 이렇게 되면 N명의 소비자가 1개의 큐에 붙어있다고

N명이 모두 브로드캐스팅 되는 구조는 절대 불가능하다. 기본적으로 라운드로빈과 같은 알고리즘으로 큐에 붙은 소비자에게 병행 처리를 위한 개념으로 만들어진 것이 큐이다.

- Binding

Exchange 와 Queue 의 관계에 해당한다. Exchange는 여러개의 Queue와 묶일 수 있다. 여기서 묶일 수 있다에 해당하는 처리를 이 Binding 이 한다.

Exchange의 패턴(타입 이라고도 한다)

Exchange는 여러개의 Queue와 연결될 수 있다고 했다. Exchange 1-1 Queue 일수도 있고, Exchange 1-N Queue 일수도 있다는 말이다.

여기 패턴은 Exhcnage가 어떠한 Queue에 메세지를 전달해야할 지에 대한 패턴을 의미한다. 하나의 큐에 전송, 그룹에 전송, 그냥 모두다 전송 이런 느낌이다.

- Direct Exchange (특정 큐를 지정해서 발송)

내가 방송회사 다닐 때 나오던 용어가 나온다, Unicast 즉 특정 타겟을 지정해서 발송한다는 것이다.

어디 누구에게 보내줘라는 개념으로, Route Key 라는 놈이 나온다. 즉 Queue 의 주소를 Route Key라고 이해하면 쉽다.

- Fanout Exchange

Broadcast 말그대로 Exchange에 연결된 모든 Queue 아몰랑 하고 다 쏴버리는 거다.

- Topic Exchange

Multicast 이다. Route Key 에 해당하는 모든 Queue 에 전달한다. 사실 Direct와 Topic 의 차이점에 대해서 개념적으로는 비슷해보이지만, Direct는 N개의 Key가 매칭되도 하나만 보내는 거고, Topic 은 매칭 되는 N개 모두 발송해주는 패턴이다.

- Headers Exchange

좀 더 복잡한 Topic Exchange 라 보면 좋다. Route Key를 통해 발송해야할 Queue를 식별하는 개념이었다면, 이 Headers 의 경우 좀 더 추가적인 발송 이유에 해당하는 Queue에만 발송한다.

인증이라던지, 특정 그룹에 보낸다던지 여러개의 custom 한 Queue 발송 규칙으로 쏴라고 해놓은 것이다.


## 삽질

아래 예제를 구성해서 빌드한 jar를 여러개의 인스턴스(프로세스)로 실행하면, 특정 A 인스턴스에만 자꾸 hello 메세지가 receive 되더라

https://spring.io/guides/gs/messaging-rabbitmq/

내가 원한 것은 여러개의 인스턴스가 동시에 hello 가 receive 되길 원했다 (broadcast)

위에서 살짝 얘기했지만, 큐는 기본 개념으로 (변경할수도 있는듯?) 여러명의 소비자가 연결될수는 있지만, 라운드로빈으로 소비자 중 한명이 메세지를 읽어가면 그 메세지는 제거된다. 

이를 이해하려면 위 예제에서 메세지 submit 하는 것을 1번이 아닌 for 문으로 1000번을 보내보면 라운드로빈으로 동작하는 것을 알수가 있다.

어쩃든 나는 동시에 모두 hello 를 찍고 싶었고, Queue 이름을 각기 다르게 해서 Exchange 에 연결하면 되지 않을까 하고

Queue 이름을 UUID 로 만들어서 했더니 원하는 대로 되었다.

개념적으로 보면 아래처럼 Queue를 만들었다.

- Queue A(1qswwqc, hello-route-key, sampleExchange)

- Queue B(2asd2!, hello-route-key, sampleExchange)

여기서 궁금해지는 게 Queue가 인스턴스 기준의 로컬에 생성되는 큐인지, 아니면 RabbitMq 내부에서 생성되는 큐인지 궁금해진다, 이는 나중에 보도록하고

어쨋든 위 삽질을 해서 이해하고 나니, Exchange와 Queue 간의 관계를 어떻게 구성해야할지인 Binding 에도 패턴이 있지 않을까 생각해보게 되었다.

있더라

## 래빗엠큐 설계 패턴

https://www.rabbitmq.com/getstarted.html

1. Hello World!

<img src="https://www.rabbitmq.com/img/tutorials/python-one-overall.png">

가장 심플한 형태, Exchange 한개 Queue 한개 Queue 에 연결된 소비자 1개 이다. Restful API 호출하듯이 직접 쏴지는 느낌으로 이해하면 쉬움


2. Work Queues

위에서 얘기했던 Queue에는 여러개의 소비자(Consumer)가 붙을 수 있다. 다만 소비자들 중 언놈이던 간에 한놈이라도 메세지를 읽으면(소비하면) 메세지는 제거 된다 규칙을 응용한 패턴이다.

- Round-robin dispatching

<img src="https://www.rabbitmq.com/img/tutorials/python-two.png">

L4, L7 라우터나 멀티코어 라운드로빈과 똑같다. 1,2,3,4 1,2,3,4 이런식으로 순차적으로 돌린다. 조금 재밌는 건 이번에 보내야할 건 1, 이번에 보내야할 건 2 이런식으로 보내면 보내야할 카운트를 단순 증가시키고 보내는 개념이라.. 1과 2와 같은 초기에 메세지를 받게 되는 소비자에 부하가 몰릴수 있다.

아래와 같은 시나리오를 말한다.

1,2,3,4,1,2

여기서 아직 1,2는 처음에 받은 메세지를 처리하고 있는데도 2번째 메세지를 받는다.

- Fair dispatch

<img src="https://www.rabbitmq.com/img/tutorials/prefetch-count.png">

라운드로빈의 문제를 조금 완화 하려고 만든 개념이다. 라운드로빈은 소비자가 메세지를 다 처리했는지는 신경쓰지 않지만, Fiar dispatch는 메세지를 처리했는지 확인하고 바쁘면 다른 친구에게 넘기는 개념이다.

구현도에서 조금 문제가 생길수 있는데, 소비자가 메세지를 다 처리했다는 ack 응답을 하지 않으면, 이 소비자는 영원히 메세지를 못받게 된다. 주의해야한다.


3. Pub/Sub

Work Queues 와 다르게 Pub/Sub은 무조건 2개 이상의 Queue가 있을 것을 가정한다. 즉 멀티캐스트/브로드캐스팅을 위한 개념이다.

- Putting it all together

<img src="https://www.rabbitmq.com/img/tutorials/exchanges.png">

가장 기본적인 형태다. exchange에 등록된 큐에 모두 발송해준다, braod cast

- Topic

<img src="https://www.rabbitmq.com/img/tutorials/python-five.png">


멀티캐스트처럼 특정 큐에만 보내기 위한 라우트키 를 확인해서 매칭되는 큐에만 보낸다. 가장 많이 사용한다.


- Routing

<img src="https://www.rabbitmq.com/img/tutorials/direct-exchange.png">

Queue의 용도에 따라 Exchange 가 어디 Queue로 쏴야할지를 판단하는 패턴이다. L4처럼 라우팅 하는 개념.
