메세지 큐(사실 메세지 브로커가 더 정확하다. by 2020-10-27)를 도입할 필요가 생겨서 RABBITMQ 를 통해서 AMQP 를 공부하고 있다.

도입 이유는 시스템 관리 툴에서 이벤트를 발생시키면, 이 이벤트에 관심있는 벡엔드 서비스 풀에서(3대 정도) 이벤트에 반응해야하는 미션이다. 관련해서는 대표적으로 캐시 갱신 관련된 내용의 기능이 있다.

AMQP의 구성요소

- Exchange 

교환소 또는 중개소로 이해하면 쉽다. 메세지 생성자 (producer) 로 부터 메세지를 전달받으면, 메세지를 큐에 발송(실제로는 레퍼런스 연결이다)시켜준다.

- Queue

큐는 메세지 소비자 (consumer) 를 위한 메세지 저장 공간이다. 말 그대로 자료구조의 큐이다. 들어간 순서대로 소비자에 의해서 소비 된다.

참고로 아래에서 설명하겠지만, 큐에는 여러명의 소비자가 연결될수 있다. 기본적으로 큐는 소비자가 메세지를 읽어가면 메세지를 삭제한다. 이렇게 되면 N명의 소비자가 1개의 큐에 붙어있다고

N명이 모두 브로드캐스팅 되는 구조는 절대 불가능하다. 기본적으로 라운드로빈과 같은 알고리즘으로 큐에 붙은 소비자에게 병행 처리를 위한 개념으로 만들어진 것이 큐이다.

- Binding

Exchange 와 Queue 의 관계에 해당한다. Exchange는 여러개의 Queue와 묶일 수 있다. 여기서 묶일 수 있다에 해당하는 처리를 이 Binding 이 한다.

Exchange의 패턴(타입 이라고도 한다)

Exchange는 여러개의 Queue와 연결될 수 있다고 했다. Exchange 1-1 Queue 일수도 있고, Exchange 1-N Queue 일수도 있다는 말이다.

여기 패턴은 Exhcnage가 어떠한 Queue에 메세지를 전달해야할 지에 대한 패턴을 의미한다. 하나의 큐에 전송, 그룹에 전송, 그냥 모두다 전송 이런 느낌이다.

- Direct Exchange (특정 큐를 지정해서 발송)

내가 방송회사 다닐 때 나오던 용어가 나온다, Unicast 즉 특정 타겟을 지정해서 발송한다는 것이다.

어디 누구에게 보내줘라는 개념으로, Route Key 라는 놈이 나온다. 즉 Queue 의 주소를 Route Key라고 이해하면 쉽다.

- Fanout Exchange

Broadcast 말그대로 Exchange에 연결된 모든 Queue 아몰랑 하고 다 쏴버리는 거다.

- Topic Exchange

Multicast 이다. Route Key 에 해당하는 모든 Queue 에 전달한다. 사실 Direct와 Topic 의 차이점에 대해서 개념적으로는 비슷해보이지만, Direct는 N개의 Key가 매칭되도 하나만 보내는 거고, Topic 은 매칭 되는 N개 모두 발송해주는 패턴이다.

- Headers Exchange

좀 더 복잡한 Topic Exchange 라 보면 좋다. Route Key를 통해 발송해야할 Queue를 식별하는 개념이었다면, 이 Headers 의 경우 좀 더 추가적인 발송 이유에 해당하는 Queue에만 발송한다.

인증이라던지, 특정 그룹에 보낸다던지 여러개의 custom 한 Queue 발송 규칙으로 쏴라고 해놓은 것이다.


## 삽질

아래 예제를 구성해서 빌드한 jar를 여러개의 인스턴스(프로세스)로 실행하면, 특정 A 인스턴스에만 자꾸 hello 메세지가 receive 되더라

https://spring.io/guides/gs/messaging-rabbitmq/

내가 원한 것은 여러개의 인스턴스가 동시에 hello 가 receive 되길 원했다 (broadcast)

위에서 살짝 얘기했지만, 큐는 기본 개념으로 (변경할수도 있는듯?) 여러명의 소비자가 연결될수는 있지만, 라운드로빈으로 소비자 중 한명이 메세지를 읽어가면 그 메세지는 제거된다. 

이를 이해하려면 위 예제에서 메세지 submit 하는 것을 1번이 아닌 for 문으로 1000번을 보내보면 라운드로빈으로 동작하는 것을 알수가 있다.

어쩃든 나는 동시에 모두 hello 를 찍고 싶었고, Queue 이름을 각기 다르게 해서 Exchange 에 연결하면 되지 않을까 하고

Queue 이름을 UUID 로 만들어서 했더니 원하는 대로 되었다.

개념적으로 보면 아래처럼 Queue를 만들었다.

- Queue A(1qswwqc, hello-route-key, sampleExchange)

- Queue B(2asd2!, hello-route-key, sampleExchange)

여기서 궁금해지는 게 Queue가 인스턴스 기준의 로컬에 생성되는 큐인지, 아니면 RabbitMq 내부에서 생성되는 큐인지 궁금해진다, 아마 로컬에도 수신을 위한 버퍼용 임시 큐가 있을것이고, RabbitMq 에는 무조건 exchange에 메세지 수신을 위한 큐가 무조건 생성 될 것이다. 이는 나중에 보도록하고..

어쨋든 위 삽질을 해서 이해하고 나니, Exchange와 Queue 간의 관계를 어떻게 구성해야할지인 Binding 에도 패턴이 있지 않을까 생각해보게 되었다.

있더라 https://www.rabbitmq.com/tutorials/tutorial-three-python.html


pub/sub 기능일 직접 만든 것은 아니고, exchange의 특성을 응용한 패턴 기반의 기능이다.

그러니깐 pub/sub 을 메카니즘으로 이해하는 게 아니라, 응용 패턴으로 바라보면 이해가 쉬워진다.

레빗MQ는 메세지 수신이라는 개념으로 보면 아래의 총 4티어 구성의 추상화를 가진다.

메세지 제공자 - 교환소 - 메세지 큐 - 메세지 소비자

위의 pub/sub 패턴 링크에 보면 나의 삽질이 왜 성공한 것인지에 대한 해답이 있는데,  이 4계층(티어)의 역활을 보면 이해할수 있다.

메세지 제공자는 메세지 생성에 집중하고, 생성된 메세지는 메세지 원본을 교환소에 던지기만 한다.

교환소는 기본적으로 자기에 설정된 메세지 큐에 메세지를 전달해주는 역활만한다.

메세지 큐는 메세지를 등록받고, 메세지 소비자가 메세지를 획득하면 이를 제거 한다.

메세지 소비자 큐에 등록된 메세지를 실제로 사용하는 주체이다. 메세지를 읽고나면, 자동적으로 메세지 큐가 읽은 메세지를 제거한다.

일반적으로 메세지 큐에서 브로드캐스팅될 것이라 생각하지만, 사실 교환소에서 브로드캐스팅하는 개념인 것이다.

pub/sub 모델에서 메세지 큐와 메세지 소비자는 1:1 관계의 사실 메세지 큐가 메세지 소비자가 되는 셈이 되고, 교환소와 메세지 큐가 1:N 으로 되어 브로드캐스팅 되는 것이다.

참고로 브로드캐스팅이 기본 기능은 아니고, 브로드캐스팅용 교환소 타입이 있다. 위에 잠시 나왔듯 이 녀석의 이름은  fanout exchange 이고, topic exchange이다.




## 래빗엠큐 설계 패턴

https://www.rabbitmq.com/getstarted.html

1. Hello World!

<img src="https://www.rabbitmq.com/img/tutorials/python-one-overall.png">

가장 심플한 형태, Exchange 한개 Queue 한개 Queue 에 연결된 소비자 1개 이다. Restful API 호출하듯이 직접 쏴지는 느낌으로 이해하면 쉬움


2. Work Queues

위에서 얘기했던 Queue에는 여러개의 소비자(Consumer)가 붙을 수 있다. 다만 소비자들 중 언놈이던 간에 한놈이라도 메세지를 읽으면(소비하면) 메세지는 제거 된다 규칙을 응용한 패턴이다.

- Round-robin dispatching

<img src="https://www.rabbitmq.com/img/tutorials/python-two.png">

L4, L7 라우터나 멀티코어 라운드로빈과 똑같다. 1,2,3,4 1,2,3,4 이런식으로 순차적으로 돌린다. 조금 재밌는 건 이번에 보내야할 건 1, 이번에 보내야할 건 2 이런식으로 보내면 보내야할 카운트를 단순 증가시키고 보내는 개념이라.. 1과 2와 같은 초기에 메세지를 받게 되는 소비자에 부하가 몰릴수 있다.

아래와 같은 시나리오를 말한다.

1,2,3,4,1,2

여기서 아직 1,2는 처음에 받은 메세지를 처리하고 있는데도 2번째 메세지를 받는다.

- Fair dispatch

<img src="https://www.rabbitmq.com/img/tutorials/prefetch-count.png">

라운드로빈의 문제를 조금 완화 하려고 만든 개념이다. 라운드로빈은 소비자가 메세지를 다 처리했는지는 신경쓰지 않지만, Fiar dispatch는 메세지를 처리했는지 확인하고 바쁘면 다른 친구에게 넘기는 개념이다.

구현도에서 조금 문제가 생길수 있는데, 소비자가 메세지를 다 처리했다는 ack 응답을 하지 않으면, 이 소비자는 영원히 메세지를 못받게 된다. 주의해야한다.


3. Pub/Sub

Work Queues 와 다르게 Pub/Sub은 무조건 2개 이상의 Queue가 있을 것을 가정한다. 즉 멀티캐스트/브로드캐스팅을 위한 개념이다.

- Putting it all together

<img src="https://www.rabbitmq.com/img/tutorials/exchanges.png">

가장 기본적인 형태다. exchange에 등록된 큐에 모두 발송해준다, braod cast

- Topic

<img src="https://www.rabbitmq.com/img/tutorials/python-five.png">


멀티캐스트처럼 특정 큐에만 보내기 위한 라우트키 를 확인해서 매칭되는 큐에만 보낸다. 가장 많이 사용한다.


- Routing

<img src="https://www.rabbitmq.com/img/tutorials/direct-exchange.png">

Queue의 용도에 따라 Exchange 가 어디 Queue로 쏴야할지를 판단하는 패턴이다. L4처럼 라우팅 하는 개념.



## 이벤트 소싱

## CQRS

https://docs.microsoft.com/ko-kr/azure/architecture/patterns/cqrs


독립적인 크기 조정. CQRS를 통해 읽기 및 쓰기 워크로드를 독립적으로 확장하고 더 적은 수의 잠금 경합이 발생할 수 있습니다.
최적화 된 데이터 스키마. 읽기 쪽에서는 쿼리에 최적화된 스키마를 사용하는 반면 쓰기 쪽에서는 업데이트에 최적화된 스키마를 사용할 수 있습니다.
보안. 올바른 도메인 엔터티만 데이터에서 쓰기를 수행할 수 있는지 쉽게 확인할 수 있습니다.
문제의 분리. 읽기 및 쓰기 쪽을 구분하면 유지 가능하고 유연한 모델을 생성할 수 있습니다. 대부분의 복잡한 비즈니스 논리는 쓰기 모델로 이동합니다. 읽기 모델은 상대적으로 간단할 수 있습니다.
단순한 쿼리 읽기 데이터베이스에서 구체화된 뷰를 저장하여 쿼리할 때 애플리케이션은 복잡한 조인을 방지할 수 있습니다.


CQRS 는 말그대로, 커맨드 쿼리의 롤을 스플릿 한다는 얘기다.

커맨드는 CRUD 에서 READ 를 제외한 모든 트랜잭션 유발작업을 말한다.  

쿼리는 READ 를 의미한다. DB에 국한하지 않는다 질의라는 개념의 쿼리를 말함.

모델은 비지니스 로직 및 도메인 오브젝트를 포함하는 도메인 핵심 계층을 말한다.

한국 SI로 말하면, DTO 와 DAO 그리고 이 둘을 연결하는 SPRING SERVICE 컴포넌트를 말할 수 있다.

이는 기존에 조회는 READONLY SLAVE DB 에 조회한다. WRITE 는 MASTER DB에 한다의 경험과 유사하게 맞아 떨어진다. 사실 이는 저수준의 CQRS 이다.

<img src='https://docs.microsoft.com/ko-kr/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-separate-stores.png'>

https://docs.microsoft.com/ko-kr/azure/architecture/patterns/cqrs

> 읽기 저장소는 쓰기 저장소의 읽기 전용 복제본이거나 읽기 및 쓰기 저장소가 전혀 다른 구조일 수 있습니다. 읽기 전용 복제본을 여러 개 사용 하면 특히 읽기 전용 복제본이 응용 프로그램 인스턴스에 가까운 위치에 있는 분산 시나리오에서 쿼리 성능을 향상 시킬 수 있습니다.

다만 이는 복제 DB의 성격 탓에 조회 모델에만 있어야할 필드가 아직도 커맨드 모델에도 존재한다거나, 조회 모델에는 관계를 맺지 않아도 될 객체 조인이 되는 문제가 발생할수 도 있다.

조회 모델에만 있어야할 필드가 만약 수정되거나 삭제되면 적어도 생성자나 정적 생성 메소드로 클래스를 인스턴스 하는 순간에 커맨드 모델에도 영향이 갈수도 있다.

예를 들면 유저를 조회하는 쿼리 모델이 있고, 유저의 아이디만 바꾸는 API 기능이 있다고 할 때, 아이디만 바꾸는 API 기능은 유저의 이메일이나 비밀번호를 알 필요가 없으나 메모리에 계속 같이 돌아다니게 될 수 있다. 

또한 커맨드 모델에는 validate() 이나 convert :: THIS -> T 와 같은 변환기를 가질수 있으나, 쿼리 모델은 이에 대해 관심이 없다.

이런 까닭에 타입언어인 자바를 사용하다 보면 프로토타입 언어처럼 객체를 구성하는 필드를 속성이라고 부르고, 속성(TRAIT)의 집합이 객체가 되는 경우처럼 사용하고 싶은 니즈가 생길 수 있는데, 자바는 Map 자료구조를 써야하나 고민이 될 수도 있다.

또한 관계를 맺지 않아도 되는 경우에 대한 이야기는, @OneToMany 처럼 Lazy 로 로드 되는 경우는 괜찮으나, @OneToOne 과 같은 EAGER 로 즉시 조회가 되는 경우에는 DB 부하가 증가한다. (여기서 부하란 DB에서 쿼리에 따른 응답을 위해 전체 응답 레코드들을 메모리에 소비하는  (출력 스트림을 여는) 것을 이야기 한다.)

이런 이유로 커맨드(쓰기 모델) 모델은 트랜잭션을 지원하는 RDBMS 와 같은 관계 구조의 DB를 사용하고 조회 모델은 NOSQL로 병렬 확장이 용이한 DB를 사용하기도 한다.

다만 반대로 커맨드의 객체 구조가 자주 바뀌는 경우 때문에 NOSQL, 조회에 SQL 로 하기도 하는 등 이건 조직과 도메인의 환경에 따라 바뀔수 있다.

아까 나의 경우처럼 Mysql Master Slave 를 서로 다른 용도로 나누고, DB는 복제본이지만 커맨드 모델 용 조회 모델용으로 각기 다른 모델로 구성해서 사용해도 된다.


### 이벤트소싱과 CQRS 의 조합

<img src='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbGKS3y%2FbtqD3H3uVQ7%2F5Yxj72Xh1TNdIkLDGKWUNK%2Fimg.png'>

이벤트 소싱은 어떠한 목적을 가진 기능의 수행(즉 로직) 이 이벤트라는 메세지의 전파로 체이닝 되는 것을 말한다.

CQRS 가 조회 모델과 커맨드 모델이 나누어졌다는 관점을 이벤트 소싱에 적용하면 아래처럼 된다.

1. 유저가 물건 구매 버튼을 누른다.

2. 물건 구매 버튼에 해당하는 커맨드를 담당하는 컨트롤러(서비스 API) 에 요청이 되거나, 물건 구매 버튼을 눌렀음을 알리는 이벤트가 exchanger 를 통해 알려진다.

3. 물건 구매 버튼의 리드를 담당하는 주체가 프로세스의 시작을 알리며, 프로세스를 구분하는 식별 EVENT_ID(UUID)를 생성하고, 생성되었음을 exchanger 로 전파한다. 이 때는 프로세스가 어떻게 흘러가는 지의 시퀀스를 의미하는 VERSION 필드 또는 SEQ 필드에 값이 1로 할당되며, TYPE 은 BUY_ITEM, TARGET = {USER_ID} 가 될 것이다.

4. 재고가 남아있는지 확인을 하는 서비스가 재고의 확인을 하고 남았음을 알린다.

5. 결재 서비스와 재고 차감 서비스가 병렬로 작업이 된다.

6. 이 모든 것은 메세지 코디네이터(또는 글로발 메세지 트랜잭션 매니저)가 설정한 타임아웃으로 시작-> 종료 과정이 타임아웃 시간내에 이루어져야 한다. 이루어지지 않는다면, 코디네이터가 롤백 명령을 날리게 되며, 이 롤백은 운이 좋게 롤백과 성공이 동시에 일어났더라도 모두다 롤백을 해야한다.

