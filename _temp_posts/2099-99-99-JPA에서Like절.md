---
layout: post
title:  "자바 아티팩트를 도커로 배포"
author: "glqdlt"
---


//    https://stackoverflow.com/questions/7688891/sql-like-vs-contains-different-results
//    Like 는 에러가 난다. containing 하고 차이가 뭘까?
//    SignUp findAllByPlayerIdLike(String id);
//    boolean existsAllByIpLike(String ip);
//    boolean existsAllByIpIsLike(String ip);
//    List<SignUp> findAllByIpLike(String ip);
//    boolean existsAllByDeviceKeyLike(String devicey);


    like 는 .. … where x.firstname like ?1

    containing 은 … where x.firstname like ?1 (parameter bound wrapped in %)

	두 개의 차이는 containing 이 우리가 많이 쓰는 like

	contins 도 있는 데 이는 파라미터가 복수형인 콜렉션 타입일 때 쓰는 것이다

	Object on collection like properties as contains.

	https://docs.spring.io/spring-data/jpa/docs/current/reference/html/

	```java
	interface UserRepository extends CrudRepository<User, String>,
                                 QuerydslPredicateExecutor<User>,                
                                 QuerydslBinderCustomizer<QUser> {               

  @Override
  default void customize(QuerydslBindings bindings, QUser user) {

    bindings.bind(user.username).first((path, value) -> path.contains(value))    
    bindings.bind(String.class)
      .first((StringPath path, String value) -> path.containsIgnoreCase(value)); 
    bindings.excluding(user.password);                                           
  }
}

	```


자바에서 관계가 형성 된 엔티티끼리에서 FK를 가지는 하위 엔티티에서 save 시에 상위 엔티티에도 저장이 자동으로 되게할 것인지에 대한 처리로 cascade 가 있다.

본래라면 상위 엔티티인 Restriction 을 먼저 save 하고 RestrictionHistory 에 저장된 Restriction 을 set() 처리한 후에 save 해야하는 데, Restriction 을 save 하지 않고 단순히 set()으로 RestrictionHistory 객체에 담기만 하고 RestrictionHistory 만 save 하더라도 Restriction 에도 save가 되어있다.

  ```java
@Table(name = "TB_RestrictionHistory")
@Entity
@Data
public class RestrictionHistory {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long seq;

    @JoinColumn(referencedColumnName = "RestrictionNo")
//    http://wonwoo.ml/index.php/post/1002
//    object references an unsaved transient instance, RestrictionList 가 save 되기 전에 이를 호출하면 에러가 나기 때문에 cascade 옵션을 준다.
//    옵션 중에서는 persist 가 해당한다. persist 는 관계 대상의 save를 잊더라도 영속성이 전이되게 해준다. ALL로 해도 동작은 하지만 의 경우 다른 의미를 가짐으로 persist 한다.
    @OneToOne(cascade = CascadeType.PERSIST)
    private Restriction restriction;

    private String location;
    private String ip;

  ```



cascade 옵션에 대한 내용

https://stackoverflow.com/questions/5383612/setting-up-table-relations-what-do-cascade-set-null-and-restrict-do