---
layout: post
title:  "자바 아티팩트를 도커로 배포"
author: "glqdlt"
---


//    https://stackoverflow.com/questions/7688891/sql-like-vs-contains-different-results
//    Like 는 에러가 난다. containing 하고 차이가 뭘까?
//    SignUp findAllByPlayerIdLike(String id);
//    boolean existsAllByIpLike(String ip);
//    boolean existsAllByIpIsLike(String ip);
//    List<SignUp> findAllByIpLike(String ip);
//    boolean existsAllByDeviceKeyLike(String devicey);


    like 는 .. … where x.firstname like ?1

    containing 은 … where x.firstname like ?1 (parameter bound wrapped in %)

	두 개의 차이는 containing 이 우리가 많이 쓰는 like

	contins 도 있는 데 이는 파라미터가 복수형인 콜렉션 타입일 때 쓰는 것이다

	Object on collection like properties as contains.

	https://docs.spring.io/spring-data/jpa/docs/current/reference/html/

	```java
	interface UserRepository extends CrudRepository<User, String>,
                                 QuerydslPredicateExecutor<User>,                
                                 QuerydslBinderCustomizer<QUser> {               

  @Override
  default void customize(QuerydslBindings bindings, QUser user) {

    bindings.bind(user.username).first((path, value) -> path.contains(value))    
    bindings.bind(String.class)
      .first((StringPath path, String value) -> path.containsIgnoreCase(value)); 
    bindings.excluding(user.password);                                           
  }
}

	```


자바에서 관계가 형성 된 엔티티끼리에서 FK를 가지는 하위 엔티티에서 save 시에 상위 엔티티에도 저장이 자동으로 되게할 것인지에 대한 처리로 cascade 가 있다.

본래라면 상위 엔티티인 Restriction 을 먼저 save 하고 RestrictionHistory 에 저장된 Restriction 을 set() 처리한 후에 save 해야하는 데, Restriction 을 save 하지 않고 단순히 set()으로 RestrictionHistory 객체에 담기만 하고 RestrictionHistory 만 save 하더라도 Restriction 에도 save가 되어있다.

  ```java
@Table(name = "TB_RestrictionHistory")
@Entity
@Data
public class RestrictionHistory {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long seq;

    @JoinColumn(referencedColumnName = "RestrictionNo")
//    http://wonwoo.ml/index.php/post/1002
//    object references an unsaved transient instance, RestrictionList 가 save 되기 전에 이를 호출하면 에러가 나기 때문에 cascade 옵션을 준다.
//    옵션 중에서는 persist 가 해당한다. persist 는 관계 대상의 save를 잊더라도 영속성이 전이되게 해준다. ALL로 해도 동작은 하지만 의 경우 다른 의미를 가짐으로 persist 한다.
    @OneToOne(cascade = CascadeType.PERSIST)
    private Restriction restriction;

    private String location;
    private String ip;

  ```



cascade 옵션에 대한 내용

https://stackoverflow.com/questions/5383612/setting-up-table-relations-what-do-cascade-set-null-and-restrict-do




junit4 에서 테스트할 때 Exception 이 일어날 것을 기대하는 코드에서 하위 inner Excpetion 이 n 개 이상일 때에는 catch 를 못한다. 하나만 지정이 가능하기 때문이다.

```java
@Test(expected = NullpointException.class)
....


```

junit5 에서는 아래처럼 n개의 에러 예상이 가능해진다.
```java
@Test(expectedExceptions = {IllegalArgumentException.class, NullPointerException.class})
```

https://stackoverflow.com/questions/1410172/testing-for-multiple-exceptions-with-junit-4-annotations


아래 코드에서 simply Refact 기능을 쓰면 생기는 문제점은 false 로 보내야하는 데, true 로 나오는 경우가 있다.

예를 들어 match(filter) 가 되지 않아 match가 null 일 때

이 경우에는 false 로 보내고 싶은데, 부정문인 ! 때문에 true 로 나가게 된다.

```java

   private boolean matchLastedDateWithDayCompareNowSchedule(List<LocalTime> schedules, LocalDateTime now, Date lastedUpdated) {
        Optional<LocalTime> match = schedules.stream().filter(x -> {
            LocalDateTime lastedDateTime = DateUtils.asLocalDateTime(lastedUpdated);
            return lastedDateTime.getHour() == x.getHour() &&
                    lastedDateTime.getDayOfMonth() == now.getDayOfMonth() &&
                    lastedDateTime.getMonth() == now.getMonth();
        }).findAny();

        // if(match.isPresent()){
        //     return false;
        // }else {
        //     return true;
        // }

      return !match.isPresent();

    }

```


hibernate_sequence 란 테이블이 만들어지길래 찾아보니

AUTO로 명시되어있기 때문에 Table 을 만들었다고 한다.

  @GeneratedValue(strategy = GenerationType.AUTO) 
  여서 

  mysql 은 IDENTITY 를 사용하기 때문에 INDENTITY로 설정해주면 DB에서 찾아온다.

  https://vladmihalcea.com/hibernate-identity-sequence-and-table-sequence-generator/




JPA 는 bulk insert 를 지원하지 않는다.

hibernate 에는 [이렇게](http://docs.jboss.org/hibernate/core/3.3/reference/en/html/batch.html) 가이드 해주고 있다.


hibernate 기준으로 꼼수로 

```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .setCacheMode(CacheMode.IGNORE)
    .scroll(ScrollMode.FORWARD_ONLY);
int count=0;
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    if ( ++count % 20 == 0 ) {
        //flush a batch of updates and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();
```

이 과정에서의 문제점은

이에 대한 내용은 [탁구치는 개발자님](https://lng1982.tistory.com/296) 도 추천해주고 있다.

여기서의 문제점은 

기존 saveAndFlush() 를 호출하게 되면 나타나는 문제가
```java
@ID
@GenerateValue(strategy = IDENTITY)
```

기존키 생성 전략이 IDENTITY 와 같은 DB 에 의존하는 경우라면

DB에 저장 > auto_increment 의 값을 가져옴 > 엔티티를 영속화 

하는 기본 개념을 어긋난

 auto_increment 의 값 없이 엔티티를 영속화 > DB에 저장 > clear

의 과정을 밟기 때문에 auto_increment 를 찾아와야 한다.

entitymanager 를 불러와서 직접 하는 것은

JPA 의 Repository는 추상화 전략 떄문에 flush 와 save는 있지만 clear 는 없다.

http://forum.spring.io/forum/spring-projects/data/110554-jparepository-why-no-clear


플러시에 대한 개념은 아래와 같다.

http://wonwoo.ml/index.php/post/997



Spring은 다양한 트랜잭션 매니저를 추상화한 PlatformTransactionManager  가 있다.

JPA의 경우에는 구현체로 JpaTransactionManager()가 있다. 당연히 이 녀석은 JPA 이기에 EntityManagerFac 을 속성으로 받는다.

이 녀석을 Bean 으로 올려주면 된다.

Multi TXM(트랜잭션 매니저)의 경우에는 한놈에게 @primary 를 선언해주고 다른 놈들은 각자 EMF(엔티티매니저 팩토리)를 엮어서 
각자의 TXM 을 만들어 주면 된다.

아래는 실제 필드에서 사용했던 config 소스의 일부이다.

```java

@Configuration
@EnableJpaRepositories(
        basePackages = "com.{some}.{som2}.system",
        entityManagerFactoryRef = "smsdEMF",
        transactionManagerRef = "smsdTXM")
@EnableTransactionManagement
public class SmsdJpaConfig {

    @Primary
    @Bean(name = "smsdDataSource")
    @ConfigurationProperties(prefix = "smsd.datasource")
    public DataSource smsdDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Primary
    @Bean(name = "smsdEMF")
    public LocalContainerEntityManagerFactoryBean smsdEMF(@Qualifier("smsdDataSource") DataSource dataSource) {
        LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
        factoryBean.setDataSource(dataSource);
        factoryBean.setPackagesToScan("com.{some}.{som2}.system");
        factoryBean.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
        factoryBean.setJpaProperties(hibernateProperties());
        return factoryBean;
    }

    @Bean(name = "smsdTXM")
    @Primary
    public PlatformTransactionManager platformTransactionManager(@Qualifier("smsdEMF") EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }

    private Properties hibernateProperties() {
        Properties properties = new Properties();
        properties.setProperty("hibernate.hbm2ddl.auto", "none");
        properties.setProperty(
                "hibernate.dialect", "org.hibernate.dialect.MySQL5Dialect");
        return properties;
    }
}

```
