---
layout: post
title:  "자바 아티팩트를 도커로 배포"
author: "glqdlt"
---


//    https://stackoverflow.com/questions/7688891/sql-like-vs-contains-different-results
//    Like 는 에러가 난다. containing 하고 차이가 뭘까?
//    SignUp findAllByPlayerIdLike(String id);
//    boolean existsAllByIpLike(String ip);
//    boolean existsAllByIpIsLike(String ip);
//    List<SignUp> findAllByIpLike(String ip);
//    boolean existsAllByDeviceKeyLike(String devicey);


    like 는 .. … where x.firstname like ?1

    containing 은 … where x.firstname like ?1 (parameter bound wrapped in %)

	두 개의 차이는 containing 이 우리가 많이 쓰는 like

	contins 도 있는 데 이는 파라미터가 복수형인 콜렉션 타입일 때 쓰는 것이다

	Object on collection like properties as contains.

	https://docs.spring.io/spring-data/jpa/docs/current/reference/html/

	```java
	interface UserRepository extends CrudRepository<User, String>,
                                 QuerydslPredicateExecutor<User>,                
                                 QuerydslBinderCustomizer<QUser> {               

  @Override
  default void customize(QuerydslBindings bindings, QUser user) {

    bindings.bind(user.username).first((path, value) -> path.contains(value))    
    bindings.bind(String.class)
      .first((StringPath path, String value) -> path.containsIgnoreCase(value)); 
    bindings.excluding(user.password);                                           
  }
}

	```


자바에서 관계가 형성 된 엔티티끼리에서 FK를 가지는 하위 엔티티에서 save 시에 상위 엔티티에도 저장이 자동으로 되게할 것인지에 대한 처리로 cascade 가 있다.

본래라면 상위 엔티티인 Restriction 을 먼저 save 하고 RestrictionHistory 에 저장된 Restriction 을 set() 처리한 후에 save 해야하는 데, Restriction 을 save 하지 않고 단순히 set()으로 RestrictionHistory 객체에 담기만 하고 RestrictionHistory 만 save 하더라도 Restriction 에도 save가 되어있다.

  ```java
@Table(name = "TB_RestrictionHistory")
@Entity
@Data
public class RestrictionHistory {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long seq;

    @JoinColumn(referencedColumnName = "RestrictionNo")
//    http://wonwoo.ml/index.php/post/1002
//    object references an unsaved transient instance, RestrictionList 가 save 되기 전에 이를 호출하면 에러가 나기 때문에 cascade 옵션을 준다.
//    옵션 중에서는 persist 가 해당한다. persist 는 관계 대상의 save를 잊더라도 영속성이 전이되게 해준다. ALL로 해도 동작은 하지만 의 경우 다른 의미를 가짐으로 persist 한다.
    @OneToOne(cascade = CascadeType.PERSIST)
    private Restriction restriction;

    private String location;
    private String ip;

  ```



cascade 옵션에 대한 내용

https://stackoverflow.com/questions/5383612/setting-up-table-relations-what-do-cascade-set-null-and-restrict-do




junit4 에서 테스트할 때 Exception 이 일어날 것을 기대하는 코드에서 하위 inner Excpetion 이 n 개 이상일 때에는 catch 를 못한다. 하나만 지정이 가능하기 때문이다.

```java
@Test(expected = NullpointException.class)
....


```

junit5 에서는 아래처럼 n개의 에러 예상이 가능해진다.
```java
@Test(expectedExceptions = {IllegalArgumentException.class, NullPointerException.class})
```

https://stackoverflow.com/questions/1410172/testing-for-multiple-exceptions-with-junit-4-annotations


아래 코드에서 simply Refact 기능을 쓰면 생기는 문제점은 false 로 보내야하는 데, true 로 나오는 경우가 있다.

예를 들어 match(filter) 가 되지 않아 match가 null 일 때

이 경우에는 false 로 보내고 싶은데, 부정문인 ! 때문에 true 로 나가게 된다.

```java

   private boolean matchLastedDateWithDayCompareNowSchedule(List<LocalTime> schedules, LocalDateTime now, Date lastedUpdated) {
        Optional<LocalTime> match = schedules.stream().filter(x -> {
            LocalDateTime lastedDateTime = DateUtils.asLocalDateTime(lastedUpdated);
            return lastedDateTime.getHour() == x.getHour() &&
                    lastedDateTime.getDayOfMonth() == now.getDayOfMonth() &&
                    lastedDateTime.getMonth() == now.getMonth();
        }).findAny();

        // if(match.isPresent()){
        //     return false;
        // }else {
        //     return true;
        // }

      return !match.isPresent();

    }

```


hibernate_sequence 란 테이블이 만들어지길래 찾아보니

AUTO로 명시되어있기 때문에 Table 을 만들었다고 한다.

  @GeneratedValue(strategy = GenerationType.AUTO) 
  여서 

  mysql 은 IDENTITY 를 사용하기 때문에 INDENTITY로 설정해주면 DB에서 찾아온다.

  https://vladmihalcea.com/hibernate-identity-sequence-and-table-sequence-generator/

